/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const LWIP_IPV4: u32 = 1;
pub const LWIP_IPV6: u32 = 1;
pub const LWIP_IPV6_DHCP6: u32 = 1;
pub const LWIP_DEBUG: u32 = 1;
pub const LWIP_ERRNO_STDINCLUDE: u32 = 1;
pub const NO_SYS: u32 = 0;
pub const LWIP_TCPIP_CORE_LOCKING: u32 = 1;
pub const LWIP_TCPIP_CORE_LOCKING_INPUT: u32 = 1;
pub const SYS_LIGHTWEIGHT_PROT: u32 = 1;
pub const MEM_LIBC_MALLOC: u32 = 1;
pub const MEMP_MEM_MALLOC: u32 = 1;
pub const MEM_ALIGNMENT: u32 = 1;
pub const MEM_SIZE: u32 = 16000;
pub const LWIP_ARP: u32 = 1;
pub const IP_FORWARD: u32 = 0;
pub const IP_OPTIONS_ALLOWED: u32 = 1;
pub const IP_REASSEMBLY: u32 = 1;
pub const IP_FRAG: u32 = 1;
pub const IP_REASS_MAXAGE: u32 = 3;
pub const IP_REASS_MAX_PBUFS: u32 = 10;
pub const IP_FRAG_USES_STATIC_BUF: u32 = 0;
pub const IP_DEFAULT_TTL: u32 = 255;
pub const LWIP_ICMP: u32 = 1;
pub const ICMP_TTL: u32 = 255;
pub const LWIP_RAW: u32 = 1;
pub const LWIP_DHCP: u32 = 1;
pub const LWIP_AUTOIP: u32 = 1;
pub const LWIP_SNMP: u32 = 1;
pub const LWIP_MIB2_CALLBACKS: u32 = 0;
pub const MIB2_STATS: u32 = 1;
pub const LWIP_IGMP: u32 = 0;
pub const LWIP_DNS: u32 = 1;
pub const LWIP_UDP: u32 = 1;
pub const LWIP_UDPLITE: u32 = 0;
pub const UDP_TTL: u32 = 255;
pub const LWIP_TCP: u32 = 1;
pub const TCP_MSS: u32 = 1432;
pub const TCP_WND: u32 = 64440;
pub const TCP_SND_BUF: u32 = 64440;
pub const PBUF_LINK_HLEN: u32 = 16;
pub const LWIP_SINGLE_NETIF: u32 = 1;
pub const LWIP_NETIF_API: u32 = 1;
pub const LWIP_HAVE_LOOPIF: u32 = 0;
pub const TCPIP_THREAD_STACKSIZE: u32 = 4096;
pub const DEFAULT_THREAD_STACKSIZE: u32 = 4096;
pub const LWIP_NETCONN: u32 = 1;
pub const LWIP_SOCKET: u32 = 1;
pub const LWIP_STATS: u32 = 1;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const _PDCLIB_HOSTED: u32 = 1;
pub const __STDC_WANT_LIB_EXT1_PREVIOUS__: i32 = -1;
pub const _PDCLIB_endl: &[u8; 2usize] = b"\n\0";
pub const _PDCLIB_SUCCESS: u32 = 0;
pub const _PDCLIB_FAILURE: i32 = -1;
pub const _PDCLIB_CHAR_SIGNED: u32 = 1;
pub const _PDCLIB_SHRT_BYTES: u32 = 2;
pub const _PDCLIB_INT_BYTES: u32 = 4;
pub const _PDCLIB_LONG_BYTES: u32 = 4;
pub const _PDCLIB_LLONG_BYTES: u32 = 8;
pub const _PDCLIB_CLOCKS_PER_SEC: u32 = 1000;
pub const _PDCLIB_TIME_UTC: u32 = 1;
pub const _PDCLIB_FLT_ROUNDS: i32 = -1;
pub const _PDCLIB_FLT_EVAL_METHOD: i32 = -1;
pub const _PDCLIB_DECIMAL_DIG: u32 = 17;
pub const _PDCLIB_PAGESIZE: u32 = 4096;
pub const _PDCLIB_MINALLOC: u32 = 8;
pub const _PDCLIB_BUFSIZ: u32 = 1024;
pub const _PDCLIB_FOPEN_MAX: u32 = 8;
pub const _PDCLIB_FILENAME_MAX: u32 = 128;
pub const _PDCLIB_L_tmpnam: u32 = 46;
pub const _PDCLIB_TMP_MAX: u32 = 50;
pub const _PDCLIB_SEEK_SET: u32 = 0;
pub const _PDCLIB_SEEK_CUR: u32 = 1;
pub const _PDCLIB_SEEK_END: u32 = 2;
pub const _PDCLIB_UNGETCBUFSIZE: u32 = 1;
pub const _PDCLIB_ATEXIT_SLOTS: u32 = 40;
pub const _PDCLIB_E2BIG: u32 = 7;
pub const _PDCLIB_EACCES: u32 = 13;
pub const _PDCLIB_EADDRINUSE: u32 = 100;
pub const _PDCLIB_EADDRNOTAVAIL: u32 = 101;
pub const _PDCLIB_EAFNOSUPPORT: u32 = 102;
pub const _PDCLIB_EAGAIN: u32 = 11;
pub const _PDCLIB_EALREADY: u32 = 103;
pub const _PDCLIB_EBADF: u32 = 9;
pub const _PDCLIB_EBADMSG: u32 = 104;
pub const _PDCLIB_EBUSY: u32 = 16;
pub const _PDCLIB_ECANCELED: u32 = 105;
pub const _PDCLIB_ECHILD: u32 = 10;
pub const _PDCLIB_ECONNABORTED: u32 = 106;
pub const _PDCLIB_ECONNREFUSED: u32 = 107;
pub const _PDCLIB_ECONNRESET: u32 = 108;
pub const _PDCLIB_EDEADLK: u32 = 36;
pub const _PDCLIB_EDESTADDRREQ: u32 = 109;
pub const _PDCLIB_EDOM: u32 = 33;
pub const _PDCLIB_EEXIST: u32 = 17;
pub const _PDCLIB_EFAULT: u32 = 14;
pub const _PDCLIB_EFBIG: u32 = 27;
pub const _PDCLIB_EHOSTUNREACH: u32 = 110;
pub const _PDCLIB_EIDRM: u32 = 111;
pub const _PDCLIB_EILSEQ: u32 = 42;
pub const _PDCLIB_EINPROGRESS: u32 = 112;
pub const _PDCLIB_EINTR: u32 = 4;
pub const _PDCLIB_EINVAL: u32 = 22;
pub const _PDCLIB_EIO: u32 = 5;
pub const _PDCLIB_EISCONN: u32 = 113;
pub const _PDCLIB_EISDIR: u32 = 21;
pub const _PDCLIB_ELOOP: u32 = 114;
pub const _PDCLIB_EMFILE: u32 = 24;
pub const _PDCLIB_EMLINK: u32 = 31;
pub const _PDCLIB_EMSGSIZE: u32 = 115;
pub const _PDCLIB_ENAMETOOLONG: u32 = 38;
pub const _PDCLIB_ENETDOWN: u32 = 116;
pub const _PDCLIB_ENETRESET: u32 = 117;
pub const _PDCLIB_ENETUNREACH: u32 = 118;
pub const _PDCLIB_ENFILE: u32 = 23;
pub const _PDCLIB_ENOBUFS: u32 = 119;
pub const _PDCLIB_ENODATA: u32 = 120;
pub const _PDCLIB_ENODEV: u32 = 19;
pub const _PDCLIB_ENOENT: u32 = 2;
pub const _PDCLIB_ENOEXEC: u32 = 8;
pub const _PDCLIB_ENOLCK: u32 = 39;
pub const _PDCLIB_ENOLINK: u32 = 121;
pub const _PDCLIB_ENOMEM: u32 = 12;
pub const _PDCLIB_ENOMSG: u32 = 122;
pub const _PDCLIB_ENOPROTOOPT: u32 = 123;
pub const _PDCLIB_ENOSPC: u32 = 28;
pub const _PDCLIB_ENOSR: u32 = 124;
pub const _PDCLIB_ENOSTR: u32 = 125;
pub const _PDCLIB_ENOSYS: u32 = 40;
pub const _PDCLIB_ENOTCONN: u32 = 126;
pub const _PDCLIB_ENOTDIR: u32 = 20;
pub const _PDCLIB_ENOTEMPTY: u32 = 41;
pub const _PDCLIB_ENOTRECOVERABLE: u32 = 127;
pub const _PDCLIB_ENOTSOCK: u32 = 128;
pub const _PDCLIB_ENOTSUP: u32 = 129;
pub const _PDCLIB_ENOTTY: u32 = 25;
pub const _PDCLIB_ENXIO: u32 = 6;
pub const _PDCLIB_EOPNOTSUPP: u32 = 130;
pub const _PDCLIB_EOVERFLOW: u32 = 132;
pub const _PDCLIB_EOWNERDEAD: u32 = 133;
pub const _PDCLIB_EPERM: u32 = 1;
pub const _PDCLIB_EPIPE: u32 = 32;
pub const _PDCLIB_EPROTO: u32 = 134;
pub const _PDCLIB_EPROTONOSUPPORT: u32 = 135;
pub const _PDCLIB_EPROTOTYPE: u32 = 136;
pub const _PDCLIB_ERANGE: u32 = 34;
pub const _PDCLIB_EROFS: u32 = 30;
pub const _PDCLIB_ESPIPE: u32 = 29;
pub const _PDCLIB_ESRCH: u32 = 3;
pub const _PDCLIB_ETIME: u32 = 137;
pub const _PDCLIB_ETIMEDOUT: u32 = 138;
pub const _PDCLIB_ETXTBSY: u32 = 139;
pub const _PDCLIB_EWOULDBLOCK: u32 = 140;
pub const _PDCLIB_EXDEV: u32 = 18;
pub const _PDCLIB_ERRNO_MAX: u32 = 141;
pub const _PDCLIB_LOCALE_PATH: &[u8; 23usize] = b"/usr/share/pdclib/i18n\0";
pub const _PDCLIB_ONCE_FLAG_INIT: u32 = 0;
pub const _PDCLIB_TSS_DTOR_ITERATIONS: u32 = 4;
pub const _PDCLIB_NULL: u32 = 0;
pub const _PDCLIB_CHAR_BIT: u32 = 8;
pub const _PDCLIB_UCHAR_MIN: u32 = 0;
pub const _PDCLIB_UCHAR_MAX: u32 = 255;
pub const _PDCLIB_SCHAR_MIN: i32 = -128;
pub const _PDCLIB_SCHAR_MAX: u32 = 127;
pub const _PDCLIB_CHAR_MIN: i32 = -128;
pub const _PDCLIB_CHAR_MAX: u32 = 127;
pub const _PDCLIB_SHRT_MAX: u32 = 32767;
pub const _PDCLIB_SHRT_MIN: i32 = -32768;
pub const _PDCLIB_USHRT_MAX: u32 = 65535;
pub const _PDCLIB_USHRT_MIN: u32 = 0;
pub const _PDCLIB_INT_MAX: u32 = 2147483647;
pub const _PDCLIB_INT_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT_MAX: u32 = 4294967295;
pub const _PDCLIB_UINT_MIN: u32 = 0;
pub const _PDCLIB_LONG_MAX: u32 = 2147483647;
pub const _PDCLIB_LONG_MIN: i32 = -2147483648;
pub const _PDCLIB_ULONG_MAX: u32 = 4294967295;
pub const _PDCLIB_ULONG_MIN: u32 = 0;
pub const _PDCLIB_LLONG_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_LLONG_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_ULLONG_MAX: i32 = -1;
pub const _PDCLIB_ULLONG_MIN: u32 = 0;
pub const _PDCLIB_INT8_MAX: u32 = 127;
pub const _PDCLIB_INT8_MIN: i32 = -128;
pub const _PDCLIB_UINT8_MAX: u32 = 255;
pub const _PDCLIB_INT16_MAX: u32 = 32767;
pub const _PDCLIB_INT16_MIN: i32 = -32768;
pub const _PDCLIB_UINT16_MAX: u32 = 65535;
pub const _PDCLIB_INT32_MAX: u32 = 2147483647;
pub const _PDCLIB_INT32_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT32_MAX: u32 = 4294967295;
pub const _PDCLIB_INT64_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_INT64_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_UINT64_MAX: i32 = -1;
pub const _PDCLIB_FREAD: u32 = 8;
pub const _PDCLIB_FWRITE: u32 = 16;
pub const _PDCLIB_FAPPEND: u32 = 32;
pub const _PDCLIB_FRW: u32 = 64;
pub const _PDCLIB_FBIN: u32 = 128;
pub const _PDCLIB_FREEBUFFER: u32 = 256;
pub const _PDCLIB_ERRORFLAG: u32 = 512;
pub const _PDCLIB_EOFFLAG: u32 = 1024;
pub const _PDCLIB_WIDESTREAM: u32 = 2048;
pub const _PDCLIB_BYTESTREAM: u32 = 4096;
pub const _PDCLIB_DELONCLOSE: u32 = 8192;
pub const _PDCLIB_STATIC: u32 = 16384;
pub const _PDCLIB_FREENAME: u32 = 32768;
pub const _PDCLIB_LC_ALL: u32 = 0;
pub const _PDCLIB_LC_COLLATE: u32 = 1;
pub const _PDCLIB_LC_CTYPE: u32 = 2;
pub const _PDCLIB_LC_MONETARY: u32 = 3;
pub const _PDCLIB_LC_NUMERIC: u32 = 4;
pub const _PDCLIB_LC_TIME: u32 = 5;
pub const _PDCLIB_LC_MESSAGES: u32 = 6;
pub const _PDCLIB_LC_COUNT: u32 = 7;
pub const _PDCLIB_CTYPE_ALPHA: u32 = 1;
pub const _PDCLIB_CTYPE_BLANK: u32 = 2;
pub const _PDCLIB_CTYPE_CNTRL: u32 = 4;
pub const _PDCLIB_CTYPE_GRAPH: u32 = 8;
pub const _PDCLIB_CTYPE_PUNCT: u32 = 16;
pub const _PDCLIB_CTYPE_SPACE: u32 = 32;
pub const _PDCLIB_CTYPE_LOWER: u32 = 64;
pub const _PDCLIB_CTYPE_UPPER: u32 = 128;
pub const _PDCLIB_CHARSET_SIZE: u32 = 256;
pub const NULL: u32 = 0;
pub const RAND_MAX: u32 = 32767;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: i32 = -1;
pub const _sys_nerr: u32 = 141;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const MB_CUR_MAX: u32 = 2;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const WHITE: u32 = 16777215;
pub const BLACK: u32 = 0;
pub const WHITE_16BPP: u32 = 65535;
pub const BLACK_16BPP: u32 = 0;
pub const WHITE_15BPP: u32 = 32767;
pub const BLACK_15BPP: u32 = 0;
pub const MAXDWORD: u32 = 4294967295;
pub const CONTEXT_X86: u32 = 65536;
pub const CONTEXT_i386: u32 = 65536;
pub const CONTEXT_CONTROL: u32 = 65537;
pub const CONTEXT_INTEGER: u32 = 65538;
pub const CONTEXT_SEGMENTS: u32 = 65540;
pub const CONTEXT_FLOATING_POINT: u32 = 65544;
pub const CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const INVALID_FILE_ATTRIBUTES: u32 = 4294967295;
pub const MAX_PATH: u32 = 260;
pub const IMAGE_DOS_SIGNATURE: u32 = 23117;
pub const IMAGE_NT_SIGNATURE: u32 = 17744;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC: u32 = 267;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC: u32 = 523;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC: u32 = 263;
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC: u32 = 267;
pub const IMAGE_SUBSYSTEM_UNKNOWN: u32 = 0;
pub const IMAGE_SUBSYSTEM_NATIVE: u32 = 1;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI: u32 = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI: u32 = 3;
pub const IMAGE_SUBSYSTEM_OS2_CUI: u32 = 5;
pub const IMAGE_SUBSYSTEM_POSIX_CUI: u32 = 7;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: u32 = 9;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: u32 = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: u32 = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: u32 = 12;
pub const IMAGE_SUBSYSTEM_EFI_ROM: u32 = 13;
pub const IMAGE_SUBSYSTEM_XBOX: u32 = 14;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION: u32 = 16;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY: u32 = 128;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT: u32 = 256;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION: u32 = 512;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH: u32 = 1024;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND: u32 = 2048;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: u32 = 8192;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: u32 = 32768;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT: u32 = 0;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT: u32 = 1;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE: u32 = 2;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION: u32 = 3;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY: u32 = 4;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC: u32 = 5;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG: u32 = 6;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: u32 = 7;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR: u32 = 8;
pub const IMAGE_DIRECTORY_ENTRY_TLS: u32 = 9;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: u32 = 10;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: u32 = 11;
pub const IMAGE_DIRECTORY_ENTRY_IAT: u32 = 12;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: u32 = 13;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: u32 = 14;
pub const IMAGE_FILE_MACHINE_I386: u32 = 332;
pub const IMAGE_FILE_MACHINE_IA64: u32 = 512;
pub const IMAGE_FILE_MACHINE_AMD64: u32 = 34404;
pub const IMAGE_FILE_RELOCS_STRIPPED: u32 = 1;
pub const IMAGE_FILE_EXECUTABLE_IMAGE: u32 = 2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED: u32 = 4;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED: u32 = 8;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM: u32 = 16;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE: u32 = 32;
pub const IMAGE_FILE_BYTES_REVERSED_LO: u32 = 128;
pub const IMAGE_FILE_32BIT_MACHINE: u32 = 256;
pub const IMAGE_FILE_DEBUG_STRIPPED: u32 = 512;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: u32 = 1024;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP: u32 = 2048;
pub const IMAGE_FILE_SYSTEM: u32 = 4096;
pub const IMAGE_FILE_DLL: u32 = 8192;
pub const IMAGE_FILE_UP_SYSTEM_ONLY: u32 = 16384;
pub const IMAGE_FILE_BYTES_REVERSED_HI: u32 = 32768;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8;
pub const XBE_DEFAULT_BASE: u32 = 65536;
pub const INFINITE: u32 = 4294967295;
pub const CREATE_SUSPENDED: u32 = 4;
pub const STACK_SIZE_PARAM_IS_A_RESERVATION: u32 = 65536;
pub const THREAD_PRIORITY_ABOVE_NORMAL: u32 = 1;
pub const THREAD_PRIOIRTY_BELOW_NORMAL: i32 = -1;
pub const THREAD_PRIORITY_HIGHEST: u32 = 2;
pub const THREAD_PRIORITY_IDLE: i32 = -15;
pub const THREAD_PRIORITY_LOWEST: i32 = -2;
pub const THREAD_PRIORITY_NORMAL: u32 = 0;
pub const THREAD_PRIORITY_TIME_CRITICAL: u32 = 15;
pub const THREAD_PRIORITY_ERROR_RETURN: u32 = 2147483647;
pub const FLS_OUT_OF_INDEXES: u32 = 4294967295;
pub const FLS_MAXIMUM_AVAILABLE: u32 = 64;
pub const TLS_OUT_OF_INDEXES: u32 = 4294967295;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64;
pub const INIT_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const INIT_ONCE_CHECK_ONLY: u32 = 1;
pub const INIT_ONCE_ASYNC: u32 = 2;
pub const INIT_ONCE_INIT_FAILED: u32 = 4;
pub const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const FILE_BEGIN: u32 = 0;
pub const FILE_CURRENT: u32 = 1;
pub const FILE_END: u32 = 2;
pub const FILE_FLAG_WRITE_THROUGH: u32 = 2147483648;
pub const FILE_FLAG_OVERLAPPED: u32 = 1073741824;
pub const FILE_FLAG_NO_BUFFERING: u32 = 536870912;
pub const FILE_FLAG_RANDOM_ACCESS: u32 = 268435456;
pub const FILE_FLAG_SEQUENTIAL_SCAN: u32 = 134217728;
pub const FILE_FLAG_DELETE_ON_CLOSE: u32 = 67108864;
pub const FILE_FLAG_BACKUP_SEMANTICS: u32 = 33554432;
pub const FILE_FLAG_POSIX_SEMANTICS: u32 = 16777216;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const CREATE_NEW: u32 = 1;
pub const CREATE_ALWAYS: u32 = 2;
pub const OPEN_EXISTING: u32 = 3;
pub const OPEN_ALWAYS: u32 = 4;
pub const TRUNCATE_EXISTING: u32 = 5;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const AV_PACK_NONE: u32 = 0;
pub const AV_PACK_STANDARD: u32 = 1;
pub const AV_PACK_RFU: u32 = 2;
pub const AV_PACK_SCART: u32 = 3;
pub const AV_PACK_HDTV: u32 = 4;
pub const AV_PACK_VGA: u32 = 5;
pub const AV_PACK_SVIDEO: u32 = 6;
pub const PAGE_SIZE: u32 = 4096;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_VALID_ATTRIBUTES: u32 = 498;
pub const LDT_TITLE: u32 = 0;
pub const LDT_LAUNCH_DASHBOARD: u32 = 1;
pub const LDT_FROM_DASHBOARD: u32 = 2;
pub const LDT_NONE: u32 = 4294967295;
pub const XBOX_HW_FLAG_INTERNAL_USB_HUB: u32 = 1;
pub const XBOX_HW_FLAG_DEVKIT_KERNEL: u32 = 2;
pub const XBOX_480P_MACROVISION_ENABLED: u32 = 4;
pub const XBOX_HW_FLAG_ARCADE: u32 = 8;
pub const XBOX_KEY_LENGTH: u32 = 16;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_CREATE_OPERATION: u32 = 8;
pub const IRP_READ_OPERATION: u32 = 16;
pub const IRP_WRITE_OPERATION: u32 = 32;
pub const IRP_CLOSE_OPERATION: u32 = 64;
pub const IRP_DEFER_IO_COMPLETION: u32 = 128;
pub const IRP_OB_QUERY_NAME: u32 = 256;
pub const IRP_UNLOCK_USER_BUFFER: u32 = 512;
pub const IRP_SCATTER_GATHER_OPERATION: u32 = 1024;
pub const IRP_UNMAP_SEGMENT_ARRAY: u32 = 2048;
pub const IRP_NO_CANCELIO: u32 = 4096;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const XNET_ETHERNET_LINK_ACTIVE: u32 = 1;
pub const XNET_ETHERNET_LINK_100MBPS: u32 = 2;
pub const XNET_ETHERNET_LINK_10MBPS: u32 = 4;
pub const XNET_ETHERNET_LINK_FULL_DUPLEX: u32 = 8;
pub const XNET_ETHERNET_LINK_HALF_DUPLEX: u32 = 16;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const IOCTL_DISK_BASE: u32 = 7;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_FOR_RECOVERY: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const FILE_COPY_STRUCTURED_STORAGE: u32 = 65;
pub const FILE_STRUCTURED_STORAGE: u32 = 1089;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const ERESOURCE_INCREMENT: u32 = 4;
pub const EVENT_INCREMENT: u32 = 1;
pub const EVENT_PAIR_INCREMENT: u32 = 1;
pub const LPC_RELEASE_WAIT_INCREMENT: u32 = 1;
pub const IO_NO_INCREMENT: u32 = 0;
pub const IO_CD_ROM_INCREMENT: u32 = 1;
pub const IO_DISK_INCREMENT: u32 = 1;
pub const IO_PARALLEL_INCREMENT: u32 = 1;
pub const IO_VIDEO_INCREMENT: u32 = 1;
pub const IO_MAILSLOT_INCREMENT: u32 = 2;
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2;
pub const IO_NETWORK_INCREMENT: u32 = 2;
pub const IO_SERIAL_INCREMENT: u32 = 2;
pub const IO_MOUSE_INCREMENT: u32 = 6;
pub const IO_KEYBOARD_INCREMENT: u32 = 6;
pub const IO_SOUND_INCREMENT: u32 = 8;
pub const MUTANT_INCREMENT: u32 = 1;
pub const SEMAPHORE_INCREMENT: u32 = 1;
pub const TIMER_APC_INCREMENT: u32 = 0;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_VIDEO: u32 = 0;
pub const PAGE_OLD_VIDEO: u32 = 2048;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_NOZERO: u32 = 8388608;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const XC_TIMEZONE_BIAS: u32 = 0;
pub const XC_TZ_STD_NAME: u32 = 1;
pub const XC_TZ_STD_DATE: u32 = 2;
pub const XC_TZ_STD_BIAS: u32 = 3;
pub const XC_TZ_DLT_NAME: u32 = 4;
pub const XC_TZ_DLT_DATE: u32 = 5;
pub const XC_TZ_DLT_BIAS: u32 = 6;
pub const XC_LANGUAGE: u32 = 7;
pub const XC_VIDEO: u32 = 8;
pub const XC_AUDIO: u32 = 9;
pub const XC_P_CONTROL_GAMES: u32 = 10;
pub const XC_P_CONTROL_PASSWORD: u32 = 11;
pub const XC_P_CONTROL_MOVIES: u32 = 12;
pub const XC_ONLINE_IP_ADDRESS: u32 = 13;
pub const XC_ONLINE_DNS_ADDRESS: u32 = 14;
pub const XC_ONLINE_DEFAULT_GATEWAY_ADDRESS: u32 = 15;
pub const XC_ONLINE_SUBNET_ADDRESS: u32 = 16;
pub const XC_MISC: u32 = 17;
pub const XC_DVD_REGION: u32 = 18;
pub const XC_MAX_OS: u32 = 255;
pub const XC_FACTORY_START_INDEX: u32 = 256;
pub const XC_FACTORY_SERIAL_NUMBER: u32 = 256;
pub const XC_FACTORY_ETHERNET_ADDR: u32 = 257;
pub const XC_FACTORY_ONLINE_KEY: u32 = 258;
pub const XC_FACTORY_AV_REGION: u32 = 259;
pub const XC_FACTORY_GAME_REGION: u32 = 260;
pub const XC_MAX_FACTORY: u32 = 511;
pub const XC_ENCRYPTED_SECTION: u32 = 65534;
pub const XC_MAX_ALL: u32 = 65535;
pub const XC_MISC_FLAG_DISABLE_DST: u32 = 2;
pub const PROCESSOR_ARCHITECTURE_INTEL: u32 = 0;
pub const PROCESSOR_ARCHITECTURE_ARM: u32 = 5;
pub const PROCESSOR_ARCHITECTURE_IA64: u32 = 6;
pub const PROCESSOR_ARCHITECTURE_AMD64: u32 = 9;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN: u32 = 65535;
pub const ERROR_SUCCESS: u32 = 0;
pub const NO_ERROR: u32 = 0;
pub const ERROR_INVALID_FUNCTION: u32 = 1;
pub const ERROR_FILE_NOT_FOUND: u32 = 2;
pub const ERROR_PATH_NOT_FOUND: u32 = 3;
pub const ERROR_TOO_MANY_OPEN_FILES: u32 = 4;
pub const ERROR_ACCESS_DENIED: u32 = 5;
pub const ERROR_INVALID_HANDLE: u32 = 6;
pub const ERROR_ARENA_TRASHED: u32 = 7;
pub const ERROR_NOT_ENOUGH_MEMORY: u32 = 8;
pub const ERROR_INVALID_BLOCK: u32 = 9;
pub const ERROR_BAD_ENVIRONMENT: u32 = 10;
pub const ERROR_BAD_FORMAT: u32 = 11;
pub const ERROR_INVALID_ACCESS: u32 = 12;
pub const ERROR_INVALID_DATA: u32 = 13;
pub const ERROR_OUTOFMEMORY: u32 = 14;
pub const ERROR_INVALID_DRIVE: u32 = 15;
pub const ERROR_CURRENT_DIRECTORY: u32 = 16;
pub const ERROR_NOT_SAME_DEVICE: u32 = 17;
pub const ERROR_NO_MORE_FILES: u32 = 18;
pub const ERROR_WRITE_PROTECT: u32 = 19;
pub const ERROR_BAD_UNIT: u32 = 20;
pub const ERROR_NOT_READY: u32 = 21;
pub const ERROR_BAD_COMMAND: u32 = 22;
pub const ERROR_CRC: u32 = 23;
pub const ERROR_BAD_LENGTH: u32 = 24;
pub const ERROR_SEEK: u32 = 25;
pub const ERROR_NOT_DOS_DISK: u32 = 26;
pub const ERROR_SECTOR_NOT_FOUND: u32 = 27;
pub const ERROR_OUT_OF_PAPER: u32 = 28;
pub const ERROR_WRITE_FAULT: u32 = 29;
pub const ERROR_READ_FAULT: u32 = 30;
pub const ERROR_GEN_FAILURE: u32 = 31;
pub const ERROR_SHARING_VIOLATION: u32 = 32;
pub const ERROR_LOCK_VIOLATION: u32 = 33;
pub const ERROR_WRONG_DISK: u32 = 34;
pub const ERROR_SHARING_BUFFER_EXCEEDED: u32 = 36;
pub const ERROR_HANDLE_EOF: u32 = 38;
pub const ERROR_HANDLE_DISK_FULL: u32 = 39;
pub const ERROR_NOT_SUPPORTED: u32 = 50;
pub const ERROR_REM_NOT_LIST: u32 = 51;
pub const ERROR_DUP_NAME: u32 = 52;
pub const ERROR_BAD_NETPATH: u32 = 53;
pub const ERROR_NETWORK_BUSY: u32 = 54;
pub const ERROR_DEV_NOT_EXIST: u32 = 55;
pub const ERROR_TOO_MANY_CMDS: u32 = 56;
pub const ERROR_ADAP_HDW_ERR: u32 = 57;
pub const ERROR_BAD_NET_RESP: u32 = 58;
pub const ERROR_UNEXP_NET_ERR: u32 = 59;
pub const ERROR_BAD_REM_ADAP: u32 = 60;
pub const ERROR_PRINTQ_FULL: u32 = 61;
pub const ERROR_NO_SPOOL_SPACE: u32 = 62;
pub const ERROR_PRINT_CANCELLED: u32 = 63;
pub const ERROR_NETNAME_DELETED: u32 = 64;
pub const ERROR_NETWORK_ACCESS_DENIED: u32 = 65;
pub const ERROR_BAD_DEV_TYPE: u32 = 66;
pub const ERROR_BAD_NET_NAME: u32 = 67;
pub const ERROR_TOO_MANY_NAMES: u32 = 68;
pub const ERROR_TOO_MANY_SESS: u32 = 69;
pub const ERROR_SHARING_PAUSED: u32 = 70;
pub const ERROR_REQ_NOT_ACCEP: u32 = 71;
pub const ERROR_REDIR_PAUSED: u32 = 72;
pub const ERROR_FILE_EXISTS: u32 = 80;
pub const ERROR_CANNOT_MAKE: u32 = 82;
pub const ERROR_FAIL_I24: u32 = 83;
pub const ERROR_OUT_OF_STRUCTURES: u32 = 84;
pub const ERROR_ALREADY_ASSIGNED: u32 = 85;
pub const ERROR_INVALID_PASSWORD: u32 = 86;
pub const ERROR_INVALID_PARAMETER: u32 = 87;
pub const ERROR_NET_WRITE_FAULT: u32 = 88;
pub const ERROR_NO_PROC_SLOTS: u32 = 89;
pub const ERROR_TOO_MANY_SEMAPHORES: u32 = 100;
pub const ERROR_EXCL_SEM_ALREADY_OWNED: u32 = 101;
pub const ERROR_SEM_IS_SET: u32 = 102;
pub const ERROR_TOO_MANY_SEM_REQUESTS: u32 = 103;
pub const ERROR_INVALID_AT_INTERRUPT_TIME: u32 = 104;
pub const ERROR_SEM_OWNER_DIED: u32 = 105;
pub const ERROR_SEM_USER_LIMIT: u32 = 106;
pub const ERROR_DISK_CHANGE: u32 = 107;
pub const ERROR_DRIVE_LOCKED: u32 = 108;
pub const ERROR_BROKEN_PIPE: u32 = 109;
pub const ERROR_OPEN_FAILED: u32 = 110;
pub const ERROR_BUFFER_OVERFLOW: u32 = 111;
pub const ERROR_DISK_FULL: u32 = 112;
pub const ERROR_NO_MORE_SEARCH_HANDLES: u32 = 113;
pub const ERROR_INVALID_TARGET_HANDLE: u32 = 114;
pub const ERROR_INVALID_CATEGORY: u32 = 117;
pub const ERROR_INVALID_VERIFY_SWITCH: u32 = 118;
pub const ERROR_BAD_DRIVER_LEVEL: u32 = 119;
pub const ERROR_CALL_NOT_IMPLEMENTED: u32 = 120;
pub const ERROR_SEM_TIMEOUT: u32 = 121;
pub const ERROR_INSUFFICIENT_BUFFER: u32 = 122;
pub const ERROR_INVALID_NAME: u32 = 123;
pub const ERROR_INVALID_LEVEL: u32 = 124;
pub const ERROR_NO_VOLUME_LABEL: u32 = 125;
pub const ERROR_MOD_NOT_FOUND: u32 = 126;
pub const ERROR_PROC_NOT_FOUND: u32 = 127;
pub const ERROR_WAIT_NO_CHILDREN: u32 = 128;
pub const ERROR_CHILD_NOT_COMPLETE: u32 = 129;
pub const ERROR_DIRECT_ACCESS_HANDLE: u32 = 130;
pub const ERROR_NEGATIVE_SEEK: u32 = 131;
pub const ERROR_SEEK_ON_DEVICE: u32 = 132;
pub const ERROR_IS_JOIN_TARGET: u32 = 133;
pub const ERROR_IS_JOINED: u32 = 134;
pub const ERROR_IS_SUBSTED: u32 = 135;
pub const ERROR_NOT_JOINED: u32 = 136;
pub const ERROR_NOT_SUBSTED: u32 = 137;
pub const ERROR_JOIN_TO_JOIN: u32 = 138;
pub const ERROR_SUBST_TO_SUBST: u32 = 139;
pub const ERROR_JOIN_TO_SUBST: u32 = 140;
pub const ERROR_SUBST_TO_JOIN: u32 = 141;
pub const ERROR_BUSY_DRIVE: u32 = 142;
pub const ERROR_SAME_DRIVE: u32 = 143;
pub const ERROR_DIR_NOT_ROOT: u32 = 144;
pub const ERROR_DIR_NOT_EMPTY: u32 = 145;
pub const ERROR_IS_SUBST_PATH: u32 = 146;
pub const ERROR_IS_JOIN_PATH: u32 = 147;
pub const ERROR_PATH_BUSY: u32 = 148;
pub const ERROR_IS_SUBST_TARGET: u32 = 149;
pub const ERROR_SYSTEM_TRACE: u32 = 150;
pub const ERROR_INVALID_EVENT_COUNT: u32 = 151;
pub const ERROR_TOO_MANY_MUXWAITERS: u32 = 152;
pub const ERROR_INVALID_LIST_FORMAT: u32 = 153;
pub const ERROR_LABEL_TOO_LONG: u32 = 154;
pub const ERROR_TOO_MANY_TCBS: u32 = 155;
pub const ERROR_SIGNAL_REFUSED: u32 = 156;
pub const ERROR_DISCARDED: u32 = 157;
pub const ERROR_NOT_LOCKED: u32 = 158;
pub const ERROR_BAD_THREADID_ADDR: u32 = 159;
pub const ERROR_BAD_ARGUMENTS: u32 = 160;
pub const ERROR_BAD_PATHNAME: u32 = 161;
pub const ERROR_SIGNAL_PENDING: u32 = 162;
pub const ERROR_MAX_THRDS_REACHED: u32 = 164;
pub const ERROR_LOCK_FAILED: u32 = 167;
pub const ERROR_BUSY: u32 = 170;
pub const ERROR_CANCEL_VIOLATION: u32 = 173;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED: u32 = 174;
pub const ERROR_INVALID_SEGMENT_NUMBER: u32 = 180;
pub const ERROR_INVALID_ORDINAL: u32 = 182;
pub const ERROR_ALREADY_EXISTS: u32 = 183;
pub const ERROR_INVALID_FLAG_NUMBER: u32 = 186;
pub const ERROR_SEM_NOT_FOUND: u32 = 187;
pub const ERROR_INVALID_STARTING_CODESEG: u32 = 188;
pub const ERROR_INVALID_STACKSEG: u32 = 189;
pub const ERROR_INVALID_MODULETYPE: u32 = 190;
pub const ERROR_INVALID_EXE_SIGNATURE: u32 = 191;
pub const ERROR_EXE_MARKED_INVALID: u32 = 192;
pub const ERROR_BAD_EXE_FORMAT: u32 = 193;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k: u32 = 194;
pub const ERROR_INVALID_MINALLOCSIZE: u32 = 195;
pub const ERROR_DYNLINK_FROM_INVALID_RING: u32 = 196;
pub const ERROR_IOPL_NOT_ENABLED: u32 = 197;
pub const ERROR_INVALID_SEGDPL: u32 = 198;
pub const ERROR_AUTODATASEG_EXCEEDS_64k: u32 = 199;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE: u32 = 200;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM: u32 = 201;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN: u32 = 202;
pub const ERROR_ENVVAR_NOT_FOUND: u32 = 203;
pub const ERROR_NO_SIGNAL_SENT: u32 = 205;
pub const ERROR_FILENAME_EXCED_RANGE: u32 = 206;
pub const ERROR_RING2_STACK_IN_USE: u32 = 207;
pub const ERROR_META_EXPANSION_TOO_LONG: u32 = 208;
pub const ERROR_INVALID_SIGNAL_NUMBER: u32 = 209;
pub const ERROR_THREAD_1_INACTIVE: u32 = 210;
pub const ERROR_LOCKED: u32 = 212;
pub const ERROR_TOO_MANY_MODULES: u32 = 214;
pub const ERROR_NESTING_NOT_ALLOWED: u32 = 215;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH: u32 = 216;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY: u32 = 217;
pub const ERRO_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY: u32 = 218;
pub const ERROR_BAD_PIPE: u32 = 230;
pub const ERROR_PIPE_BUSY: u32 = 231;
pub const ERROR_NO_DATA: u32 = 232;
pub const ERROR_PIPE_NOT_CONNECTED: u32 = 233;
pub const ERROR_MORE_DATA: u32 = 234;
pub const ERROR_VC_DISCONNECTED: u32 = 240;
pub const ERROR_INVALID_EA_NAME: u32 = 254;
pub const ERROR_EA_LIST_INCONSISTENT: u32 = 255;
pub const ERROR_NO_MORE_ITEMS: u32 = 259;
pub const ERROR_CANNOT_COPY: u32 = 266;
pub const ERROR_DIRECTORY: u32 = 267;
pub const ERROR_EAS_DIDNT_FIT: u32 = 275;
pub const ERROR_EA_FILE_CORRUPT: u32 = 276;
pub const ERROR_EA_TABLE_FULL: u32 = 277;
pub const ERROR_INVALID_EA_HANDLE: u32 = 278;
pub const ERROR_EAS_NOT_SUPPORTED: u32 = 282;
pub const ERROR_NOT_OWNER: u32 = 288;
pub const ERROR_TOO_MANY_POSTS: u32 = 298;
pub const ERROR_PARTIAL_COPY: u32 = 299;
pub const ERROR_OPLOCK_NOT_GRANTED: u32 = 300;
pub const ERROR_INVALID_OPLOCK_PROTOCOL: u32 = 301;
pub const ERROR_DISK_TOO_FRAGMENTED: u32 = 302;
pub const ERROR_DELETE_PENDING: u32 = 303;
pub const ERROR_MR_MID_NOT_FOUND: u32 = 317;
pub const ERROR_SCOPE_NOT_FOUND: u32 = 318;
pub const ERROR_INVALID_ADDRESS: u32 = 487;
pub const ERROR_ARITHMETIC_OVERFLOW: u32 = 534;
pub const ERROR_PIPE_CONNECTED: u32 = 535;
pub const ERROR_PIPE_LISTENING: u32 = 536;
pub const ERROR_EA_ACCESS_DENIED: u32 = 994;
pub const ERROR_OPERATION_ABORTED: u32 = 995;
pub const ERROR_IO_INCOMPLETE: u32 = 996;
pub const ERROR_IO_PENDING: u32 = 997;
pub const ERROR_NOACCESS: u32 = 998;
pub const ERROR_SWAPERROR: u32 = 999;
pub const ERROR_STACK_OVERFLOW: u32 = 1001;
pub const ERROR_INVALID_MESSAGE: u32 = 1002;
pub const ERROR_CAN_NOT_COMPLETE: u32 = 1003;
pub const ERROR_INVALID_FLAGS: u32 = 1004;
pub const ERROR_UNRECOGNIZED_VOLUME: u32 = 1005;
pub const ERROR_FILE_INVALID: u32 = 1006;
pub const ERROR_FULLSCREEN_MODE: u32 = 1007;
pub const ERROR_NO_TOKEN: u32 = 1008;
pub const ERROR_BADDB: u32 = 1009;
pub const ERROR_BADKEY: u32 = 1010;
pub const ERROR_CANTOPEN: u32 = 1011;
pub const ERROR_CANTREAD: u32 = 1012;
pub const ERROR_CANTWRITE: u32 = 1013;
pub const ERROR_REGISTRY_RECOVERED: u32 = 1014;
pub const ERROR_REGISTRY_CORRUPT: u32 = 1015;
pub const ERROR_REGISTRY_IO_FAILED: u32 = 1016;
pub const ERROR_NOT_REGISTRY_FILE: u32 = 1017;
pub const ERROR_KEY_DELETED: u32 = 1018;
pub const ERROR_NO_LOG_SPACE: u32 = 1019;
pub const ERROR_KEY_HAS_CHILDREN: u32 = 1020;
pub const ERROR_CHILD_MUST_BE_VOLATILE: u32 = 1021;
pub const ERROR_NOTIFY_ENUM_DIR: u32 = 1022;
pub const ERROR_DEPENDENT_SERVICES_RUNNING: u32 = 1051;
pub const ERROR_INVALID_SERVICE_CONTROL: u32 = 1052;
pub const ERROR_SERVICE_REQUEST_TIMEOUT: u32 = 1053;
pub const ERROR_SERVICE_NO_THREAD: u32 = 1054;
pub const ERROR_SERVICE_DATABASE_LOCKED: u32 = 1055;
pub const ERROR_SERVICE_ALREADY_RUNNING: u32 = 1056;
pub const ERROR_INVALID_SERVICE_ACCOUNT: u32 = 1057;
pub const ERROR_SERVICE_DISABLED: u32 = 1058;
pub const ERROR_CIRCULAR_DEPENDENCY: u32 = 1059;
pub const ERROR_SERVICE_DOES_NOT_EXIST: u32 = 1060;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL: u32 = 1061;
pub const ERROR_SERVICE_NOT_ACTIVE: u32 = 1062;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT: u32 = 1063;
pub const ERROR_EXCEPTION_IN_SERVICE: u32 = 1064;
pub const ERROR_DATABASE_DOES_NOT_EXIST: u32 = 1065;
pub const ERROR_SERVICE_SPECIFIC_ERROR: u32 = 1066;
pub const ERROR_PROCESS_ABORTED: u32 = 1067;
pub const ERROR_SERVICE_DEPENDENCY_FAIL: u32 = 1068;
pub const ERROR_SERVICE_LOGON_FAILED: u32 = 1069;
pub const ERROR_SERVICE_START_HANG: u32 = 1070;
pub const ERROR_INVALID_SERVICE_LOCK: u32 = 1071;
pub const ERROR_SERVICE_MARKED_FOR_DELETE: u32 = 1072;
pub const ERROR_SERVICE_EXISTS: u32 = 1073;
pub const ERROR_ALREADY_RUNNING_LKG: u32 = 1074;
pub const ERROR_SERVICE_DEPENDENCY_DELETED: u32 = 1075;
pub const ERROR_BOOT_ALREADY_ACCEPTED: u32 = 1076;
pub const ERROR_SERVICE_NEVER_STARTED: u32 = 1077;
pub const ERROR_DUPLICATE_SERVICE_NAME: u32 = 1078;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT: u32 = 1079;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE: u32 = 1080;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT: u32 = 1081;
pub const ERROR_NO_RECOVERY_PROGRAM: u32 = 1082;
pub const ERROR_SERVICE_NOT_IN_EXE: u32 = 1083;
pub const ERROR_NOT_SAFEBOOT_SERVICE: u32 = 1084;
pub const ERROR_END_OF_MEDIA: u32 = 1100;
pub const ERROR_FILEMARK_DETECTED: u32 = 1101;
pub const ERROR_BEGINNING_OF_MEDIA: u32 = 1102;
pub const ERROR_SETMARK_DETECTED: u32 = 1103;
pub const ERROR_NO_DATA_DETECTED: u32 = 1104;
pub const ERROR_PARTITION_FAILURE: u32 = 1105;
pub const ERROR_INVALID_BLOCK_LENGTH: u32 = 1106;
pub const ERROR_DEVICE_NOT_PARTITIONED: u32 = 1107;
pub const ERROR_UNABLE_TO_LOCK_MEDIA: u32 = 1108;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA: u32 = 1109;
pub const ERROR_MEDIA_CHANGED: u32 = 1110;
pub const ERROR_BUS_RESET: u32 = 1111;
pub const ERROR_NO_MEDIA_IN_DRIVE: u32 = 1112;
pub const ERROR_NO_UNICODE_TRANSLATION: u32 = 1113;
pub const ERROR_DLL_INIT_FAILED: u32 = 1114;
pub const ERROR_SHUTDOWN_IN_PROGRESS: u32 = 1115;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS: u32 = 1116;
pub const ERROR_IO_DEVICE: u32 = 1117;
pub const ERROR_SERIAL_NO_DEVICE: u32 = 1118;
pub const ERROR_IRQ_BUSY: u32 = 1119;
pub const ERROR_MORE_WRITES: u32 = 1120;
pub const ERROR_COUNTER_TIMEOUT: u32 = 1121;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND: u32 = 1122;
pub const ERROR_FLOPPY_WRONG_CYLINDER: u32 = 1123;
pub const ERROR_FLOPPY_UNKNOWN_ERROR: u32 = 1124;
pub const ERROR_FLOPPY_BAD_REGISTERS: u32 = 1125;
pub const ERROR_DISK_RECALIBRATE_FAILED: u32 = 1126;
pub const ERROR_DISK_OPERATION_FAILED: u32 = 1127;
pub const ERROR_DISK_RESET_FAILED: u32 = 1128;
pub const ERROR_EOM_OVERFLOW: u32 = 1129;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY: u32 = 1130;
pub const ERROR_POSSIBLE_DEADLOCK: u32 = 1131;
pub const ERROR_MAPPED_ALIGNMENT: u32 = 1132;
pub const ERROR_SET_POWER_STATE_VETOED: u32 = 1140;
pub const ERROR_SET_POWER_STATE_FAILED: u32 = 1141;
pub const ERROR_TOO_MANY_LINKS: u32 = 1142;
pub const ERROR_OLD_WIN_VERSION: u32 = 1150;
pub const ERROR_APP_WRONG_OS: u32 = 1151;
pub const ERROR_SINGLE_INSTANCE_APP: u32 = 1152;
pub const ERROR_RMODE_APP: u32 = 1153;
pub const ERROR_INVALID_DLL: u32 = 1154;
pub const ERROR_NO_ASSOCIATION: u32 = 1155;
pub const ERROR_DDE_FAIL: u32 = 1156;
pub const ERROR_DLL_NOT_FOUND: u32 = 1157;
pub const ERROR_NO_MORE_USER_HANDLES: u32 = 1158;
pub const ERROR_MESSAGE_SYNC_ONLY: u32 = 1159;
pub const ERROR_SOURCE_ELEMENT_EMPTY: u32 = 1160;
pub const ERROR_DESTINATION_ELEMENT_FULL: u32 = 1161;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS: u32 = 1162;
pub const ERROR_MAGAZINE_NOT_PRESENT: u32 = 1163;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED: u32 = 1164;
pub const ERROR_DEVICE_REQUIRES_CLEANING: u32 = 1165;
pub const ERROR_DEVICE_DOOR_OPEN: u32 = 1166;
pub const ERROR_DEVICE_NOT_CONNECTED: u32 = 1167;
pub const ERROR_NOT_FOUND: u32 = 1168;
pub const ERROR_NO_MATCH: u32 = 1169;
pub const ERROR_SET_NOT_FOUND: u32 = 1170;
pub const ERROR_POINT_NOT_FOUND: u32 = 1171;
pub const ERROR_NO_TRACKING_SERVICE: u32 = 1172;
pub const ERROR_NO_VOLUME_ID: u32 = 1173;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED: u32 = 1175;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT: u32 = 1176;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2: u32 = 1177;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS: u32 = 1178;
pub const ERROR_JOURNAL_NOT_ACTIVE: u32 = 1179;
pub const ERROR_POTENTIAL_FILE_FOUND: u32 = 1180;
pub const ERROR_JOURNAL_ENTRY_DELETED: u32 = 1181;
pub const ERROR_BAD_DEVICE: u32 = 1200;
pub const ERROR_CONNECTION_UNAVAIL: u32 = 1201;
pub const ERROR_DEVICE_ALREADY_REMEMBERED: u32 = 1202;
pub const ERROR_NO_NET_OR_BAD_PATH: u32 = 1203;
pub const ERROR_BAD_PROVIDER: u32 = 1204;
pub const ERROR_CANNOT_OPEN_PROFILE: u32 = 1205;
pub const ERROR_BAD_PROFILE: u32 = 1206;
pub const ERROR_NOT_CONTAINER: u32 = 1207;
pub const ERROR_EXTENDED_ERROR: u32 = 1208;
pub const ERROR_INVALID_GROUPNAME: u32 = 1209;
pub const ERROR_INVALID_COMPUTERNAME: u32 = 1210;
pub const ERROR_INVALID_EVENTNAME: u32 = 1211;
pub const ERROR_INVALID_DOMAINNAME: u32 = 1212;
pub const ERROR_INVALID_SERVICENAME: u32 = 1213;
pub const ERROR_INVALID_NETNAME: u32 = 1214;
pub const ERROR_INVALID_SHARENAME: u32 = 1215;
pub const ERROR_INVALID_PASSWORDNAME: u32 = 1216;
pub const ERROR_INVALID_MESSAGENAME: u32 = 1217;
pub const ERROR_INVALID_MESSAGEDEST: u32 = 1218;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT: u32 = 1219;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED: u32 = 1220;
pub const ERROR_DUP_DOMAINNAME: u32 = 1221;
pub const ERROR_NO_NETWORK: u32 = 1222;
pub const ERROR_CANCELLED: u32 = 1223;
pub const ERROR_USER_MAPPED_FILE: u32 = 1224;
pub const ERROR_CONNECTION_REFUSED: u32 = 1225;
pub const ERROR_GRACEFUL_DISCONNECT: u32 = 1226;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED: u32 = 1227;
pub const ERROR_ADDRESS_NOT_ASSOCIATED: u32 = 1228;
pub const ERROR_CONNECTION_INVALID: u32 = 1229;
pub const ERROR_CONNECTION_ACTIVE: u32 = 1230;
pub const ERROR_NETWORK_UNREACHABLE: u32 = 1231;
pub const ERROR_HOST_UNREACHABLE: u32 = 1232;
pub const ERROR_PROTOCOL_UNREACHABLE: u32 = 1233;
pub const ERROR_PORT_UNREACHABLE: u32 = 1234;
pub const ERROR_REQUEST_ABORTED: u32 = 1235;
pub const ERROR_CONNECTION_ABORTED: u32 = 1236;
pub const ERROR_RETRY: u32 = 1237;
pub const ERROR_CONNECTION_COUNT_LIMIT: u32 = 1238;
pub const ERROR_LOGIN_TIME_RESTRICTION: u32 = 1239;
pub const ERROR_LOGIN_WKSTA_RESTRICTION: u32 = 1240;
pub const ERROR_INCORRECT_ADDRESS: u32 = 1241;
pub const ERROR_ALREADY_REGISTERED: u32 = 1242;
pub const ERROR_SERVICE_NOT_FOUND: u32 = 1243;
pub const ERROR_NOT_AUTHENTICATED: u32 = 1244;
pub const ERROR_NOT_LOGGED_ON: u32 = 1245;
pub const ERROR_CONTINUE: u32 = 1246;
pub const ERROR_ALREADY_INITIALIZED: u32 = 1247;
pub const ERROR_NO_MORE_DEVICES: u32 = 1248;
pub const ERROR_NO_SUCH_SITE: u32 = 1249;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS: u32 = 1250;
pub const ERROR_ONLY_IF_CONNECTED: u32 = 1251;
pub const ERROR_OVERRIDE_NOCHANGES: u32 = 1252;
pub const ERROR_BAD_USER_PROFILE: u32 = 1253;
pub const ERROR_NOT_SUPPORTED_ON_SBS: u32 = 1254;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS: u32 = 1255;
pub const ERROR_HOST_DOWN: u32 = 1256;
pub const ERROR_NON_ACCOUNT_SID: u32 = 1257;
pub const ERROR_NON_DOMAIN_SID: u32 = 1258;
pub const ERROR_APPHELP_BLOCK: u32 = 1259;
pub const ERROR_ACCESS_DISABLED_BY_POLICY: u32 = 1260;
pub const ERROR_REG_NAT_CONSUMPTION: u32 = 1261;
pub const ERROR_CSCSHARE_OFFLINE: u32 = 1262;
pub const ERROR_PKINIT_FAILURE: u32 = 1263;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE: u32 = 1264;
pub const ERROR_DOWNGRADE_DETECTED: u32 = 1265;
pub const SEC_E_SMARTCARD_CERT_REVOKED: u32 = 1266;
pub const SEC_E_ISSUING_CA_UNTRUSTED: u32 = 1267;
pub const SEC_E_REVOCATION_OFFLINE_C: u32 = 1268;
pub const SEC_E_PKINIT_CLIENT_FAILUR: u32 = 1269;
pub const SEC_E_SMARTCARD_CERT_EXPIRED: u32 = 1270;
pub const ERROR_MACHINE_LOCKED: u32 = 1271;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA: u32 = 1273;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED: u32 = 1274;
pub const ERROR_DRIVER_BLOCKED: u32 = 1275;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL: u32 = 1276;
pub const ERROR_ACCESS_DISABLED_WEBBLADE: u32 = 1277;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER: u32 = 1278;
pub const ERROR_RECOVERY_FAILURE: u32 = 1279;
pub const ERROR_ALREADY_FIBER: u32 = 1280;
pub const ERROR_ALREADY_THREAD: u32 = 1281;
pub const ERROR_STACK_BUFFER_OVERRUN: u32 = 1282;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED: u32 = 1283;
pub const ERROR_DEBUGGER_INACTIVE: u32 = 1284;
pub const ERROR_NOT_ALL_ASSIGNED: u32 = 1300;
pub const ERROR_SOME_NOT_MAPPED: u32 = 1301;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT: u32 = 1302;
pub const ERROR_LOCAL_USER_SESSION_KEY: u32 = 1303;
pub const ERROR_NULL_LM_PASSWORD: u32 = 1304;
pub const ERROR_UNKNOWN_REVISION: u32 = 1305;
pub const ERROR_REVISION_MISMATCH: u32 = 1306;
pub const ERROR_INVALID_OWNER: u32 = 1307;
pub const ERROR_INVALID_PRIMARY_GROUP: u32 = 1308;
pub const ERROR_NO_IMPERSONATION_TOKEN: u32 = 1309;
pub const ERROR_CANT_DISABLE_MANDATORY: u32 = 1310;
pub const ERROR_NO_LOGON_SERVERS: u32 = 1311;
pub const ERROR_NO_SUCH_LOGON_SESSION: u32 = 1312;
pub const ERROR_NO_SUCH_PRIVILEGE: u32 = 1313;
pub const ERROR_PRIVILEGE_NOT_HELD: u32 = 1314;
pub const ERROR_INVALID_ACCOUNT_NAME: u32 = 1315;
pub const ERROR_USER_EXISTS: u32 = 1316;
pub const ERROR_NO_SUCH_USER: u32 = 1317;
pub const ERROR_GROUP_EXISTS: u32 = 1318;
pub const ERROR_NO_SUCH_GROUP: u32 = 1319;
pub const ERROR_MEMBER_IN_GROUP: u32 = 1320;
pub const ERROR_MEMBER_NOT_IN_GROUP: u32 = 1321;
pub const ERROR_LAST_ADMIN: u32 = 1322;
pub const ERROR_WRONG_PASSWORD: u32 = 1323;
pub const ERROR_ILL_FORMED_PASSWORD: u32 = 1324;
pub const ERROR_PASSWORD_RESTRICTION: u32 = 1325;
pub const ERROR_LOGON_FAILURE: u32 = 1326;
pub const ERROR_ACCOUNT_RESTRICTION: u32 = 1327;
pub const ERROR_INVALID_LOGON_HOURS: u32 = 1328;
pub const ERROR_INVALID_WORKSTATION: u32 = 1329;
pub const ERROR_PASSWORD_EXPIRED: u32 = 1330;
pub const ERROR_ACCOUNT_DISABLED: u32 = 1331;
pub const ERROR_NONE_MAPPED: u32 = 1332;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED: u32 = 1333;
pub const ERROR_LUIDS_EXHAUSTED: u32 = 1334;
pub const ERROR_INVALID_SUB_AUTHORITY: u32 = 1335;
pub const ERROR_INVALID_ACL: u32 = 1336;
pub const ERROR_INVALID_SID: u32 = 1337;
pub const ERROR_INVALID_SECURITY_DESCR: u32 = 1338;
pub const ERROR_BAD_INHERITANCE_ACL: u32 = 1340;
pub const ERROR_SERVER_DISABLED: u32 = 1341;
pub const ERROR_SERVER_NOT_DISABLED: u32 = 1342;
pub const ERROR_INVALID_ID_AUTHORITY: u32 = 1343;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED: u32 = 1344;
pub const ERROR_INVALID_GROUP_ATTRIBUTES: u32 = 1345;
pub const ERROR_BAD_IMPERSONATION_LEVEL: u32 = 1346;
pub const ERROR_CANT_OPEN_ANONYMOUS: u32 = 1347;
pub const ERROR_BAD_VALIDATION_CLASS: u32 = 1348;
pub const ERROR_BAD_TOKEN_TYPE: u32 = 1349;
pub const ERROR_NO_SECURITY_ON_OBJECT: u32 = 1350;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO: u32 = 1351;
pub const ERROR_INVALID_SERVER_STATE: u32 = 1352;
pub const ERROR_INVALID_DOMAIN_STATE: u32 = 1353;
pub const ERROR_INVALID_DOMAIN_ROLE: u32 = 1354;
pub const ERROR_NO_SUCH_DOMAIN: u32 = 1355;
pub const ERROR_DOMAIN_EXISTS: u32 = 1356;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED: u32 = 1357;
pub const ERROR_INTERNAL_DB_CORRUPTION: u32 = 1358;
pub const ERROR_INTERNAL_ERROR: u32 = 1359;
pub const ERROR_GENERIC_NOT_MAPPED: u32 = 1360;
pub const ERROR_BAD_DESCRIPTOR_FORMAT: u32 = 1361;
pub const ERROR_NOT_LOGON_PROCESS: u32 = 1362;
pub const ERROR_LOGON_SESSION_EXISTS: u32 = 1363;
pub const ERROR_NO_SUCH_PACKAGE: u32 = 1364;
pub const ERROR_BAD_LOGON_SESSION_STATE: u32 = 1365;
pub const ERROR_LOGON_SESSION_COLLISION: u32 = 1366;
pub const ERROR_INVALID_LOGON_TYPE: u32 = 1367;
pub const ERROR_CANNOT_IMPERSONATE: u32 = 1368;
pub const ERROR_RXACT_INVALID_STATE: u32 = 1369;
pub const ERROR_RXACT_COMMIT_FAILURE: u32 = 1370;
pub const ERROR_SPECIAL_ACCOUNT: u32 = 1371;
pub const ERROR_SPECIAL_GROUP: u32 = 1372;
pub const ERROR_SPECIAL_USER: u32 = 1373;
pub const ERROR_MEMBERS_PRIMARY_GROUP: u32 = 1374;
pub const ERROR_TOKEN_ALREADY_IN_USE: u32 = 1375;
pub const ERROR_NO_SUCH_ALIAS: u32 = 1376;
pub const ERROR_MEMBER_NOT_IN_ALIAS: u32 = 1377;
pub const ERROR_MEMBER_IN_ALIAS: u32 = 1378;
pub const ERROR_ALIAS_EXISTS: u32 = 1379;
pub const ERROR_LOGON_NOT_GRANTED: u32 = 1380;
pub const ERROR_TOO_MANY_SECRETS: u32 = 1381;
pub const ERROR_SECRET_TOO_LONG: u32 = 1382;
pub const ERROR_INTERNAL_DB_ERROR: u32 = 1383;
pub const ERROR_TOO_MANY_CONTEXT_IDS: u32 = 1384;
pub const ERROR_LOGON_TYPE_NOT_GRANTED: u32 = 1385;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED: u32 = 1386;
pub const ERROR_NO_SUCH_MEMBER: u32 = 1387;
pub const ERROR_INVALID_MEMBER: u32 = 1388;
pub const ERROR_TOO_MANY_SIDS: u32 = 1389;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED: u32 = 1390;
pub const ERROR_NO_INHERITANCE: u32 = 1391;
pub const ERROR_FILE_CORRUPT: u32 = 1392;
pub const ERROR_DISK_CORRUPT: u32 = 1393;
pub const ERROR_NO_USER_SESSION_KEY: u32 = 1394;
pub const ERROR_LICENSE_QUOTA_EXCEEDED: u32 = 1395;
pub const ERROR_WRONG_TARGET_NAME: u32 = 1396;
pub const ERROR_MUTUAL_AUTH_FAILED: u32 = 1397;
pub const ERROR_TIME_SKEW: u32 = 1398;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED: u32 = 1399;
pub const ERROR_INVALID_WINDOW_HANDLE: u32 = 1400;
pub const ERROR_INVALID_MENU_HANDLE: u32 = 1401;
pub const ERROR_INVALID_CURSOR_HANDLE: u32 = 1402;
pub const ERROR_INVALID_ACCEL_HANDLE: u32 = 1403;
pub const ERROR_INVALID_HOOK_HANDLE: u32 = 1404;
pub const ERROR_INVALID_DWP_HANDLE: u32 = 1405;
pub const ERROR_TLW_WITH_WSCHILD: u32 = 1406;
pub const ERROR_CANNOT_FIND_WND_CLASS: u32 = 1407;
pub const ERROR_WINDOW_OF_OTHER_THREAD: u32 = 1408;
pub const ERROR_HOTKEY_ALREADY_REGISTERED: u32 = 1409;
pub const ERROR_CLASS_ALREADY_EXISTS: u32 = 1410;
pub const ERROR_CLASS_DOES_NOT_EXIST: u32 = 1411;
pub const ERROR_CLASS_HAS_WINDOWS: u32 = 1412;
pub const ERROR_INVALID_INDEX: u32 = 1413;
pub const ERROR_INVALID_ICON_HANDLE: u32 = 1414;
pub const ERROR_PRIVATE_DIALOG_INDEX: u32 = 1415;
pub const ERROR_LISTBOX_ID_NOT_FOUND: u32 = 1416;
pub const ERROR_NO_WILDCARD_CHARACTERS: u32 = 1417;
pub const ERROR_CLIPBOARD_NOT_OPEN: u32 = 1418;
pub const ERROR_HOTKEY_NOT_REGISTERED: u32 = 1419;
pub const ERROR_WINDOW_NOT_DIALOG: u32 = 1420;
pub const ERROR_CONTROL_ID_NOT_FOUND: u32 = 1421;
pub const ERROR_INVALID_COMBOBOX_MESSAGE: u32 = 1422;
pub const ERROR_WINDOW_NOT_COMBOBOX: u32 = 1423;
pub const ERROR_INVALID_EDIT_HEIGHT: u32 = 1424;
pub const ERROR_DC_NOT_FOUND: u32 = 1425;
pub const ERROR_INVALID_HOOK_FILTER: u32 = 1426;
pub const ERROR_INVALID_FILTER_PROC: u32 = 1427;
pub const ERROR_HOOK_NEEDS_HMOD: u32 = 1428;
pub const ERROR_GLOBAL_ONLY_HOOK: u32 = 1429;
pub const ERROR_JOURNAL_HOOK_SET: u32 = 1430;
pub const ERROR_HOOK_NOT_INSTALLED: u32 = 1431;
pub const ERROR_INVALID_LB_MESSAGE: u32 = 1432;
pub const ERROR_SETCOUNT_ON_BAD_LB: u32 = 1433;
pub const ERROR_LB_WITHOUT_TABSTOPS: u32 = 1434;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD: u32 = 1435;
pub const ERROR_CHILD_WINDOW_MENU: u32 = 1436;
pub const ERROR_NO_SYSTEM_MENU: u32 = 1437;
pub const ERROR_INVALID_MSGBOX_STYLE: u32 = 1438;
pub const ERROR_INVALID_SPI_VALUE: u32 = 1439;
pub const ERROR_SCREEN_ALREADY_LOCKED: u32 = 1440;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT: u32 = 1441;
pub const ERROR_NOT_CHILD_WINDOW: u32 = 1442;
pub const ERROR_INVALID_GW_COMMAND: u32 = 1443;
pub const ERROR_INVALID_THREAD_ID: u32 = 1444;
pub const ERROR_NON_MDICHILD_WINDOW: u32 = 1445;
pub const ERROR_POPUP_ALREADY_ACTIVE: u32 = 1446;
pub const ERROR_NO_SCROLLBARS: u32 = 1447;
pub const ERROR_INVALID_SCROLLBAR_RANGE: u32 = 1448;
pub const ERROR_INVALID_SHOWWIN_COMMAND: u32 = 1449;
pub const ERROR_NO_SYSTEM_RESOURCES: u32 = 1450;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES: u32 = 1451;
pub const ERROR_PAGED_SYSTEM_RESOURCES: u32 = 1452;
pub const ERROR_WORKING_SET_QUOTA: u32 = 1453;
pub const ERROR_PAGEFILE_QUOTA: u32 = 1454;
pub const ERROR_COMMITMENT_LIMIT: u32 = 1455;
pub const ERROR_MENU_ITEM_NOT_FOUND: u32 = 1456;
pub const ERROR_INVALID_KEYBOARD_HANDLE: u32 = 1457;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED: u32 = 1458;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION: u32 = 1459;
pub const ERROR_TIMEOUT: u32 = 1460;
pub const ERROR_INVALID_MONITOR_HANDLE: u32 = 1461;
pub const ERROR_EVENTLOG_FILE_CORRUPT: u32 = 1500;
pub const ERROR_EVENTLOG_CANT_START: u32 = 1501;
pub const ERROR_LOG_FILE_FULL: u32 = 1502;
pub const ERROR_EVENTLOG_FILE_CHANGED: u32 = 1503;
pub const ERROR_INSTALL_SERVICE_FAILURE: u32 = 1601;
pub const ERROR_INSTALL_USEREXIT: u32 = 1602;
pub const ERROR_INSTALL_FAILURE: u32 = 1603;
pub const ERROR_INSTALL_SUSPEND: u32 = 1604;
pub const ERROR_UNKNOWN_PRODUCT: u32 = 1605;
pub const ERROR_UNKNOWN_FEATURE: u32 = 1606;
pub const ERROR_UNKNOWN_COMPONENT: u32 = 1607;
pub const ERROR_UNKNOWN_PROPERTY: u32 = 1608;
pub const ERROR_INVALID_HANDLE_STATE: u32 = 1609;
pub const ERROR_BAD_CONFIGURATION: u32 = 1610;
pub const ERROR_INDEX_ABSENT: u32 = 1611;
pub const ERROR_INSTALL_SOURCE_ABSENT: u32 = 1612;
pub const ERROR_INSTALL_PACKAGE_VERSION: u32 = 1613;
pub const ERROR_PRODUCT_UNINSTALLED: u32 = 1614;
pub const ERROR_BAD_QUERY_SYNTAX: u32 = 1615;
pub const ERROR_INVALID_FIELD: u32 = 1616;
pub const ERROR_DEVICE_REMOVED: u32 = 1617;
pub const ERROR_INSTALL_ALREADY_RUNNING: u32 = 1618;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED: u32 = 1619;
pub const ERROR_INSTALL_PACKAGE_INVALID: u32 = 1620;
pub const ERROR_INSTALL_UI_FAILURE: u32 = 1621;
pub const ERROR_INSTALL_LOG_FAILURE: u32 = 1622;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED: u32 = 1623;
pub const ERROR_INSTALL_TRANSFORM_FAILURE: u32 = 1624;
pub const ERROR_INSTALL_PACKAGE_REJECTED: u32 = 1625;
pub const ERROR_FUNCTION_NOT_CALLED: u32 = 1626;
pub const ERROR_FUNCTION_FAILED: u32 = 1627;
pub const ERROR_INVALID_TABLE: u32 = 1628;
pub const ERROR_DATATYPE_MISMATCH: u32 = 1629;
pub const ERROR_UNSUPPORTED_TYPE: u32 = 1630;
pub const ERROR_CREATE_FAILED: u32 = 1631;
pub const ERROR_INSTALL_TEMP_UNWRITABLE: u32 = 1632;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED: u32 = 1633;
pub const ERROR_INSTALL_NOTUSED: u32 = 1634;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED: u32 = 1635;
pub const ERROR_PATCH_PACKAGE_INVALID: u32 = 1636;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED: u32 = 1637;
pub const ERROR_PRODUCT_VERSION: u32 = 1638;
pub const ERROR_INVALID_COMMAND_LINE: u32 = 1639;
pub const ERROR_INSTALL_REMOTE_DISALLOWED: u32 = 1640;
pub const ERROR_SUCCESS_REBOOT_INITIATED: u32 = 1641;
pub const ERROR_PATCH_TARGET_NOT_FOUND: u32 = 1642;
pub const ERROR_PATCH_PACKAGE_REJECTED: u32 = 1643;
pub const ERROR_INSTALL_TRANSFORM_REJECTED: u32 = 1644;
pub const ERROR_INSTALL_REMOTE_PROHIBITED: u32 = 1645;
pub const RPC_S_INVALID_STRING_BINDING: u32 = 1700;
pub const RPC_S_WRONG_KIND_OF_BINDING: u32 = 1701;
pub const RPC_S_INVALID_BINDING: u32 = 1702;
pub const RPC_S_PROTSEQ_NOT_SUPPORTED: u32 = 1703;
pub const RPC_S_INVALID_RPC_PROTSEQ: u32 = 1704;
pub const RPC_S_INVALID_STRING_UUID: u32 = 1705;
pub const RPC_S_INVALID_ENDPOINT_FORMAT: u32 = 1706;
pub const RPC_S_INVALID_NET_ADDR: u32 = 1707;
pub const RPC_S_NO_ENDPOINT_FOUND: u32 = 1708;
pub const RPC_S_INVALID_TIMEOUT: u32 = 1709;
pub const RPC_S_OBJECT_NOT_FOUND: u32 = 1710;
pub const RPC_S_ALREADY_REGISTERED: u32 = 1711;
pub const RPC_S_TYPE_ALREADY_REGISTERED: u32 = 1712;
pub const RPC_S_ALREADY_LISTENING: u32 = 1713;
pub const RPC_S_NO_PROTSEQS_REGISTERED: u32 = 1714;
pub const RPC_S_NOT_LISTENING: u32 = 1715;
pub const RPC_S_UNKNOWN_MGR_TYPE: u32 = 1716;
pub const RPC_S_UNKNOWN_IF: u32 = 1717;
pub const RPC_S_NO_BINDINGS: u32 = 1718;
pub const RPC_S_NO_PROTSEQS: u32 = 1719;
pub const RPC_S_CANT_CREATE_ENDPOINT: u32 = 1720;
pub const RPC_S_OUT_OF_RESOURCES: u32 = 1721;
pub const RPC_S_SERVER_UNAVAILABLE: u32 = 1722;
pub const RPC_S_SERVER_TOO_BUSY: u32 = 1723;
pub const RPC_S_INVALID_NETWORK_OPTIONS: u32 = 1724;
pub const RPC_S_NO_CALL_ACTIVE: u32 = 1725;
pub const RPC_S_CALL_FAILED: u32 = 1726;
pub const RPC_S_CALL_FAILED_DNE: u32 = 1727;
pub const RPC_S_PROTOCOL_ERROR: u32 = 1728;
pub const RPC_S_UNSUPPORTED_TRANS_SYN: u32 = 1730;
pub const RPC_S_UNSUPPORTED_TYPE: u32 = 1732;
pub const RPC_S_INVALID_TAG: u32 = 1733;
pub const RPC_S_INVALID_BOUND: u32 = 1734;
pub const RPC_S_NO_ENTRY_NAME: u32 = 1735;
pub const RPC_S_INVALID_NAME_SYNTAX: u32 = 1736;
pub const RPC_S_UNSUPPORTED_NAME_SYNTAX: u32 = 1737;
pub const RPC_S_UUID_NO_ADDRESS: u32 = 1739;
pub const RPC_S_DUPLICATE_ENDPOINT: u32 = 1740;
pub const RPC_S_UNKNOWN_AUTHN_TYPE: u32 = 1741;
pub const RPC_S_MAX_CALLS_TOO_SMALL: u32 = 1742;
pub const RPC_S_STRING_TOO_LONG: u32 = 1743;
pub const RPC_S_PROTSEQ_NOT_FOUND: u32 = 1744;
pub const RPC_S_PROCNUM_OUT_OF_RANGE: u32 = 1745;
pub const RPC_S_BINDING_HAS_NO_AUTH: u32 = 1746;
pub const RPC_S_UNKNOWN_AUTHN_SERVICE: u32 = 1747;
pub const RPC_S_UNKNOWN_AUTHN_LEVEL: u32 = 1748;
pub const RPC_S_INVALID_AUTH_IDENTITY: u32 = 1749;
pub const RPC_S_UNKNOWN_AUTHZ_SERVICE: u32 = 1750;
pub const EPT_S_INVALID_ENTRY: u32 = 1751;
pub const EPT_S_CANT_PERFORM_OP: u32 = 1752;
pub const EPT_S_NOT_REGISTERED: u32 = 1753;
pub const RPC_S_NOTHING_TO_EXPORT: u32 = 1754;
pub const RPC_S_INCOMPLETE_NAME: u32 = 1755;
pub const RPC_S_INVALID_VERS_OPTION: u32 = 1756;
pub const RPC_S_NO_MORE_MEMBERS: u32 = 1757;
pub const RPC_S_NOT_ALL_OBJS_UNEXPORTED: u32 = 1758;
pub const RPC_S_INTERFACE_NOT_FOUND: u32 = 1759;
pub const RPC_S_ENTRY_ALREADY_EXISTS: u32 = 1760;
pub const RPC_S_ENTRY_NOT_FOUND: u32 = 1761;
pub const RPC_S_NAME_SERVICE_UNAVAILABLE: u32 = 1762;
pub const RPC_S_INVALID_NAF_ID: u32 = 1763;
pub const RPC_S_CANNOT_SUPPORT: u32 = 1764;
pub const RPC_S_NO_CONTEXT_AVAILABLE: u32 = 1765;
pub const RPC_S_INTERNAL_ERROR: u32 = 1766;
pub const RPC_S_ZERO_DIVIDE: u32 = 1767;
pub const RPC_S_ADDRESS_ERROR: u32 = 1768;
pub const RPC_S_FP_DIV_ZERO: u32 = 1769;
pub const RPC_S_FP_UNDERFLOW: u32 = 1770;
pub const RPC_S_FP_OVERFLOW: u32 = 1771;
pub const RPC_X_NO_MORE_ENTRIES: u32 = 1772;
pub const RPC_X_SS_CHAR_TRANS_OPEN_FAIL: u32 = 1773;
pub const RPC_X_SS_CHAR_TRANS_SHORT_FILE: u32 = 1774;
pub const RPC_X_SS_IN_NULL_CONTEXT: u32 = 1775;
pub const RPC_X_SS_CONTEXT_DAMAGED: u32 = 1777;
pub const RPC_X_SS_HANDLES_MISMATCH: u32 = 1778;
pub const RPC_X_SS_CANNOT_GET_CALL_HANDLE: u32 = 1779;
pub const RPC_X_NULL_REF_POINTER: u32 = 1780;
pub const RPC_X_ENUM_VALUE_OUT_OF_RANGE: u32 = 1781;
pub const RPC_X_BYTE_COUNT_TOO_SMALL: u32 = 1782;
pub const RPC_X_BAD_STUB_DATA: u32 = 1783;
pub const ERROR_INVALID_USER_BUFFER: u32 = 1784;
pub const ERROR_UNRECOGNIZED_MEDIA: u32 = 1785;
pub const ERROR_NO_TRUST_LSA_SECRET: u32 = 1786;
pub const ERROR_NO_TRUST_SAM_ACCOUNT: u32 = 1787;
pub const ERROR_TRUSTED_DOMAIN_FAILURE: u32 = 1788;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE: u32 = 1789;
pub const ERROR_TRUST_FAILURE: u32 = 1790;
pub const RPC_S_CALL_IN_PROGRESS: u32 = 1791;
pub const ERROR_NETLOGON_NOT_STARTED: u32 = 1792;
pub const ERROR_ACCOUNT_EXPIRED: u32 = 1793;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES: u32 = 1794;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED: u32 = 1795;
pub const ERROR_UNKNOWN_PORT: u32 = 1796;
pub const ERROR_UNKNOWN_PRINTER_DRIVER: u32 = 1797;
pub const ERROR_UNKNOWN_PRINTPROCESSOR: u32 = 1798;
pub const ERROR_INVALID_SEPARATOR_FILE: u32 = 1799;
pub const ERROR_INVALID_PRIORITY: u32 = 1800;
pub const ERROR_INVALID_PRINTER_NAME: u32 = 1801;
pub const ERROR_PRINTER_ALREADY_EXISTS: u32 = 1802;
pub const ERROR_INVALID_PRINTER_COMMAND: u32 = 1803;
pub const ERROR_INVALID_DATATYPE: u32 = 1804;
pub const ERROR_INVALID_ENVIRONMENT: u32 = 1805;
pub const RPC_S_NO_MORE_BINDINGS: u32 = 1806;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT: u32 = 1807;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT: u32 = 1808;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT: u32 = 1809;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT: u32 = 1810;
pub const ERROR_SERVER_HAS_OPEN_HANDLES: u32 = 1811;
pub const ERROR_RESOURCE_DATA_NOT_FOUND: u32 = 1812;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND: u32 = 1813;
pub const ERROR_RESOURCE_NAME_NOT_FOUND: u32 = 1814;
pub const ERROR_RESOURCE_LANG_NOT_FOUND: u32 = 1815;
pub const ERROR_NOT_ENOUGH_QUOTA: u32 = 1816;
pub const RPC_S_NO_INTERFACES: u32 = 1817;
pub const RPC_S_CALL_CANCELLED: u32 = 1818;
pub const RPC_S_BINDING_INCOMPLETE: u32 = 1819;
pub const RPC_S_COMM_FAILURE: u32 = 1820;
pub const RPC_S_UNSUPPORTED_AUTHN_LEVEL: u32 = 1821;
pub const RPC_S_NO_PRINC_NAME: u32 = 1822;
pub const RPC_S_NOT_RPC_ERROR: u32 = 1823;
pub const RPC_S_UUID_LOCAL_ONLY: u32 = 1824;
pub const RPC_S_SEC_PKG_ERROR: u32 = 1825;
pub const RPC_S_NOT_CANCELLED: u32 = 1826;
pub const RPC_X_INVALID_ES_ACTION: u32 = 1827;
pub const RPC_X_WRONG_ES_VERSION: u32 = 1828;
pub const RPC_X_WRONG_STUB_VERSION: u32 = 1829;
pub const RPC_X_INVALID_PIPE_OBJECT: u32 = 1830;
pub const RPC_X_WRONG_PIPE_ORDER: u32 = 1831;
pub const RPC_X_WRONG_PIPE_VERSION: u32 = 1832;
pub const RPC_S_GROUP_MEMBER_NOT_FOUND: u32 = 1898;
pub const EPT_S_CANT_CREATE: u32 = 1899;
pub const RPC_S_INVALID_OBJECT: u32 = 1900;
pub const ERROR_INVALID_TIME: u32 = 1901;
pub const ERROR_INVALID_FORM_NAME: u32 = 1902;
pub const ERROR_INVALID_FORM_SIZE: u32 = 1903;
pub const ERROR_ALREADY_WAITING: u32 = 1904;
pub const ERROR_PRINTER_DELETED: u32 = 1905;
pub const ERROR_INVALID_PRINTER_STATE: u32 = 1906;
pub const ERROR_PASSWORD_MUST_CHANGE: u32 = 1907;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND: u32 = 1908;
pub const ERROR_ACCOUNT_LOCKED_OUT: u32 = 1909;
pub const OR_INVALID_OXID: u32 = 1910;
pub const OR_INVALID_OID: u32 = 1911;
pub const OR_INVALID_SET: u32 = 1912;
pub const RPC_S_SEND_INCOMPLETE: u32 = 1913;
pub const RPC_S_INVALID_ASYNC_HANDLE: u32 = 1914;
pub const RPC_S_INVALID_ASYNC_CALL: u32 = 1915;
pub const RPC_X_PIPE_CLOSED: u32 = 1916;
pub const RPC_X_PIPE_DISCIPLINE_ERROR: u32 = 1917;
pub const RPC_X_PIPE_EMPTY: u32 = 1918;
pub const ERROR_NO_SITENAME: u32 = 1919;
pub const ERROR_CANT_ACCESS_FILE: u32 = 1920;
pub const ERROR_CANT_RESOLVE_FILENAME: u32 = 1921;
pub const RPC_S_ENTRY_TYPE_MISMATCH: u32 = 1922;
pub const RPC_S_NOT_ALL_OBJS_EXPORTED: u32 = 1923;
pub const RPC_S_INTERFACE_NOT_EXPORTED: u32 = 1924;
pub const RPC_S_PROFILE_NOT_ADDED: u32 = 1925;
pub const RPC_S_PRF_ELT_NOT_ADDED: u32 = 1926;
pub const RPC_S_PRF_ELT_NOT_REMOVED: u32 = 1927;
pub const RPC_S_GRP_ELT_NOT_ADDED: u32 = 1928;
pub const RPC_S_GRP_ELT_NOT_REMOVED: u32 = 1929;
pub const ERROR_KM_DRIVER_BLOCKED: u32 = 1930;
pub const ERROR_CONTEXT_EXPIRED: u32 = 1931;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED: u32 = 1932;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED: u32 = 1933;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED: u32 = 1934;
pub const ERROR_INVALID_PIXEL_FORMAT: u32 = 2000;
pub const ERROR_BAD_DRIVER: u32 = 2001;
pub const ERROR_INVALID_WINDOW_STYLE: u32 = 2002;
pub const ERROR_METAFILE_NOT_SUPPORTED: u32 = 2003;
pub const ERROR_TRANSFORM_NOT_SUPPORTED: u32 = 2004;
pub const ERROR_CLIPPING_NOT_SUPPORTED: u32 = 2005;
pub const ERROR_INVALID_CMM: u32 = 2010;
pub const ERROR_INVALID_PROFILE: u32 = 2011;
pub const ERROR_TAG_NOT_FOUND: u32 = 2012;
pub const ERROR_TAG_NOT_PRESENT: u32 = 2013;
pub const ERROR_DUPLICATE_TAG: u32 = 2014;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE: u32 = 2015;
pub const ERROR_PROFILE_NOT_FOUND: u32 = 2016;
pub const ERROR_INVALID_COLORSPACE: u32 = 2017;
pub const ERROR_ICM_NOT_ENABLED: u32 = 2018;
pub const ERROR_DELETING_ICM_XFORM: u32 = 2019;
pub const ERROR_INVALID_TRANSFORM: u32 = 2020;
pub const ERROR_COLORSPACE_MISMATCH: u32 = 2021;
pub const ERROR_INVALID_COLORINDEX: u32 = 2022;
pub const ERROR_CONNECTED_OTHER_PASSWORD: u32 = 2108;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT: u32 = 2109;
pub const ERROR_BAD_USERNAME: u32 = 2202;
pub const ERROR_NOT_CONNECTED: u32 = 2250;
pub const ERROR_OPEN_FILES: u32 = 2401;
pub const ERROR_ACTIVE_CONNECTIONS: u32 = 2402;
pub const ERROR_DEVICE_IN_USE: u32 = 2404;
pub const ERROR_UNKNOWN_PRINT_MONITOR: u32 = 3000;
pub const ERROR_PRINTER_DRIVER_IN_USE: u32 = 3001;
pub const ERROR_SPOOL_FILE_NOT_FOUND: u32 = 3002;
pub const ERROR_SPL_NO_STARTDOC: u32 = 3003;
pub const ERROR_SPL_NO_ADDJOB: u32 = 3004;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED: u32 = 3005;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED: u32 = 3006;
pub const ERROR_INVALID_PRINT_MONITOR: u32 = 3007;
pub const ERROR_PRINT_MONITOR_IN_USE: u32 = 3008;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED: u32 = 3009;
pub const ERROR_SUCCESS_REBOOT_REQUIRED: u32 = 3010;
pub const ERROR_SUCCESS_RESTART_REQUIRED: u32 = 3011;
pub const ERROR_PRINTER_NOT_FOUND: u32 = 3012;
pub const ERROR_PRINTER_DRIVER_WARNED: u32 = 3013;
pub const ERROR_PRINTER_DRIVER_BLOCKED: u32 = 3014;
pub const ERROR_WINS_INTERNAL: u32 = 4000;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS: u32 = 4001;
pub const ERROR_STATIC_INIT: u32 = 4002;
pub const ERROR_INC_BACKUP: u32 = 4003;
pub const ERROR_FULL_BACKUP: u32 = 4004;
pub const ERROR_REC_NON_EXISTENT: u32 = 4005;
pub const ERROR_RPL_NOT_ALLOWED: u32 = 4006;
pub const ERROR_DHCP_ADDRESS_CONFLICT: u32 = 4100;
pub const ERROR_WMI_GUID_NOT_FOUND: u32 = 4200;
pub const ERROR_WMI_INSTANCE_NOT_FOUND: u32 = 4201;
pub const ERROR_WMI_ITEMID_NOT_FOUND: u32 = 4202;
pub const ERROR_WMI_TRY_AGAIN: u32 = 4203;
pub const ERROR_WMI_DP_NOT_FOUND: u32 = 4204;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF: u32 = 4205;
pub const ERROR_WMI_ALREADY_ENABLED: u32 = 4206;
pub const ERROR_WMI_GUID_DISCONNECTED: u32 = 4207;
pub const ERROR_WMI_SERVER_UNAVAILABLE: u32 = 4208;
pub const ERROR_WMI_DP_FAILED: u32 = 4209;
pub const ERROR_WMI_INVALID_MOF: u32 = 4210;
pub const ERROR_WMI_INVALID_REGINFO: u32 = 4211;
pub const ERROR_WMI_ALREADY_DISABLED: u32 = 4212;
pub const ERROR_WMI_READ_ONLY: u32 = 4213;
pub const ERROR_WMI_SET_FAILURE: u32 = 4214;
pub const ERROR_INVALID_MEDIA: u32 = 4300;
pub const ERROR_INVALID_LIBRARY: u32 = 4301;
pub const ERROR_INVALID_MEDIA_POOL: u32 = 4302;
pub const ERROR_DRIVE_MEDIA_MISMATCH: u32 = 4303;
pub const ERROR_MEDIA_OFFLINE: u32 = 4304;
pub const ERROR_LIBRARY_OFFLINE: u32 = 4305;
pub const ERROR_EMPTY: u32 = 4306;
pub const ERROR_NOT_EMPTY: u32 = 4307;
pub const ERROR_MEDIA_UNAVAILABLE: u32 = 4308;
pub const ERROR_RESOURCE_DISABLED: u32 = 4309;
pub const ERROR_INVALID_CLEANER: u32 = 4310;
pub const ERROR_UNABLE_TO_CLEAN: u32 = 4311;
pub const ERROR_OBJECT_NOT_FOUND: u32 = 4312;
pub const ERROR_DATABASE_FAILURE: u32 = 4313;
pub const ERROR_DATABASE_FULL: u32 = 4314;
pub const ERROR_MEDIA_INCOMPATIBLE: u32 = 4315;
pub const ERROR_RESOURCE_NOT_PRESENT: u32 = 4316;
pub const ERROR_INVALID_OPERATION: u32 = 4317;
pub const ERROR_MEDIA_NOT_AVAILABLE: u32 = 4318;
pub const ERROR_DEVICE_NOT_AVAILABLE: u32 = 4319;
pub const ERROR_REQUEST_REFUSED: u32 = 4320;
pub const ERROR_INVALID_DRIVE_OBJECT: u32 = 4321;
pub const ERROR_LIBRARY_FULL: u32 = 4322;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE: u32 = 4323;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM: u32 = 4324;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE: u32 = 4325;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT: u32 = 4326;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT: u32 = 4327;
pub const ERROR_TRANSPORT_FULL: u32 = 4328;
pub const ERROR_CONTROLLING_IEPORT: u32 = 4329;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA: u32 = 4330;
pub const ERROR_CLEANER_SLOT_SET: u32 = 4331;
pub const ERROR_CLEANER_SLOT_NOT_SET: u32 = 4332;
pub const ERROR_CLEANER_CARTRIDGE_SPENT: u32 = 4333;
pub const ERROR_UNEXPECTED_OMID: u32 = 4334;
pub const ERROR_CANT_DELETE_LAST_ITEM: u32 = 4335;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE: u32 = 4336;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES: u32 = 4337;
pub const ERROR_INDIGENOUS_TYPE: u32 = 4338;
pub const ERROR_NO_SUPPORTING_DRIVES: u32 = 4339;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED: u32 = 4340;
pub const ERROR_FILE_OFFLINE: u32 = 4350;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE: u32 = 4351;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR: u32 = 4352;
pub const ERROR_NOT_A_REPARSE_POINT: u32 = 4390;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT: u32 = 4391;
pub const ERROR_INVALID_REPARSE_DATA: u32 = 4392;
pub const ERROR_REPARSE_TAG_INVALID: u32 = 4393;
pub const ERROR_REPARSE_TAG_MISMATCH: u32 = 4394;
pub const ERROR_VOLUME_NOT_SIS_ENABLED: u32 = 4500;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS: u32 = 5001;
pub const ERROR_DEPENDENCY_NOT_FOUND: u32 = 5002;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS: u32 = 5003;
pub const ERROR_RESOURCE_NOT_ONLINE: u32 = 5004;
pub const ERROR_HOST_NODE_NOT_AVAILABLE: u32 = 5005;
pub const ERROR_RESOURCE_NOT_AVAILABLE: u32 = 5006;
pub const ERROR_RESOURCE_NOT_FOUND: u32 = 5007;
pub const ERROR_SHUTDOWN_CLUSTER: u32 = 5008;
pub const ERROR_CANT_EVICT_ACTIVE_NODE: u32 = 5009;
pub const ERROR_OBJECT_ALREADY_EXISTS: u32 = 5010;
pub const ERROR_OBJECT_IN_LIST: u32 = 5011;
pub const ERROR_GROUP_NOT_AVAILABLE: u32 = 5012;
pub const ERROR_GROUP_NOT_FOUND: u32 = 5013;
pub const ERROR_GROUP_NOT_ONLINE: u32 = 5014;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER: u32 = 5015;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER: u32 = 5016;
pub const ERROR_RESMON_CREATE_FAILED: u32 = 5017;
pub const ERROR_RESMON_ONLINE_FAILED: u32 = 5018;
pub const ERROR_RESOURCE_ONLINE: u32 = 5019;
pub const ERROR_QUORUM_RESOURCE: u32 = 5020;
pub const ERROR_NOT_QUORUM_CAPABLE: u32 = 5021;
pub const ERROR_CLUSTER_SHUTTING_DOWN: u32 = 5022;
pub const ERROR_INVALID_STATE: u32 = 5023;
pub const ERROR_RESOURCE_PROPERTIES_STORED: u32 = 5024;
pub const ERROR_NOT_QUORUM_CLASS: u32 = 5025;
pub const ERROR_CORE_RESOURCE: u32 = 5026;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED: u32 = 5027;
pub const ERROR_QUORUMLOG_OPEN_FAILED: u32 = 5028;
pub const ERROR_CLUSTERLOG_CORRUPT: u32 = 5029;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE: u32 = 5030;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE: u32 = 5031;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND: u32 = 5032;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE: u32 = 5033;
pub const ERROR_QUORUM_OWNER_ALIVE: u32 = 5034;
pub const ERROR_NETWORK_NOT_AVAILABLE: u32 = 5035;
pub const ERROR_NODE_NOT_AVAILABLE: u32 = 5036;
pub const ERROR_ALL_NODES_NOT_AVAILABLE: u32 = 5037;
pub const ERROR_RESOURCE_FAILED: u32 = 5038;
pub const ERROR_CLUSTER_INVALID_NODE: u32 = 5039;
pub const ERROR_CLUSTER_NODE_EXISTS: u32 = 5040;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS: u32 = 5041;
pub const ERROR_CLUSTER_NODE_NOT_FOUND: u32 = 5042;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND: u32 = 5043;
pub const ERROR_CLUSTER_NETWORK_EXISTS: u32 = 5044;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND: u32 = 5045;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS: u32 = 5046;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND: u32 = 5047;
pub const ERROR_CLUSTER_INVALID_REQUEST: u32 = 5048;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER: u32 = 5049;
pub const ERROR_CLUSTER_NODE_DOWN: u32 = 5050;
pub const ERROR_CLUSTER_NODE_UNREACHABLE: u32 = 5051;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER: u32 = 5052;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS: u32 = 5053;
pub const ERROR_CLUSTER_INVALID_NETWORK: u32 = 5054;
pub const ERROR_CLUSTER_NODE_UP: u32 = 5056;
pub const ERROR_CLUSTER_IPADDR_IN_USE: u32 = 5057;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED: u32 = 5058;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT: u32 = 5059;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL: u32 = 5060;
pub const ERROR_CLUSTER_NODE_ALREADY_UP: u32 = 5061;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN: u32 = 5062;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE: u32 = 5063;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE: u32 = 5064;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER: u32 = 5065;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK: u32 = 5066;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS: u32 = 5067;
pub const ERROR_INVALID_OPERATION_ON_QUORUM: u32 = 5068;
pub const ERROR_DEPENDENCY_NOT_ALLOWED: u32 = 5069;
pub const ERROR_CLUSTER_NODE_PAUSED: u32 = 5070;
pub const ERROR_NODE_CANT_HOST_RESOURCE: u32 = 5071;
pub const ERROR_CLUSTER_NODE_NOT_READY: u32 = 5072;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN: u32 = 5073;
pub const ERROR_CLUSTER_JOIN_ABORTED: u32 = 5074;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS: u32 = 5075;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED: u32 = 5076;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED: u32 = 5077;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND: u32 = 5078;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED: u32 = 5079;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND: u32 = 5080;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED: u32 = 5081;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST: u32 = 5082;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH: u32 = 5083;
pub const ERROR_RESMON_INVALID_STATE: u32 = 5084;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER: u32 = 5085;
pub const ERROR_QUORUM_DISK_NOT_FOUND: u32 = 5086;
pub const ERROR_DATABASE_BACKUP_CORRUPT: u32 = 5087;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT: u32 = 5088;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE: u32 = 5089;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE: u32 = 5890;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND: u32 = 5891;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT: u32 = 5892;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH: u32 = 5893;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP: u32 = 5894;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH: u32 = 5895;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP: u32 = 5896;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH: u32 = 5897;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED: u32 = 5898;
pub const ERROR_CLUSTER_WRONG_OS_VERSION: u32 = 5899;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME: u32 = 5900;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED: u32 = 5901;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED: u32 = 5902;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT: u32 = 5903;
pub const ERROR_CLUSTER_OLD_VERSION: u32 = 5904;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME: u32 = 5905;
pub const ERROR_ENCRYPTION_FAILED: u32 = 6000;
pub const ERROR_DECRYPTION_FAILED: u32 = 6001;
pub const ERROR_FILE_ENCRYPTED: u32 = 6002;
pub const ERROR_NO_RECOVERY_POLICY: u32 = 6003;
pub const ERROR_NO_EFS: u32 = 6004;
pub const ERROR_WRONG_EFS: u32 = 6005;
pub const ERROR_NO_USER_KEYS: u32 = 6006;
pub const ERROR_FILE_NOT_ENCRYPTED: u32 = 6007;
pub const ERROR_NOT_EXPORT_FORMAT: u32 = 6008;
pub const ERROR_FILE_READ_ONLY: u32 = 6009;
pub const ERROR_DIR_EFS_DISALLOWED: u32 = 6010;
pub const ERROR_EFS_SERVER_NOT_TRUSTED: u32 = 6011;
pub const ERROR_BAD_RECOVERY_POLICY: u32 = 6012;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG: u32 = 6013;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS: u32 = 6014;
pub const ERROR_EFS_DISABLED: u32 = 6015;
pub const ERROR_EFS_VERSION_NOT_SUPPORT: u32 = 6016;
pub const ERROR_NO_BROWSER_SERVERS_FOUND: u32 = 6118;
pub const SCHED_E_SERVICE_NOT_LOCALSYSTEM: u32 = 6200;
pub const ERROR_CTX_WINSTATION_NAME_INVALID: u32 = 7001;
pub const ERROR_CTX_INVALID_PD: u32 = 7002;
pub const ERROR_CTX_PD_NOT_FOUND: u32 = 7003;
pub const ERROR_CTX_WD_NOT_FOUND: u32 = 7004;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY: u32 = 7005;
pub const ERROR_CTX_SERVICE_NAME_COLLISION: u32 = 7006;
pub const ERROR_CTX_CLOSE_PENDING: u32 = 7007;
pub const ERROR_CTX_NO_OUTBUF: u32 = 7008;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND: u32 = 7009;
pub const ERROR_CTX_INVALID_MODEMNAME: u32 = 7010;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR: u32 = 7011;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT: u32 = 7012;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER: u32 = 7013;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE: u32 = 7014;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY: u32 = 7015;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE: u32 = 7016;
pub const ERROR_CTX_TD_ERROR: u32 = 7017;
pub const ERROR_CTX_WINSTATION_NOT_FOUND: u32 = 7022;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS: u32 = 7023;
pub const ERROR_CTX_WINSTATION_BUSY: u32 = 7024;
pub const ERROR_CTX_BAD_VIDEO_MODE: u32 = 7025;
pub const ERROR_CTX_GRAPHICS_INVALID: u32 = 7035;
pub const ERROR_CTX_LOGON_DISABLED: u32 = 7037;
pub const ERROR_CTX_NOT_CONSOLE: u32 = 7038;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT: u32 = 7040;
pub const ERROR_CTX_CONSOLE_DISCONNECT: u32 = 7041;
pub const ERROR_CTX_CONSOLE_CONNECT: u32 = 7042;
pub const ERROR_CTX_SHADOW_DENIED: u32 = 7044;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED: u32 = 7045;
pub const ERROR_CTX_INVALID_WD: u32 = 7049;
pub const ERROR_CTX_SHADOW_INVALID: u32 = 7050;
pub const ERROR_CTX_SHADOW_DISABLED: u32 = 7051;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE: u32 = 7052;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET: u32 = 7053;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE: u32 = 7054;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID: u32 = 7055;
pub const ERROR_CTX_LICENSE_EXPIRED: u32 = 7056;
pub const ERROR_CTX_SHADOW_NOT_RUNNING: u32 = 7057;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE: u32 = 7058;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED: u32 = 7059;
pub const FRS_ERR_INVALID_API_SEQUENCE: u32 = 8001;
pub const FRS_ERR_STARTING_SERVICE: u32 = 8002;
pub const FRS_ERR_STOPPING_SERVICE: u32 = 8003;
pub const FRS_ERR_INTERNAL_API: u32 = 8004;
pub const FRS_ERR_INTERNAL: u32 = 8005;
pub const FRS_ERR_SERVICE_COMM: u32 = 8006;
pub const FRS_ERR_INSUFFICIENT_PRIV: u32 = 8007;
pub const FRS_ERR_AUTHENTICATION: u32 = 8008;
pub const FRS_ERR_PARENT_INSUFFICIENT_PRIV: u32 = 8009;
pub const FRS_ERR_PARENT_AUTHENTICATION: u32 = 8010;
pub const FRS_ERR_CHILD_TO_PARENT_COMM: u32 = 8011;
pub const FRS_ERR_PARENT_TO_CHILD_COMM: u32 = 8012;
pub const FRS_ERR_SYSVOL_POPULATE: u32 = 8013;
pub const FRS_ERR_SYSVOL_POPULATE_TIMEOUT: u32 = 8014;
pub const FRS_ERR_SYSVOL_IS_BUSY: u32 = 8015;
pub const FRS_ERR_SYSVOL_DEMOTE: u32 = 8016;
pub const FRS_ERR_INVALID_SERVICE_PARAMETER: u32 = 8017;
pub const ERROR_DS_NOT_INSTALLED: u32 = 8200;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY: u32 = 8201;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE: u32 = 8202;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX: u32 = 8203;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED: u32 = 8204;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS: u32 = 8205;
pub const ERROR_DS_BUSY: u32 = 8206;
pub const ERROR_DS_UNAVAILABLE: u32 = 8207;
pub const ERROR_DS_NO_RIDS_ALLOCATED: u32 = 8208;
pub const ERROR_DS_NO_MORE_RIDS: u32 = 8209;
pub const ERROR_DS_INCORRECT_ROLE_OWNER: u32 = 8210;
pub const ERROR_DS_RIDMGR_INIT_ERROR: u32 = 8211;
pub const ERROR_DS_OBJ_CLASS_VIOLATION: u32 = 8212;
pub const ERROR_DS_CANT_ON_NON_LEAF: u32 = 8213;
pub const ERROR_DS_CANT_ON_RDN: u32 = 8214;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS: u32 = 8215;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR: u32 = 8216;
pub const ERROR_DS_GC_NOT_AVAILABLE: u32 = 8217;
pub const ERROR_SHARED_POLICY: u32 = 8218;
pub const ERROR_POLICY_OBJECT_NOT_FOUND: u32 = 8219;
pub const ERROR_POLICY_ONLY_IN_DS: u32 = 8220;
pub const ERROR_PROMOTION_ACTIVE: u32 = 8221;
pub const ERROR_NO_PROMOTION_ACTIVE: u32 = 8222;
pub const ERROR_DS_OPERATIONS_ERROR: u32 = 8224;
pub const ERROR_DS_PROTOCOL_ERROR: u32 = 8225;
pub const ERROR_DS_TIMELIMIT_EXCEEDED: u32 = 8226;
pub const ERROR_DS_SIZELIMIT_EXCEEDED: u32 = 8227;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED: u32 = 8228;
pub const ERROR_DS_COMPARE_FALSE: u32 = 8229;
pub const ERROR_DS_COMPARE_TRUE: u32 = 8230;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED: u32 = 8231;
pub const ERROR_DS_STRONG_AUTH_REQUIRED: u32 = 8232;
pub const ERROR_DS_INAPPROPRIATE_AUTH: u32 = 8233;
pub const ERROR_DS_AUTH_UNKNOWN: u32 = 8234;
pub const ERROR_DS_REFERRAL: u32 = 8235;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION: u32 = 8236;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED: u32 = 8237;
pub const ERROR_DS_INAPPROPRIATE_MATCHING: u32 = 8238;
pub const ERROR_DS_CONSTRAINT_VIOLATION: u32 = 8239;
pub const ERROR_DS_NO_SUCH_OBJECT: u32 = 8240;
pub const ERROR_DS_ALIAS_PROBLEM: u32 = 8241;
pub const ERROR_DS_INVALID_DN_SYNTAX: u32 = 8242;
pub const ERROR_DS_IS_LEAF: u32 = 8243;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM: u32 = 8244;
pub const ERROR_DS_UNWILLING_TO_PERFORM: u32 = 8245;
pub const ERROR_DS_LOOP_DETECT: u32 = 8246;
pub const ERROR_DS_NAMING_VIOLATION: u32 = 8247;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE: u32 = 8248;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS: u32 = 8249;
pub const ERROR_DS_SERVER_DOWN: u32 = 8250;
pub const ERROR_DS_LOCAL_ERROR: u32 = 8251;
pub const ERROR_DS_ENCODING_ERROR: u32 = 8252;
pub const ERROR_DS_DECODING_ERROR: u32 = 8253;
pub const ERROR_DS_FILTER_UNKNOWN: u32 = 8254;
pub const ERROR_DS_PARAM_ERROR: u32 = 8255;
pub const ERROR_DS_NOT_SUPPORTED: u32 = 8256;
pub const ERROR_DS_NO_RESULTS_RETURNED: u32 = 8257;
pub const ERROR_DS_CONTROL_NOT_FOUND: u32 = 8258;
pub const ERROR_DS_CLIENT_LOOP: u32 = 8259;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED: u32 = 8260;
pub const ERROR_DS_SORT_CONTROL_MISSING: u32 = 8261;
pub const ERROR_DS_OFFSET_RANGE_ERROR: u32 = 8262;
pub const ERROR_DS_ROOT_MUST_BE_NC: u32 = 8301;
pub const ERROR_DS_ADD_REPLICA_INHIBITED: u32 = 8302;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA: u32 = 8303;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED: u32 = 8304;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS: u32 = 8305;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA: u32 = 8306;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA: u32 = 8307;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND: u32 = 8308;
pub const ERROR_DS_USER_BUFFER_TO_SMALL: u32 = 8309;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ: u32 = 8310;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION: u32 = 8311;
pub const ERROR_DS_OBJ_TOO_LARGE: u32 = 8312;
pub const ERROR_DS_BAD_INSTANCE_TYPE: u32 = 8313;
pub const ERROR_DS_MASTERDSA_REQUIRED: u32 = 8314;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED: u32 = 8315;
pub const ERROR_DS_MISSING_REQUIRED_ATT: u32 = 8316;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS: u32 = 8317;
pub const ERROR_DS_ATT_ALREADY_EXISTS: u32 = 8318;
pub const ERROR_DS_CANT_ADD_ATT_VALUES: u32 = 8320;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT: u32 = 8321;
pub const ERROR_DS_RANGE_CONSTRAINT: u32 = 8322;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS: u32 = 8323;
pub const ERROR_DS_CANT_REM_MISSING_ATT: u32 = 8324;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL: u32 = 8325;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF: u32 = 8326;
pub const ERROR_DS_NO_CHAINING: u32 = 8327;
pub const ERROR_DS_NO_CHAINED_EVAL: u32 = 8328;
pub const ERROR_DS_NO_PARENT_OBJECT: u32 = 8329;
pub const ERROR_DS_PARENT_IS_AN_ALIAS: u32 = 8330;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS: u32 = 8331;
pub const ERROR_DS_CHILDREN_EXIST: u32 = 8332;
pub const ERROR_DS_OBJ_NOT_FOUND: u32 = 8333;
pub const ERROR_DS_ALIASED_OBJ_MISSING: u32 = 8334;
pub const ERROR_DS_BAD_NAME_SYNTAX: u32 = 8335;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS: u32 = 8336;
pub const ERROR_DS_CANT_DEREF_ALIAS: u32 = 8337;
pub const ERROR_DS_OUT_OF_SCOPE: u32 = 8338;
pub const ERROR_DS_OBJECT_BEING_REMOVED: u32 = 8339;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ: u32 = 8340;
pub const ERROR_DS_GENERIC_ERROR: u32 = 8341;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER: u32 = 8342;
pub const ERROR_DS_CLASS_NOT_DSA: u32 = 8343;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS: u32 = 8344;
pub const ERROR_DS_ILLEGAL_SUPERIOR: u32 = 8345;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM: u32 = 8346;
pub const ERROR_DS_NAME_TOO_MANY_PARTS: u32 = 8347;
pub const ERROR_DS_NAME_TOO_LONG: u32 = 8348;
pub const ERROR_DS_NAME_VALUE_TOO_LONG: u32 = 8349;
pub const ERROR_DS_NAME_UNPARSEABLE: u32 = 8350;
pub const ERROR_DS_NAME_TYPE_UNKNOWN: u32 = 8351;
pub const ERROR_DS_NOT_AN_OBJECT: u32 = 8352;
pub const ERROR_DS_SEC_DESC_TOO_SHORT: u32 = 8353;
pub const ERROR_DS_SEC_DESC_INVALID: u32 = 8354;
pub const ERROR_DS_NO_DELETED_NAME: u32 = 8355;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT: u32 = 8356;
pub const ERROR_DS_NCNAME_MUST_BE_NC: u32 = 8357;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY: u32 = 8358;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE: u32 = 8359;
pub const ERROR_DS_INVALID_DMD: u32 = 8360;
pub const ERROR_DS_OBJ_GUID_EXISTS: u32 = 8361;
pub const ERROR_DS_NOT_ON_BACKLINK: u32 = 8362;
pub const ERROR_DS_NO_CROSSREF_FOR_NC: u32 = 8363;
pub const ERROR_DS_SHUTTING_DOWN: u32 = 8364;
pub const ERROR_DS_UNKNOWN_OPERATION: u32 = 8365;
pub const ERROR_DS_INVALID_ROLE_OWNER: u32 = 8366;
pub const ERROR_DS_COULDNT_CONTACT_FSMO: u32 = 8367;
pub const ERROR_DS_CROSS_NC_DN_RENAME: u32 = 8368;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY: u32 = 8369;
pub const ERROR_DS_REPLICATOR_ONLY: u32 = 8370;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED: u32 = 8371;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS: u32 = 8372;
pub const ERROR_DS_NAME_REFERENCE_INVALID: u32 = 8373;
pub const ERROR_DS_CROSS_REF_EXISTS: u32 = 8374;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF: u32 = 8375;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD: u32 = 8376;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX: u32 = 8377;
pub const ERROR_DS_DUP_RDN: u32 = 8378;
pub const ERROR_DS_DUP_OID: u32 = 8379;
pub const ERROR_DS_DUP_MAPI_ID: u32 = 8380;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID: u32 = 8381;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME: u32 = 8382;
pub const ERROR_DS_SEMANTIC_ATT_TEST: u32 = 8383;
pub const ERROR_DS_SYNTAX_MISMATCH: u32 = 8384;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE: u32 = 8385;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE: u32 = 8386;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE: u32 = 8387;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE: u32 = 8388;
pub const ERROR_DS_AUX_CLS_TEST_FAIL: u32 = 8389;
pub const ERROR_DS_NONEXISTENT_POSS_SUP: u32 = 8390;
pub const ERROR_DS_SUB_CLS_TEST_FAIL: u32 = 8391;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX: u32 = 8392;
pub const ERROR_DS_EXISTS_IN_AUX_CLS: u32 = 8393;
pub const ERROR_DS_EXISTS_IN_SUB_CLS: u32 = 8394;
pub const ERROR_DS_EXISTS_IN_POSS_SUP: u32 = 8395;
pub const ERROR_DS_RECALCSCHEMA_FAILED: u32 = 8396;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED: u32 = 8397;
pub const ERROR_DS_CANT_DELETE: u32 = 8398;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID: u32 = 8399;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX: u32 = 8400;
pub const ERROR_DS_CANT_CACHE_ATT: u32 = 8401;
pub const ERROR_DS_CANT_CACHE_CLASS: u32 = 8402;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE: u32 = 8403;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE: u32 = 8404;
pub const ERROR_DS_CANT_RETRIEVE_DN: u32 = 8405;
pub const ERROR_DS_MISSING_SUPREF: u32 = 8406;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE: u32 = 8407;
pub const ERROR_DS_CODE_INCONSISTENCY: u32 = 8408;
pub const ERROR_DS_DATABASE_ERROR: u32 = 8409;
pub const ERROR_DS_GOVERNSID_MISSING: u32 = 8410;
pub const ERROR_DS_MISSING_EXPECTED_ATT: u32 = 8411;
pub const ERROR_DS_NCNAME_MISSING_CR_REF: u32 = 8412;
pub const ERROR_DS_SECURITY_CHECKING_ERROR: u32 = 8413;
pub const ERROR_DS_SCHEMA_NOT_LOADED: u32 = 8414;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED: u32 = 8415;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX: u32 = 8416;
pub const ERROR_DS_GCVERIFY_ERROR: u32 = 8417;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH: u32 = 8418;
pub const ERROR_DS_CANT_FIND_DSA_OBJ: u32 = 8419;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC: u32 = 8420;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE: u32 = 8421;
pub const ERROR_DS_CANT_RETRIEVE_CHILD: u32 = 8422;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY: u32 = 8423;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC: u32 = 8424;
pub const ERROR_DS_BAD_HIERARCHY_FILE: u32 = 8425;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED: u32 = 8426;
pub const ERROR_DS_CONFIG_PARAM_MISSING: u32 = 8427;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED: u32 = 8428;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED: u32 = 8429;
pub const ERROR_DS_INTERNAL_FAILURE: u32 = 8430;
pub const ERROR_DS_UNKNOWN_ERROR: u32 = 8431;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP: u32 = 8432;
pub const ERROR_DS_REFUSING_FSMO_ROLES: u32 = 8433;
pub const ERROR_DS_MISSING_FSMO_SETTINGS: u32 = 8434;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES: u32 = 8435;
pub const ERROR_DS_DRA_GENERIC: u32 = 8436;
pub const ERROR_DS_DRA_INVALID_PARAMETER: u32 = 8437;
pub const ERROR_DS_DRA_BUSY: u32 = 8438;
pub const ERROR_DS_DRA_BAD_DN: u32 = 8439;
pub const ERROR_DS_DRA_BAD_NC: u32 = 8440;
pub const ERROR_DS_DRA_DN_EXISTS: u32 = 8441;
pub const ERROR_DS_DRA_INTERNAL_ERROR: u32 = 8442;
pub const ERROR_DS_DRA_INCONSISTENT_DIT: u32 = 8443;
pub const ERROR_DS_DRA_CONNECTION_FAILED: u32 = 8444;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE: u32 = 8445;
pub const ERROR_DS_DRA_OUT_OF_MEM: u32 = 8446;
pub const ERROR_DS_DRA_MAIL_PROBLEM: u32 = 8447;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS: u32 = 8448;
pub const ERROR_DS_DRA_REF_NOT_FOUND: u32 = 8449;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE: u32 = 8450;
pub const ERROR_DS_DRA_DB_ERROR: u32 = 8451;
pub const ERROR_DS_DRA_NO_REPLICA: u32 = 8452;
pub const ERROR_DS_DRA_ACCESS_DENIED: u32 = 8453;
pub const ERROR_DS_DRA_NOT_SUPPORTED: u32 = 8454;
pub const ERROR_DS_DRA_RPC_CANCELLED: u32 = 8455;
pub const ERROR_DS_DRA_SOURCE_DISABLED: u32 = 8456;
pub const ERROR_DS_DRA_SINK_DISABLED: u32 = 8457;
pub const ERROR_DS_DRA_NAME_COLLISION: u32 = 8458;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED: u32 = 8459;
pub const ERROR_DS_DRA_MISSING_PARENT: u32 = 8460;
pub const ERROR_DS_DRA_PREEMPTED: u32 = 8461;
pub const ERROR_DS_DRA_ABANDON_SYNC: u32 = 8462;
pub const ERROR_DS_DRA_SHUTDOWN: u32 = 8463;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET: u32 = 8464;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA: u32 = 8465;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED: u32 = 8466;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH: u32 = 8467;
pub const ERROR_DS_DUP_LINK_ID: u32 = 8468;
pub const ERROR_DS_NAME_ERROR_RESOLVING: u32 = 8469;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND: u32 = 8470;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE: u32 = 8471;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING: u32 = 8472;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY: u32 = 8473;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING: u32 = 8474;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD: u32 = 8475;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS: u32 = 8476;
pub const ERROR_DS_DRA_REPL_PENDING: u32 = 8477;
pub const ERROR_DS_DS_REQUIRED: u32 = 8478;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME: u32 = 8479;
pub const ERROR_DS_NON_BASE_SEARCH: u32 = 8480;
pub const ERROR_DS_CANT_RETRIEVE_ATTS: u32 = 8481;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK: u32 = 8482;
pub const ERROR_DS_EPOCH_MISMATCH: u32 = 8483;
pub const ERROR_DS_SRC_NAME_MISMATCH: u32 = 8484;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL: u32 = 8485;
pub const ERROR_DS_DST_NC_MISMATCH: u32 = 8486;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC: u32 = 8487;
pub const ERROR_DS_SRC_GUID_MISMATCH: u32 = 8488;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT: u32 = 8489;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS: u32 = 8490;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD: u32 = 8491;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION: u32 = 8492;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS: u32 = 8493;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT: u32 = 8494;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE: u32 = 8495;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE: u32 = 8496;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER: u32 = 8497;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP: u32 = 8498;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP: u32 = 8499;
pub const ERROR_DS_INVALID_SEARCH_FLAG: u32 = 8500;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC: u32 = 8501;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE: u32 = 8502;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE: u32 = 8503;
pub const ERROR_DS_SAM_INIT_FAILURE: u32 = 8504;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION: u32 = 8505;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID: u32 = 8506;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD: u32 = 8507;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE: u32 = 8508;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED: u32 = 8509;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA: u32 = 8510;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION: u32 = 8511;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE: u32 = 8512;
pub const ERROR_DS_INVALID_GROUP_TYPE: u32 = 8513;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN: u32 = 8514;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN: u32 = 8515;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8516;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8517;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER: u32 = 8518;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER: u32 = 8519;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER: u32 = 8520;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS: u32 = 8521;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED: u32 = 8522;
pub const ERROR_DS_NAMING_MASTER_GC: u32 = 8523;
pub const ERROR_DS_LOOKUP_FAILURE: u32 = 8524;
pub const ERROR_DS_COULDNT_UPDATE_SPNS: u32 = 8525;
pub const ERROR_DS_CANT_RETRIEVE_SD: u32 = 8526;
pub const ERROR_DS_KEY_NOT_UNIQUE: u32 = 8527;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX: u32 = 8528;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD: u32 = 8529;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY: u32 = 8530;
pub const ERROR_DS_CANT_START: u32 = 8531;
pub const ERROR_DS_INIT_FAILURE: u32 = 8532;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION: u32 = 8533;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST: u32 = 8534;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST: u32 = 8535;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED: u32 = 8536;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN: u32 = 8537;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER: u32 = 8538;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST: u32 = 8539;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH: u32 = 8540;
pub const ERROR_SAM_INIT_FAILURE: u32 = 8541;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP: u32 = 8542;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT: u32 = 8543;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONLICT: u32 = 8544;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH: u32 = 8545;
pub const ERROR_DS_NC_STILL_HAS_DSAS: u32 = 8546;
pub const ERROR_DS_GC_REQUIRED: u32 = 8547;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY: u32 = 8548;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS: u32 = 8549;
pub const ERROR_DS_CANT_ADD_TO_GC: u32 = 8550;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC: u32 = 8551;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED: u32 = 8552;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC: u32 = 8553;
pub const ERROR_DS_INVALID_NAME_FOR_SPN: u32 = 8554;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS: u32 = 8555;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES: u32 = 8556;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED: u32 = 8557;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC: u32 = 8558;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER: u32 = 8559;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ: u32 = 8560;
pub const ERROR_DS_INIT_FAILURE_CONSOLE: u32 = 8561;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE: u32 = 8562;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH: u32 = 8563;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH: u32 = 8564;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW: u32 = 8565;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW: u32 = 8566;
pub const ERROR_DS_INCOMPATIBLE_VERSION: u32 = 8567;
pub const ERROR_DS_LOW_DSA_VERSION: u32 = 8568;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN: u32 = 8569;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER: u32 = 8570;
pub const ERROR_DS_NAME_NOT_UNIQUE: u32 = 8571;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4: u32 = 8572;
pub const ERROR_DS_OUT_OF_VERSION_STORE: u32 = 8573;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED: u32 = 8574;
pub const ERROR_DS_NO_REF_DOMAIN: u32 = 8575;
pub const ERROR_DS_RESERVED_LINK_ID: u32 = 8576;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE: u32 = 8577;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER: u32 = 8578;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE: u32 = 8579;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC: u32 = 8580;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG: u32 = 8581;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT: u32 = 8582;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL: u32 = 8583;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER: u32 = 8584;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD: u32 = 8585;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2: u32 = 8586;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED: u32 = 8587;
pub const ERROR_DS_NOT_CLOSEST: u32 = 8588;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF: u32 = 8589;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED: u32 = 8590;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR: u32 = 8591;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR: u32 = 8592;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS: u32 = 8593;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED: u32 = 8594;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR: u32 = 8595;
pub const ERROR_DS_NO_MSDS_INTID: u32 = 8596;
pub const ERROR_DS_DUP_MSDS_INTID: u32 = 8597;
pub const ERROR_DS_EXISTS_IN_RDNATTID: u32 = 8598;
pub const ERROR_DS_AUTHORIZATION_FAILED: u32 = 8599;
pub const ERROR_DS_INVALID_SCRIPT: u32 = 8600;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED: u32 = 8601;
pub const ERROR_DS_CROSS_REF_BUSY: u32 = 8602;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN: u32 = 8603;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC: u32 = 8604;
pub const ERROR_DS_DUPLICATE_ID_FOUND: u32 = 8605;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT: u32 = 8606;
pub const ERROR_DS_GROUP_CONVERSION_ERROR: u32 = 8607;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP: u32 = 8608;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP: u32 = 8609;
pub const ERROR_DS_ROLE_NOT_VERIFIED: u32 = 8610;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL: u32 = 8611;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS: u32 = 8612;
pub const ERROR_DS_EXISTING_AD_CHILD_NC: u32 = 8613;
pub const DNS_ERROR_RCODE_FORMAT_ERROR: u32 = 9001;
pub const DNS_ERROR_RCODE_SERVER_FAILURE: u32 = 9002;
pub const DNS_ERROR_RCODE_NAME_ERROR: u32 = 9003;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED: u32 = 9004;
pub const DNS_ERROR_RCODE_REFUSED: u32 = 9005;
pub const DNS_ERROR_RCODE_YXDOMAIN: u32 = 9006;
pub const DNS_ERROR_RCODE_YXRRSET: u32 = 9007;
pub const DNS_ERROR_RCODE_NXRRSET: u32 = 9008;
pub const DNS_ERROR_RCODE_NOTAUTH: u32 = 9009;
pub const DNS_ERROR_RCODE_NOTZONE: u32 = 9010;
pub const DNS_ERROR_RCODE_BADSIG: u32 = 9016;
pub const DNS_ERROR_RCODE_BADKEY: u32 = 9017;
pub const DNS_ERROR_RCODE_BADTIME: u32 = 9018;
pub const DNS_INFO_NO_RECORDS: u32 = 9501;
pub const DNS_ERROR_BAD_PACKET: u32 = 9502;
pub const DNS_ERROR_NO_PACKET: u32 = 9503;
pub const DNS_ERROR_RCODE: u32 = 9504;
pub const DNS_ERROR_UNSECURE_PACKET: u32 = 9505;
pub const DNS_ERROR_INVALID_TYPE: u32 = 9551;
pub const DNS_ERROR_INVALID_IP_ADDRESS: u32 = 9552;
pub const DNS_ERROR_INVALID_PROPERTY: u32 = 9553;
pub const DNS_ERROR_TRY_AGAIN_LATER: u32 = 9554;
pub const DNS_ERROR_NOT_UNIQUE: u32 = 9555;
pub const DNS_ERROR_NON_RFC_NAME: u32 = 9556;
pub const DNS_STATUS_FQDN: u32 = 9557;
pub const DNS_STATUS_DOTTED_NAME: u32 = 9558;
pub const DNS_STATUS_SINGLE_PART_NAME: u32 = 9559;
pub const DNS_ERROR_INVALID_NAME_CHAR: u32 = 9560;
pub const DNS_ERROR_NUMERIC_NAME: u32 = 9561;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER: u32 = 9562;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION: u32 = 9563;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS: u32 = 9564;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS: u32 = 9565;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST: u32 = 9601;
pub const DNS_ERROR_NO_ZONE_INFO: u32 = 9602;
pub const DNS_ERROR_INVALID_ZONE_OPERATION: u32 = 9603;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR: u32 = 9604;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD: u32 = 9605;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS: u32 = 9606;
pub const DNS_ERROR_ZONE_LOCKED: u32 = 9607;
pub const DNS_ERROR_ZONE_CREATION_FAILED: u32 = 9608;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS: u32 = 9609;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS: u32 = 9610;
pub const DNS_ERROR_INVALID_ZONE_TYPE: u32 = 9611;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP: u32 = 9612;
pub const DNS_ERROR_ZONE_NOT_SECONDARY: u32 = 9613;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES: u32 = 9614;
pub const DNS_ERROR_WINS_INIT_FAILED: u32 = 9615;
pub const DNS_ERROR_NEED_WINS_SERVERS: u32 = 9616;
pub const DNS_ERROR_NBSTAT_INIT_FAILED: u32 = 9617;
pub const DNS_ERROR_SOA_DELETE_INVALID: u32 = 9618;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS: u32 = 9619;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP: u32 = 9620;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN: u32 = 9621;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE: u32 = 9651;
pub const DNS_ERROR_INVALID_DATAFILE_NAME: u32 = 9652;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE: u32 = 9653;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED: u32 = 9654;
pub const DNS_ERROR_DATAFILE_PARSING: u32 = 9655;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST: u32 = 9701;
pub const DNS_ERROR_RECORD_FORMAT: u32 = 9702;
pub const DNS_ERROR_NODE_CREATION_FAILED: u32 = 9703;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE: u32 = 9704;
pub const DNS_ERROR_RECORD_TIMED_OUT: u32 = 9705;
pub const DNS_ERROR_NAME_NOT_IN_ZONE: u32 = 9706;
pub const DNS_ERROR_CNAME_LOOP: u32 = 9707;
pub const DNS_ERROR_NODE_IS_CNAME: u32 = 9708;
pub const DNS_ERROR_CNAME_COLLISION: u32 = 9709;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT: u32 = 9710;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS: u32 = 9711;
pub const DNS_ERROR_SECONDARY_DATA: u32 = 9712;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA: u32 = 9713;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST: u32 = 9714;
pub const DNS_WARNING_PTR_CREATE_FAILED: u32 = 9715;
pub const DNS_WARNING_DOMAIN_UNDELETED: u32 = 9716;
pub const DNS_ERROR_DS_UNAVAILABLE: u32 = 9717;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS: u32 = 9718;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE: u32 = 9719;
pub const DNS_INFO_AXFR_COMPLETE: u32 = 9751;
pub const DNS_ERROR_AXFR: u32 = 9752;
pub const DNS_INFO_ADDED_LOCAL_WINS: u32 = 9753;
pub const DNS_STATUS_CONTINUE_NEEDED: u32 = 9801;
pub const DNS_ERROR_NO_TCPIP: u32 = 9851;
pub const DNS_ERROR_NO_DNS_SERVERS: u32 = 9852;
pub const DNS_ERROR_DP_DOES_NOT_EXIST: u32 = 9901;
pub const DNS_ERROR_DP_ALREADY_EXISTS: u32 = 9902;
pub const DNS_ERROR_DP_NOT_ENLISTED: u32 = 9903;
pub const DNS_ERROR_DP_ALREADY_ENLISTED: u32 = 9904;
pub const DNS_ERROR_DP_NOT_AVAILABLE: u32 = 9905;
pub const WSABASEERR: u32 = 10000;
pub const WSAEINTR: u32 = 10004;
pub const WSAEBADF: u32 = 10009;
pub const WSAEACCES: u32 = 10013;
pub const WSAEFAULT: u32 = 10014;
pub const WSAEINVAL: u32 = 10022;
pub const WSAEMFILE: u32 = 10024;
pub const WSAEWOULDBLOCK: u32 = 10035;
pub const WSAEINPROGRESS: u32 = 10036;
pub const WSAEALREADY: u32 = 10037;
pub const WSAENOTSOCK: u32 = 10038;
pub const WSAEDESTADDRREQ: u32 = 10039;
pub const WSAEMSGSIZE: u32 = 10040;
pub const WSAEPROTOTYPE: u32 = 10041;
pub const WSAENOPROTOOPT: u32 = 10042;
pub const WSAEPROTONOSUPPORT: u32 = 10043;
pub const WSAESOCKTNOSUPPORT: u32 = 10044;
pub const WSAEOPNOTSUPP: u32 = 10045;
pub const WSAEPFNOSUPPORT: u32 = 10046;
pub const WSAEAFNOSUPPORT: u32 = 10047;
pub const WSAEADDRINUSE: u32 = 10048;
pub const WSAEADDRNOTAVAIL: u32 = 10049;
pub const WSAENETDOWN: u32 = 10050;
pub const WSAENETUNREACH: u32 = 10051;
pub const WSAENETRESET: u32 = 10052;
pub const WSAECONNABORTED: u32 = 10053;
pub const WSAECONNRESET: u32 = 10054;
pub const WSAENOBUFS: u32 = 10055;
pub const WSAEISCONN: u32 = 10056;
pub const WSAENOTCONN: u32 = 10057;
pub const WSAESHUTDOWN: u32 = 10058;
pub const WSAETOOMANYREFS: u32 = 10059;
pub const WSAETIMEDOUT: u32 = 10060;
pub const WSAECONNREFUSED: u32 = 10061;
pub const WSAELOOP: u32 = 10062;
pub const WSAENAMETOOLONG: u32 = 10063;
pub const WSAEHOSTDOWN: u32 = 10064;
pub const WSAEHOSTUNREACH: u32 = 10065;
pub const WSAENOTEMPTY: u32 = 10066;
pub const WSAEPROCLIM: u32 = 10067;
pub const WSAEUSERS: u32 = 10068;
pub const WSAEDQUOT: u32 = 10069;
pub const WSAESTALE: u32 = 10070;
pub const WSAEREMOTE: u32 = 10071;
pub const WSASYSNOTREADY: u32 = 10091;
pub const WSAVERNOTSUPPORTED: u32 = 10092;
pub const WSANOTINITIALISED: u32 = 10093;
pub const WSAEDISCON: u32 = 10101;
pub const WSAENOMORE: u32 = 10102;
pub const WSAECANCELLED: u32 = 10103;
pub const WSAEINVALIDPROCTABLE: u32 = 10104;
pub const WSAEINVALIDPROVIDER: u32 = 10105;
pub const WSAEPROVIDERFAILEDINIT: u32 = 10106;
pub const WSASYSCALLFAILURE: u32 = 10107;
pub const WSASERVICE_NOT_FOUND: u32 = 10108;
pub const WSATYPE_NOT_FOUND: u32 = 10109;
pub const WSA_E_NO_MORE: u32 = 10110;
pub const WSA_E_CANCELLED: u32 = 10111;
pub const WSAEREFUSED: u32 = 10112;
pub const WSAHOST_NOT_FOUND: u32 = 11001;
pub const WSATRY_AGAIN: u32 = 11002;
pub const WSANO_RECOVERY: u32 = 11003;
pub const WSANO_DATA: u32 = 11004;
pub const WSA_QOS_RECEIVERS: u32 = 11005;
pub const WSA_QOS_SENDERS: u32 = 11006;
pub const WSA_QOS_NO_SENDERS: u32 = 11007;
pub const WSA_QOS_NO_RECEIVERS: u32 = 11008;
pub const WSA_QOS_REQUEST_CONFIRMED: u32 = 11009;
pub const WSA_QOS_ADMISSION_FAILURE: u32 = 11010;
pub const WSA_QOS_POLICY_FAILURE: u32 = 11011;
pub const WSA_QOS_BAD_STYLE: u32 = 11012;
pub const WSA_QOS_BAD_OBJECT: u32 = 11013;
pub const WSA_QOS_TRAFFIC_CTRL_ERROR: u32 = 11014;
pub const WSA_QOS_GENERIC_ERROR: u32 = 11015;
pub const WSA_QOS_ESERVICETYPE: u32 = 11016;
pub const WSA_QOS_EFLOWSPEC: u32 = 11017;
pub const WSA_QOS_EPROVSPECBUF: u32 = 11018;
pub const WSA_QOS_EFILTERSTYLE: u32 = 11019;
pub const WSA_QOS_EFILTERTYPE: u32 = 11020;
pub const WSA_QOS_EFILTERCOUNT: u32 = 11021;
pub const WSA_QOS_EOBJLENGTH: u32 = 11022;
pub const WSA_QOS_EFLOWCOUNT: u32 = 11023;
pub const WSA_QOS_EUNKNOWNPSOBJ: u32 = 11024;
pub const WSA_QOS_EPOLICYOBJ: u32 = 11025;
pub const WSA_QOS_EFLOWDESC: u32 = 11026;
pub const WSA_QOS_EPSFLOWSPEC: u32 = 11027;
pub const WSA_QOS_EPSFILTERSPEC: u32 = 11028;
pub const WSA_QOS_ESDMODEOBJ: u32 = 11029;
pub const WSA_QOS_ESHAPERATEOBJ: u32 = 11030;
pub const WSA_QOS_RESERVED_PETYPE: u32 = 11031;
pub const ERROR_IPSEC_QM_POLICY_EXISTS: u32 = 13000;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND: u32 = 13001;
pub const ERROR_IPSEC_QM_POLICY_IN_USE: u32 = 13002;
pub const ERROR_IPSEC_MM_POLICY_EXISTS: u32 = 13003;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND: u32 = 13004;
pub const ERROR_IPSEC_MM_POLICY_IN_USE: u32 = 13005;
pub const ERROR_IPSEC_MM_FILTER_EXISTS: u32 = 13006;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND: u32 = 13007;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS: u32 = 13008;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND: u32 = 13009;
pub const ERROR_IPSEC_MM_AUTH_EXISTS: u32 = 13010;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND: u32 = 13011;
pub const ERROR_IPSEC_MM_AUTH_IN_USE: u32 = 13012;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND: u32 = 13013;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND: u32 = 13014;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND: u32 = 13015;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS: u32 = 13016;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND: u32 = 13017;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION: u32 = 13018;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION: u32 = 13019;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION: u32 = 13020;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION: u32 = 13021;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION: u32 = 13022;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION: u32 = 13023;
pub const WARNING_IPSEC_MM_POLICY_PRUNED: u32 = 13024;
pub const WARNING_IPSEC_QM_POLICY_PRUNED: u32 = 13025;
pub const ERROR_IPSEC_IKE_AUTH_FAIL: u32 = 13801;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL: u32 = 13802;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING: u32 = 13803;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR: u32 = 13804;
pub const ERROR_IPSEC_IKE_TIMED_OUT: u32 = 13805;
pub const ERROR_IPSEC_IKE_NO_CERT: u32 = 13806;
pub const ERROR_IPSEC_IKE_SA_DELETED: u32 = 13807;
pub const ERROR_IPSEC_IKE_SA_REAPED: u32 = 13808;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP: u32 = 13809;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP: u32 = 13810;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM: u32 = 13811;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM: u32 = 13812;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE: u32 = 13813;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP: u32 = 13814;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP: u32 = 13815;
pub const ERROR_IPSEC_IKE_ERROR: u32 = 13816;
pub const ERROR_IPSEC_IKE_CRL_FAILED: u32 = 13817;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE: u32 = 13818;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE: u32 = 13819;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY: u32 = 13820;
pub const ERROR_IPSEC_IKE_DH_FAIL: u32 = 13822;
pub const ERROR_IPSEC_IKE_INVALID_HEADER: u32 = 13824;
pub const ERROR_IPSEC_IKE_NO_POLICY: u32 = 13825;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE: u32 = 13826;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR: u32 = 13827;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY: u32 = 13828;
pub const ERROR_IPSEC_IKE_PROCESS_ERR: u32 = 13829;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA: u32 = 13830;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP: u32 = 13831;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS: u32 = 13832;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE: u32 = 13833;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID: u32 = 13834;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT: u32 = 13835;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ: u32 = 13836;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH: u32 = 13837;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG: u32 = 13838;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE: u32 = 13839;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY: u32 = 13840;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE: u32 = 13841;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR: u32 = 13842;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD: u32 = 13843;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA: u32 = 13844;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN: u32 = 13845;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE: u32 = 13846;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT: u32 = 13847;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED: u32 = 13848;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE: u32 = 13849;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY: u32 = 13850;
pub const ERROR_IPSEC_IKE_NOTCBPRIV: u32 = 13851;
pub const ERROR_IPSEC_IKE_SECLOADFAIL: u32 = 13852;
pub const ERROR_IPSEC_IKE_FAILSSPINIT: u32 = 13853;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP: u32 = 13854;
pub const ERROR_IPSEC_IKE_SRVACQFAIL: u32 = 13855;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED: u32 = 13856;
pub const ERROR_IPSEC_IKE_GETSPIFAIL: u32 = 13857;
pub const ERROR_IPSEC_IKE_INVALID_FILTER: u32 = 13858;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY: u32 = 13859;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED: u32 = 13860;
pub const ERROR_IPSEC_IKE_INVALID_POLICY: u32 = 13861;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI: u32 = 13862;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION: u32 = 13863;
pub const ERROR_IPSEC_IKE_DH_FAILURE: u32 = 13864;
pub const ERROR_IPSEC_IKE_INVALID_GROUP: u32 = 13865;
pub const ERROR_IPSEC_IKE_ENCRYPT: u32 = 13866;
pub const ERROR_IPSEC_IKE_DECRYPT: u32 = 13867;
pub const ERROR_IPSEC_IKE_POLICY_MATCH: u32 = 13868;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID: u32 = 13869;
pub const ERROR_IPSEC_IKE_INVALID_HASH: u32 = 13870;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG: u32 = 13871;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE: u32 = 13872;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG: u32 = 13873;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG: u32 = 13874;
pub const ERROR_IPSEC_IKE_INVALID_SIG: u32 = 13875;
pub const ERROR_IPSEC_IKE_LOAD_FAILED: u32 = 13876;
pub const ERROR_IPSEC_IKE_RPC_DELETE: u32 = 13877;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT: u32 = 13878;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY: u32 = 13879;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN: u32 = 13881;
pub const ERROR_IPSEC_IKE_MM_LIMIT: u32 = 13882;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED: u32 = 13883;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END: u32 = 13884;
pub const ERROR_SXS_SECTION_NOT_FOUND: u32 = 14000;
pub const ERROR_SXS_CANT_GEN_ACTCTX: u32 = 14001;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT: u32 = 14002;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND: u32 = 14003;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR: u32 = 14004;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR: u32 = 14005;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED: u32 = 14006;
pub const ERROR_SXS_KEY_NOT_FOUND: u32 = 14007;
pub const ERROR_SXS_VERSION_CONFLICT: u32 = 14008;
pub const ERROR_SXS_WRONG_SECTION_TYPE: u32 = 14009;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED: u32 = 14010;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET: u32 = 14011;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP: u32 = 14012;
pub const ERROR_SXS_UNKNOWN_ENCODING: u32 = 14013;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI: u32 = 14014;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14015;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED: u32 = 14016;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14017;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE: u32 = 14018;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE: u32 = 14019;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT: u32 = 14020;
pub const ERROR_SXS_DUPLICATE_DLL_NAME: u32 = 14021;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME: u32 = 14022;
pub const ERROR_SXS_DUPLICATE_CLSID: u32 = 14023;
pub const ERROR_SXS_DUPLICATE_IID: u32 = 14024;
pub const ERROR_SXS_DUPLICATE_TLBID: u32 = 14025;
pub const ERROR_SXS_DUPLICATE_PROGID: u32 = 14026;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME: u32 = 14027;
pub const ERROR_SXS_FILE_HASH_MISMATCH: u32 = 14028;
pub const ERROR_SXS_POLICY_PARSE_ERROR: u32 = 14029;
pub const ERROR_SXS_XML_E_MISSINGQUOTE: u32 = 14030;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX: u32 = 14031;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR: u32 = 14032;
pub const ERROR_SXS_XML_E_BADNAMECHAR: u32 = 14033;
pub const ERROR_SXS_XML_E_BADCHARINSTRING: u32 = 14034;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX: u32 = 14035;
pub const ERROR_SXS_XML_E_BADCHARDATA: u32 = 14036;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE: u32 = 14037;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND: u32 = 14038;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON: u32 = 14039;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN: u32 = 14040;
pub const ERROR_SXS_XML_E_INTERNALERROR: u32 = 14041;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE: u32 = 14042;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING: u32 = 14043;
pub const ERROR_SXS_XML_E_MISSING_PAREN: u32 = 14044;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE: u32 = 14045;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS: u32 = 14046;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL: u32 = 14047;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL: u32 = 14048;
pub const ERROR_SXS_XML_E_INVALID_UNICODE: u32 = 14049;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK: u32 = 14050;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG: u32 = 14051;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG: u32 = 14052;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE: u32 = 14053;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS: u32 = 14054;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL: u32 = 14055;
pub const ERROR_SXS_XML_E_BADXMLDECL: u32 = 14056;
pub const ERROR_SXS_XML_E_MISSINGROOT: u32 = 14057;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF: u32 = 14058;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET: u32 = 14059;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG: u32 = 14060;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG: u32 = 14061;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING: u32 = 14062;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT: u32 = 14063;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL: u32 = 14064;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA: u32 = 14065;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE: u32 = 14066;
pub const ERROR_SXS_XML_E_INVALIDENCODING: u32 = 14067;
pub const ERROR_SXS_XML_E_INVALIDSWITCH: u32 = 14068;
pub const ERROR_SXS_XML_E_BADXMLCASE: u32 = 14069;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE: u32 = 14070;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE: u32 = 14071;
pub const ERROR_SXS_XML_E_INVALID_VERSION: u32 = 14072;
pub const ERROR_SXS_XML_E_MISSINGEQUALS: u32 = 14073;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED: u32 = 14074;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT: u32 = 14075;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID: u32 = 14076;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT: u32 = 14077;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING: u32 = 14078;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE: u32 = 14079;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME: u32 = 14080;
pub const SEVERITY_SUCCESS: u32 = 0;
pub const SEVERITY_ERROR: u32 = 1;
pub const FACILITY_WINDOWS: u32 = 8;
pub const FACILITY_STORAGE: u32 = 3;
pub const FACILITY_RPC: u32 = 1;
pub const FACILITY_WIN32: u32 = 7;
pub const FACILITY_CONTROL: u32 = 10;
pub const FACILITY_NULL: u32 = 0;
pub const FACILITY_ITF: u32 = 4;
pub const FACILITY_DISPATCH: u32 = 2;
pub const FACILITY_NT_BIT: u32 = 268435456;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0;
pub const TIME_ZONE_ID_STANDARD: u32 = 1;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2;
pub const BYTE_ORDER: u32 = 1234;
pub const X8_F: &[u8; 4usize] = b"02x\0";
pub const U16_F: &[u8; 3usize] = b"hu\0";
pub const S16_F: &[u8; 3usize] = b"hd\0";
pub const X16_F: &[u8; 3usize] = b"hx\0";
pub const U32_F: &[u8; 2usize] = b"u\0";
pub const S32_F: &[u8; 2usize] = b"d\0";
pub const X32_F: &[u8; 2usize] = b"x\0";
pub const SZT_F: &[u8; 2usize] = b"u\0";
pub const LWIP_NO_STDDEF_H: u32 = 0;
pub const LWIP_NO_STDINT_H: u32 = 0;
pub const LWIP_HAVE_INT64: u32 = 1;
pub const LWIP_NO_INTTYPES_H: u32 = 0;
pub const LWIP_NO_LIMITS_H: u32 = 0;
pub const MB_LEN_MAX: u32 = 1;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const ULLONG_MAX: i32 = -1;
pub const CHAR_BIT: u32 = 8;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const LONG_MIN: i32 = -2147483648;
pub const USHRT_MAX: u32 = 65535;
pub const UINT_MAX: u32 = 4294967295;
pub const ULONG_MAX: u32 = 4294967295;
pub const SSIZE_MAX: u32 = 2147483647;
pub const LWIP_UINT32_MAX: u32 = 4294967295;
pub const LWIP_NO_CTYPE_H: u32 = 0;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _ALPHA: u32 = 259;
pub const LWIP_DBG_LEVEL_ALL: u32 = 0;
pub const LWIP_DBG_LEVEL_WARNING: u32 = 1;
pub const LWIP_DBG_LEVEL_SERIOUS: u32 = 2;
pub const LWIP_DBG_LEVEL_SEVERE: u32 = 3;
pub const LWIP_DBG_MASK_LEVEL: u32 = 3;
pub const LWIP_DBG_LEVEL_OFF: u32 = 0;
pub const LWIP_DBG_ON: u32 = 128;
pub const LWIP_DBG_OFF: u32 = 0;
pub const LWIP_DBG_TRACE: u32 = 64;
pub const LWIP_DBG_STATE: u32 = 32;
pub const LWIP_DBG_FRESH: u32 = 16;
pub const LWIP_DBG_HALT: u32 = 8;
pub const LWIP_TIMERS: u32 = 1;
pub const LWIP_TIMERS_CUSTOM: u32 = 0;
pub const LWIP_MPU_COMPATIBLE: u32 = 0;
pub const MEMP_MEM_INIT: u32 = 0;
pub const MEMP_OVERFLOW_CHECK: u32 = 0;
pub const MEMP_SANITY_CHECK: u32 = 0;
pub const MEM_OVERFLOW_CHECK: u32 = 0;
pub const MEM_SANITY_CHECK: u32 = 0;
pub const MEM_USE_POOLS: u32 = 0;
pub const MEM_USE_POOLS_TRY_BIGGER_POOL: u32 = 0;
pub const MEMP_USE_CUSTOM_POOLS: u32 = 0;
pub const LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT: u32 = 0;
pub const MEMP_NUM_PBUF: u32 = 16;
pub const MEMP_NUM_RAW_PCB: u32 = 4;
pub const MEMP_NUM_UDP_PCB: u32 = 4;
pub const MEMP_NUM_TCP_PCB: u32 = 5;
pub const MEMP_NUM_TCP_PCB_LISTEN: u32 = 8;
pub const MEMP_NUM_TCP_SEG: u32 = 16;
pub const MEMP_NUM_ALTCP_PCB: u32 = 5;
pub const MEMP_NUM_REASSDATA: u32 = 5;
pub const MEMP_NUM_FRAG_PBUF: u32 = 15;
pub const MEMP_NUM_ARP_QUEUE: u32 = 30;
pub const MEMP_NUM_IGMP_GROUP: u32 = 8;
pub const MEMP_NUM_NETBUF: u32 = 2;
pub const MEMP_NUM_NETCONN: u32 = 4;
pub const MEMP_NUM_SELECT_CB: u32 = 4;
pub const MEMP_NUM_TCPIP_MSG_API: u32 = 8;
pub const MEMP_NUM_TCPIP_MSG_INPKT: u32 = 8;
pub const MEMP_NUM_NETDB: u32 = 1;
pub const MEMP_NUM_LOCALHOSTLIST: u32 = 1;
pub const PBUF_POOL_SIZE: u32 = 16;
pub const MEMP_NUM_API_MSG: u32 = 8;
pub const MEMP_NUM_DNS_API_MSG: u32 = 8;
pub const MEMP_NUM_SOCKET_SETGETSOCKOPT_DATA: u32 = 8;
pub const MEMP_NUM_NETIFAPI_MSG: u32 = 8;
pub const ARP_TABLE_SIZE: u32 = 10;
pub const ARP_MAXAGE: u32 = 300;
pub const ARP_QUEUEING: u32 = 0;
pub const ARP_QUEUE_LEN: u32 = 3;
pub const ETHARP_SUPPORT_VLAN: u32 = 0;
pub const LWIP_ETHERNET: u32 = 1;
pub const ETH_PAD_SIZE: u32 = 0;
pub const ETHARP_SUPPORT_STATIC_ENTRIES: u32 = 0;
pub const IP_SOF_BROADCAST: u32 = 0;
pub const IP_SOF_BROADCAST_RECV: u32 = 0;
pub const IP_FORWARD_ALLOW_TX_ON_RX_NETIF: u32 = 0;
pub const LWIP_BROADCAST_PING: u32 = 0;
pub const LWIP_MULTICAST_PING: u32 = 0;
pub const RAW_TTL: u32 = 255;
pub const LWIP_DHCP_BOOTP_FILE: u32 = 0;
pub const LWIP_DHCP_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP_AUTOIP_COOP: u32 = 0;
pub const LWIP_DHCP_AUTOIP_COOP_TRIES: u32 = 9;
pub const DNS_TABLE_SIZE: u32 = 4;
pub const DNS_MAX_NAME_LENGTH: u32 = 256;
pub const DNS_MAX_SERVERS: u32 = 2;
pub const DNS_MAX_RETRIES: u32 = 4;
pub const DNS_DOES_NAME_CHECK: u32 = 1;
pub const LWIP_DNS_SECURE_RAND_XID: u32 = 1;
pub const LWIP_DNS_SECURE_NO_MULTIPLE_OUTSTANDING: u32 = 2;
pub const LWIP_DNS_SECURE_RAND_SRC_PORT: u32 = 4;
pub const DNS_LOCAL_HOSTLIST: u32 = 0;
pub const DNS_LOCAL_HOSTLIST_IS_DYNAMIC: u32 = 0;
pub const LWIP_DNS_SUPPORT_MDNS_QUERIES: u32 = 0;
pub const LWIP_NETBUF_RECVINFO: u32 = 0;
pub const TCP_TTL: u32 = 255;
pub const TCP_MAXRTX: u32 = 12;
pub const TCP_SYNMAXRTX: u32 = 6;
pub const TCP_QUEUE_OOSEQ: u32 = 1;
pub const LWIP_TCP_SACK_OUT: u32 = 0;
pub const LWIP_TCP_MAX_SACK_NUM: u32 = 4;
pub const TCP_CALCULATE_EFF_SEND_MSS: u32 = 1;
pub const TCP_SND_QUEUELEN: u32 = 180;
pub const TCP_OOSEQ_MAX_BYTES: u32 = 0;
pub const TCP_OOSEQ_MAX_PBUFS: u32 = 0;
pub const TCP_LISTEN_BACKLOG: u32 = 0;
pub const TCP_DEFAULT_LISTEN_BACKLOG: u32 = 255;
pub const TCP_OVERSIZE: u32 = 1432;
pub const LWIP_TCP_TIMESTAMPS: u32 = 0;
pub const LWIP_EVENT_API: u32 = 0;
pub const LWIP_CALLBACK_API: u32 = 1;
pub const LWIP_WND_SCALE: u32 = 0;
pub const TCP_RCV_SCALE: u32 = 0;
pub const LWIP_TCP_PCB_NUM_EXT_ARGS: u32 = 0;
pub const LWIP_ALTCP: u32 = 0;
pub const LWIP_ALTCP_TLS: u32 = 0;
pub const PBUF_LINK_ENCAPSULATION_HLEN: u32 = 0;
pub const LWIP_NETIF_HOSTNAME: u32 = 0;
pub const LWIP_NETIF_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_EXT_STATUS_CALLBACK: u32 = 0;
pub const LWIP_NETIF_LINK_CALLBACK: u32 = 0;
pub const LWIP_NETIF_REMOVE_CALLBACK: u32 = 0;
pub const LWIP_NETIF_HWADDRHINT: u32 = 0;
pub const LWIP_NETIF_TX_SINGLE_PBUF: u32 = 0;
pub const LWIP_NUM_NETIF_CLIENT_DATA: u32 = 0;
pub const LWIP_LOOPIF_MULTICAST: u32 = 0;
pub const LWIP_NETIF_LOOPBACK: u32 = 0;
pub const LWIP_LOOPBACK_MAX_PBUFS: u32 = 0;
pub const TCPIP_THREAD_NAME: &[u8; 13usize] = b"tcpip_thread\0";
pub const TCPIP_THREAD_PRIO: u32 = 1;
pub const TCPIP_MBOX_SIZE: u32 = 0;
pub const SLIPIF_THREAD_NAME: &[u8; 12usize] = b"slipif_loop\0";
pub const SLIPIF_THREAD_STACKSIZE: u32 = 0;
pub const SLIPIF_THREAD_PRIO: u32 = 1;
pub const DEFAULT_THREAD_NAME: &[u8; 5usize] = b"lwIP\0";
pub const DEFAULT_THREAD_PRIO: u32 = 1;
pub const DEFAULT_RAW_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_UDP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_TCP_RECVMBOX_SIZE: u32 = 0;
pub const DEFAULT_ACCEPTMBOX_SIZE: u32 = 0;
pub const LWIP_TCPIP_TIMEOUT: u32 = 0;
pub const LWIP_NETCONN_SEM_PER_THREAD: u32 = 0;
pub const LWIP_NETCONN_FULLDUPLEX: u32 = 0;
pub const LWIP_COMPAT_SOCKETS: u32 = 1;
pub const LWIP_POSIX_SOCKETS_IO_NAMES: u32 = 1;
pub const LWIP_SOCKET_OFFSET: u32 = 0;
pub const LWIP_TCP_KEEPALIVE: u32 = 0;
pub const LWIP_SO_SNDTIMEO: u32 = 0;
pub const LWIP_SO_RCVTIMEO: u32 = 0;
pub const LWIP_SO_SNDRCVTIMEO_NONSTANDARD: u32 = 0;
pub const LWIP_SO_RCVBUF: u32 = 0;
pub const LWIP_SO_LINGER: u32 = 0;
pub const RECV_BUFSIZE_DEFAULT: u32 = 2147483647;
pub const LWIP_TCP_CLOSE_TIMEOUT_MS_DEFAULT: u32 = 20000;
pub const SO_REUSE: u32 = 0;
pub const SO_REUSE_RXTOALL: u32 = 0;
pub const LWIP_FIONREAD_LINUXMODE: u32 = 0;
pub const LWIP_SOCKET_SELECT: u32 = 1;
pub const LWIP_SOCKET_POLL: u32 = 1;
pub const LWIP_STATS_DISPLAY: u32 = 0;
pub const LINK_STATS: u32 = 1;
pub const ETHARP_STATS: u32 = 1;
pub const IP_STATS: u32 = 1;
pub const ICMP_STATS: u32 = 1;
pub const IGMP_STATS: u32 = 0;
pub const UDP_STATS: u32 = 1;
pub const TCP_STATS: u32 = 1;
pub const IP6_STATS: u32 = 1;
pub const ND6_STATS: u32 = 1;
pub const LWIP_CHECKSUM_CTRL_PER_NETIF: u32 = 0;
pub const CHECKSUM_GEN_IP: u32 = 1;
pub const CHECKSUM_GEN_UDP: u32 = 1;
pub const CHECKSUM_GEN_TCP: u32 = 1;
pub const CHECKSUM_GEN_ICMP: u32 = 1;
pub const CHECKSUM_GEN_ICMP6: u32 = 1;
pub const CHECKSUM_CHECK_IP: u32 = 1;
pub const CHECKSUM_CHECK_UDP: u32 = 1;
pub const CHECKSUM_CHECK_TCP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP: u32 = 1;
pub const CHECKSUM_CHECK_ICMP6: u32 = 1;
pub const LWIP_CHECKSUM_ON_COPY: u32 = 0;
pub const IPV6_REASS_MAXAGE: u32 = 60;
pub const LWIP_IPV6_SCOPES_DEBUG: u32 = 0;
pub const LWIP_IPV6_NUM_ADDRESSES: u32 = 3;
pub const LWIP_IPV6_FORWARD: u32 = 0;
pub const LWIP_IPV6_FRAG: u32 = 1;
pub const LWIP_IPV6_REASS: u32 = 1;
pub const LWIP_IPV6_SEND_ROUTER_SOLICIT: u32 = 1;
pub const LWIP_IPV6_AUTOCONFIG: u32 = 1;
pub const LWIP_IPV6_ADDRESS_LIFETIMES: u32 = 1;
pub const LWIP_IPV6_DUP_DETECT_ATTEMPTS: u32 = 1;
pub const LWIP_ICMP6: u32 = 1;
pub const LWIP_ICMP6_DATASIZE: u32 = 0;
pub const LWIP_ICMP6_HL: u32 = 255;
pub const LWIP_IPV6_MLD: u32 = 1;
pub const MEMP_NUM_MLD6_GROUP: u32 = 4;
pub const LWIP_ND6_QUEUEING: u32 = 1;
pub const MEMP_NUM_ND6_QUEUE: u32 = 20;
pub const LWIP_ND6_NUM_NEIGHBORS: u32 = 10;
pub const LWIP_ND6_NUM_DESTINATIONS: u32 = 10;
pub const LWIP_ND6_NUM_PREFIXES: u32 = 5;
pub const LWIP_ND6_NUM_ROUTERS: u32 = 3;
pub const LWIP_ND6_MAX_MULTICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_UNICAST_SOLICIT: u32 = 3;
pub const LWIP_ND6_MAX_ANYCAST_DELAY_TIME: u32 = 1000;
pub const LWIP_ND6_MAX_NEIGHBOR_ADVERTISEMENT: u32 = 3;
pub const LWIP_ND6_REACHABLE_TIME: u32 = 30000;
pub const LWIP_ND6_RETRANS_TIMER: u32 = 1000;
pub const LWIP_ND6_DELAY_FIRST_PROBE_TIME: u32 = 5000;
pub const LWIP_ND6_ALLOW_RA_UPDATES: u32 = 1;
pub const LWIP_ND6_TCP_REACHABILITY_HINTS: u32 = 1;
pub const LWIP_ND6_RDNSS_MAX_DNS_SERVERS: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATEFUL: u32 = 0;
pub const LWIP_IPV6_DHCP6_STATELESS: u32 = 1;
pub const LWIP_DHCP6_GET_NTP_SRV: u32 = 0;
pub const LWIP_DHCP6_MAX_NTP_SERVERS: u32 = 1;
pub const LWIP_DHCP6_MAX_DNS_SERVERS: u32 = 2;
pub const LWIP_DBG_MIN_LEVEL: u32 = 0;
pub const PBUF_DEBUG: u32 = 0;
pub const IGMP_DEBUG: u32 = 0;
pub const INET_DEBUG: u32 = 0;
pub const MEM_DEBUG: u32 = 0;
pub const MEMP_DEBUG: u32 = 0;
pub const SYS_DEBUG: u32 = 0;
pub const TIMERS_DEBUG: u32 = 0;
pub const SLIP_DEBUG: u32 = 0;
pub const DHCP_DEBUG: u32 = 0;
pub const AUTOIP_DEBUG: u32 = 0;
pub const DNS_DEBUG: u32 = 0;
pub const IP6_DEBUG: u32 = 0;
pub const DHCP6_DEBUG: u32 = 0;
pub const LWIP_TESTMODE: u32 = 0;
pub const LWIP_PERF: u32 = 0;
pub const IP_CLASSA_NET: u32 = 4278190080;
pub const IP_CLASSA_NSHIFT: u32 = 24;
pub const IP_CLASSA_HOST: u32 = 16777215;
pub const IP_CLASSA_MAX: u32 = 128;
pub const IP_CLASSB_NET: u32 = 4294901760;
pub const IP_CLASSB_NSHIFT: u32 = 16;
pub const IP_CLASSB_HOST: u32 = 65535;
pub const IP_CLASSB_MAX: u32 = 65536;
pub const IP_CLASSC_NET: u32 = 4294967040;
pub const IP_CLASSC_NSHIFT: u32 = 8;
pub const IP_CLASSC_HOST: u32 = 255;
pub const IP_CLASSD_NET: u32 = 4026531840;
pub const IP_CLASSD_NSHIFT: u32 = 28;
pub const IP_CLASSD_HOST: u32 = 268435455;
pub const IP_LOOPBACKNET: u32 = 127;
pub const IP4ADDR_STRLEN_MAX: u32 = 16;
pub const IP6_NO_ZONE: u32 = 0;
pub const IPV6_CUSTOM_SCOPES: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED: u32 = 0;
pub const IP6_MULTICAST_SCOPE_RESERVED0: u32 = 0;
pub const IP6_MULTICAST_SCOPE_INTERFACE_LOCAL: u32 = 1;
pub const IP6_MULTICAST_SCOPE_LINK_LOCAL: u32 = 2;
pub const IP6_MULTICAST_SCOPE_RESERVED3: u32 = 3;
pub const IP6_MULTICAST_SCOPE_ADMIN_LOCAL: u32 = 4;
pub const IP6_MULTICAST_SCOPE_SITE_LOCAL: u32 = 5;
pub const IP6_MULTICAST_SCOPE_ORGANIZATION_LOCAL: u32 = 8;
pub const IP6_MULTICAST_SCOPE_GLOBAL: u32 = 14;
pub const IP6_MULTICAST_SCOPE_RESERVEDF: u32 = 15;
pub const IP6_ADDR_INVALID: u32 = 0;
pub const IP6_ADDR_TENTATIVE: u32 = 8;
pub const IP6_ADDR_TENTATIVE_1: u32 = 9;
pub const IP6_ADDR_TENTATIVE_2: u32 = 10;
pub const IP6_ADDR_TENTATIVE_3: u32 = 11;
pub const IP6_ADDR_TENTATIVE_4: u32 = 12;
pub const IP6_ADDR_TENTATIVE_5: u32 = 13;
pub const IP6_ADDR_TENTATIVE_6: u32 = 14;
pub const IP6_ADDR_TENTATIVE_7: u32 = 15;
pub const IP6_ADDR_VALID: u32 = 16;
pub const IP6_ADDR_PREFERRED: u32 = 48;
pub const IP6_ADDR_DEPRECATED: u32 = 16;
pub const IP6_ADDR_DUPLICATED: u32 = 64;
pub const IP6_ADDR_TENTATIVE_COUNT_MASK: u32 = 7;
pub const IP6_ADDR_LIFE_STATIC: u32 = 0;
pub const IP6_ADDR_LIFE_INFINITE: u32 = 4294967295;
pub const IP6ADDR_STRLEN_MAX: u32 = 46;
pub const IPADDR_STRLEN_MAX: u32 = 46;
pub const PBUF_TRANSPORT_HLEN: u32 = 20;
pub const PBUF_IP_HLEN: u32 = 40;
pub const PBUF_TYPE_FLAG_STRUCT_DATA_CONTIGUOUS: u32 = 128;
pub const PBUF_TYPE_FLAG_DATA_VOLATILE: u32 = 64;
pub const PBUF_TYPE_ALLOC_SRC_MASK: u32 = 15;
pub const PBUF_ALLOC_FLAG_RX: u32 = 256;
pub const PBUF_ALLOC_FLAG_DATA_CONTIGUOUS: u32 = 512;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_HEAP: u32 = 0;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF: u32 = 1;
pub const PBUF_TYPE_ALLOC_SRC_MASK_STD_MEMP_PBUF_POOL: u32 = 2;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MIN: u32 = 3;
pub const PBUF_TYPE_ALLOC_SRC_MASK_APP_MAX: u32 = 15;
pub const PBUF_FLAG_PUSH: u32 = 1;
pub const PBUF_FLAG_IS_CUSTOM: u32 = 2;
pub const PBUF_FLAG_MCASTLOOP: u32 = 4;
pub const PBUF_FLAG_LLBCAST: u32 = 8;
pub const PBUF_FLAG_LLMCAST: u32 = 16;
pub const PBUF_FLAG_TCP_FIN: u32 = 32;
pub const PBUF_POOL_FREE_OOSEQ: u32 = 1;
pub const MEM_SIZE_F: &[u8; 2usize] = b"u\0";
pub const MEMP_SIZE: u32 = 0;
pub const LWIP_STATS_LARGE: u32 = 0;
pub const STAT_COUNTER_F: &[u8; 3usize] = b"hu\0";
pub const NETIF_MAX_HWADDR_LEN: u32 = 6;
pub const NETIF_NAMESIZE: u32 = 6;
pub const NETIF_FLAG_UP: u32 = 1;
pub const NETIF_FLAG_BROADCAST: u32 = 2;
pub const NETIF_FLAG_LINK_UP: u32 = 4;
pub const NETIF_FLAG_ETHARP: u32 = 8;
pub const NETIF_FLAG_ETHERNET: u32 = 16;
pub const NETIF_FLAG_IGMP: u32 = 32;
pub const NETIF_FLAG_MLD6: u32 = 64;
pub const NETIF_ADDR_IDX_MAX: u32 = 127;
pub const LWIP_NETIF_USE_HINTS: u32 = 0;
pub const NETIF_NO_INDEX: u32 = 0;
pub const LWIP_NSC_NONE: u32 = 0;
pub const LWIP_NSC_NETIF_ADDED: u32 = 1;
pub const LWIP_NSC_NETIF_REMOVED: u32 = 2;
pub const LWIP_NSC_LINK_CHANGED: u32 = 4;
pub const LWIP_NSC_STATUS_CHANGED: u32 = 8;
pub const LWIP_NSC_IPV4_ADDRESS_CHANGED: u32 = 16;
pub const LWIP_NSC_IPV4_GATEWAY_CHANGED: u32 = 32;
pub const LWIP_NSC_IPV4_NETMASK_CHANGED: u32 = 64;
pub const LWIP_NSC_IPV4_SETTINGS_CHANGED: u32 = 128;
pub const LWIP_NSC_IPV6_SET: u32 = 256;
pub const LWIP_NSC_IPV6_ADDR_STATE_CHANGED: u32 = 512;
extern "C" {
    pub static mut debug_flags: libc::c_uchar;
}
extern "C" {
    pub fn _xbox_assert(
        expression: *const libc::c_char,
        file_name: *const libc::c_char,
        function_name: *const libc::c_char,
        line: libc::c_ulong,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout__PDCLIB_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_imaxdiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type _PDCLIB_va_list = __builtin_va_list;
pub type _PDCLIB_fd_t = *mut libc::c_void;
pub type _PDCLIB_thrd_t = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_cnd_t {
    pub eventHandles: [*mut libc::c_void; 2usize],
    pub waitCount: u32,
}
#[test]
fn bindgen_test_layout___PDCLIB_cnd_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_cnd_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_cnd_t>(),
        12usize,
        concat!("Size of: ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_cnd_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventHandles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(eventHandles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(waitCount)
        )
    );
}
pub type _PDCLIB_cnd_t = __PDCLIB_cnd_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_mtx_t {
    pub handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___PDCLIB_mtx_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_mtx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Size of: ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_mtx_t),
            "::",
            stringify!(handle)
        )
    );
}
pub type _PDCLIB_mtx_t = __PDCLIB_mtx_t;
pub type _PDCLIB_tss_t = libc::c_uint;
pub type _PDCLIB_once_flag = libc::c_int;
pub type _PDCLIB_int8_t = libc::c_schar;
pub type _PDCLIB_uint8_t = libc::c_uchar;
pub type _PDCLIB_int16_t = libc::c_short;
pub type _PDCLIB_uint16_t = libc::c_ushort;
pub type _PDCLIB_int32_t = libc::c_int;
pub type _PDCLIB_uint32_t = libc::c_uint;
pub type _PDCLIB_int64_t = libc::c_longlong;
pub type _PDCLIB_uint64_t = libc::c_ulonglong;
pub type _PDCLIB_int_fast8_t = libc::c_int;
pub type _PDCLIB_uint_fast8_t = libc::c_uint;
pub type _PDCLIB_int_fast16_t = libc::c_int;
pub type _PDCLIB_uint_fast16_t = libc::c_uint;
pub type _PDCLIB_int_fast32_t = libc::c_int;
pub type _PDCLIB_uint_fast32_t = libc::c_uint;
pub type _PDCLIB_int_fast64_t = libc::c_long;
pub type _PDCLIB_uint_fast64_t = libc::c_ulong;
pub type _PDCLIB_ptrdiff_t = libc::c_int;
pub type _PDCLIB_size_t = libc::c_uint;
pub type _PDCLIB_wchar_t = libc::c_ushort;
pub type _PDCLIB_wint_t = libc::c_ushort;
pub type _PDCLIB_intptr_t = libc::c_long;
pub type _PDCLIB_uintptr_t = libc::c_ulong;
pub type _PDCLIB_intmax_t = libc::c_longlong;
pub type _PDCLIB_uintmax_t = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_fpos_t {
    pub offset: _PDCLIB_uint64_t,
    pub status: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_file_t {
    pub handle: _PDCLIB_fd_t,
    pub buffer: *mut libc::c_char,
    pub bufsize: _PDCLIB_size_t,
    pub bufidx: _PDCLIB_size_t,
    pub bufend: _PDCLIB_size_t,
    pub pos: _PDCLIB_fpos_t,
    pub ungetidx: _PDCLIB_size_t,
    pub ungetbuf: *mut libc::c_uchar,
    pub status: libc::c_uint,
    pub filename: *mut libc::c_char,
    pub next: *mut _PDCLIB_file_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_file_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_file_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_file_t>(),
        64usize,
        concat!("Size of: ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufidx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetidx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetbuf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(next)
        )
    );
}
pub type _PDCLIB_time_t = libc::c_long;
pub type _PDCLIB_clock_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_exitfunc_t {
    pub next: *mut _PDCLIB_exitfunc_t,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__PDCLIB_exitfunc_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_exitfunc_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_exitfunc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_exitfunc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_status_t {
    pub base: libc::c_int,
    pub flags: _PDCLIB_int_fast32_t,
    pub n: _PDCLIB_size_t,
    pub i: _PDCLIB_size_t,
    pub current: _PDCLIB_size_t,
    pub s: *mut libc::c_char,
    pub width: _PDCLIB_size_t,
    pub prec: libc::c_int,
    pub stream: *mut _PDCLIB_file_t,
    pub arg: _PDCLIB_va_list,
}
#[test]
fn bindgen_test_layout__PDCLIB_status_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_status_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_status_t>(),
        40usize,
        concat!("Size of: ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn _PDCLIB_atomax(s: *const libc::c_char) -> _PDCLIB_intmax_t;
}
extern "C" {
    pub fn _PDCLIB_strtox_prelim(
        p: *const libc::c_char,
        sign: *mut libc::c_char,
        base: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_strtox_main(
        p: *mut *const libc::c_char,
        base: libc::c_uint,
        error: _PDCLIB_uintmax_t,
        limval: _PDCLIB_uintmax_t,
        limdigit: libc::c_int,
        sign: *mut libc::c_char,
    ) -> _PDCLIB_uintmax_t;
}
extern "C" {
    pub static _PDCLIB_digits: [libc::c_char; 0usize];
}
extern "C" {
    pub static _PDCLIB_Xdigits: [libc::c_char; 0usize];
}
extern "C" {
    pub fn _PDCLIB_print(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_scan(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_filemode(mode: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn _PDCLIB_prepread(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_prepwrite(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_closeall();
}
extern "C" {
    pub fn _PDCLIB_is_leap(year_offset: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_load_lines(
        stream: *mut _PDCLIB_file_t,
        lines: _PDCLIB_size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_getstream(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_setstream(stream: *mut _PDCLIB_file_t);
}
extern "C" {
    pub fn _PDCLIB_strtok(
        s1: *mut libc::c_char,
        s1max: *mut _PDCLIB_size_t,
        s2: *const libc::c_char,
        ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_errno_func() -> *mut libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_numeric_t {
    pub decimal_point: *mut libc::c_char,
    pub thousands_sep: *mut libc::c_char,
    pub grouping: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_numeric_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_numeric_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_numeric_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_numeric_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(grouping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_monetary_t {
    pub mon_decimal_point: *mut libc::c_char,
    pub mon_thousands_sep: *mut libc::c_char,
    pub mon_grouping: *mut libc::c_char,
    pub positive_sign: *mut libc::c_char,
    pub negative_sign: *mut libc::c_char,
    pub currency_symbol: *mut libc::c_char,
    pub int_curr_symbol: *mut libc::c_char,
    pub frac_digits: libc::c_char,
    pub p_cs_precedes: libc::c_char,
    pub n_cs_precedes: libc::c_char,
    pub p_sep_by_space: libc::c_char,
    pub n_sep_by_space: libc::c_char,
    pub p_sign_posn: libc::c_char,
    pub n_sign_posn: libc::c_char,
    pub int_frac_digits: libc::c_char,
    pub int_p_cs_precedes: libc::c_char,
    pub int_n_cs_precedes: libc::c_char,
    pub int_p_sep_by_space: libc::c_char,
    pub int_n_sep_by_space: libc::c_char,
    pub int_p_sign_posn: libc::c_char,
    pub int_n_sign_posn: libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_monetary_t>(),
        44usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_numeric_monetary_t {
    pub lconv: *mut lconv,
    pub numeric_alloced: libc::c_int,
    pub monetary_alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_numeric_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_numeric_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_numeric_monetary_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_numeric_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lconv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numeric_alloced) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(numeric_alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).monetary_alloced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(monetary_alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_numeric_monetary: _PDCLIB_lc_numeric_monetary_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_collate_t {
    pub alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_collate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_collate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_collate_t),
            "::",
            stringify!(alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_collate: _PDCLIB_lc_collate_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_entry_t {
    pub flags: _PDCLIB_uint16_t,
    pub upper: libc::c_uchar,
    pub lower: libc::c_uchar,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_entry_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_entry_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_entry_t>(),
        2usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(lower)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_t {
    pub alloced: libc::c_int,
    pub digits_low: libc::c_int,
    pub digits_high: libc::c_int,
    pub Xdigits_low: libc::c_int,
    pub Xdigits_high: libc::c_int,
    pub xdigits_low: libc::c_int,
    pub xdigits_high: libc::c_int,
    pub entry: *mut _PDCLIB_lc_ctype_entry_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_t>(),
        32usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_low) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_high) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_low) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_high) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_ctype: _PDCLIB_lc_ctype_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_messages_t {
    pub alloced: libc::c_int,
    pub errno_texts: [*mut libc::c_char; 141usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_messages_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_messages_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_messages_t>(),
        568usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_messages_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errno_texts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(errno_texts)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_messages: _PDCLIB_lc_messages_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_time_t {
    pub alloced: libc::c_int,
    pub month_name_abbr: [*mut libc::c_char; 12usize],
    pub month_name_full: [*mut libc::c_char; 12usize],
    pub day_name_abbr: [*mut libc::c_char; 7usize],
    pub day_name_full: [*mut libc::c_char; 7usize],
    pub date_time_format: *mut libc::c_char,
    pub time_format_12h: *mut libc::c_char,
    pub date_format: *mut libc::c_char,
    pub time_format: *mut libc::c_char,
    pub am_pm: [*mut libc::c_char; 2usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_time_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_time_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_time_t>(),
        180usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_time_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_abbr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_full) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_abbr) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_full) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_time_format) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format_12h) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format_12h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_format) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).am_pm) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(am_pm)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_time: _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_numeric(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_numeric_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_monetary(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_monetary_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_collate(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_collate_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_ctype(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_ctype_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_time(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_messages(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_messages_t;
}
pub const _PDCLIB_assert_568: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = libc::c_int;
pub const _PDCLIB_assert_569: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = libc::c_int;
pub const _PDCLIB_assert_570: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = libc::c_int;
pub const _PDCLIB_assert_571: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = libc::c_int;
pub const _PDCLIB_assert_574: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = libc::c_int;
pub const _PDCLIB_assert_577: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = libc::c_int;
pub const _PDCLIB_assert_580: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = libc::c_int;
pub const _PDCLIB_assert_586: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = libc::c_int;
pub const _PDCLIB_assert_589: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = libc::c_int;
extern "C" {
    pub fn atof(nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn strtod(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoll(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoul(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoull(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn atoi(nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub static mut _PDCLIB_seed: libc::c_ulong;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(seed: libc::c_uint);
}
extern "C" {
    pub fn malloc(size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(nmemb: libc::c_uint, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn aligned_alloc(alignment: libc::c_uint, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn realloc(ptr: *mut libc::c_void, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn at_quick_exit(func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn atexit(func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn exit(status: libc::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(status: libc::c_int);
}
extern "C" {
    pub fn _Exit(status: libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(string: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn bsearch(
        key: *const libc::c_void,
        base: *const libc::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn abs(j: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(j: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(j: libc::c_longlong) -> libc::c_longlong;
}
pub type div_t = _PDCLIB_div_t;
pub type ldiv_t = _PDCLIB_ldiv_t;
pub type lldiv_t = _PDCLIB_lldiv_t;
extern "C" {
    pub fn div(numer: libc::c_int, denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(numer: libc::c_long, denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(numer: libc::c_longlong, denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn _byteswap_ushort(val: libc::c_ushort) -> libc::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(val: libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(val: libc::c_ulonglong) -> libc::c_ulonglong;
}
pub type _purecall_handler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_purecall_handler(function: _purecall_handler) -> _purecall_handler;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = _PDCLIB_int_fast8_t;
pub type int_fast16_t = _PDCLIB_int_fast16_t;
pub type int_fast32_t = _PDCLIB_int_fast32_t;
pub type int_fast64_t = _PDCLIB_int_fast64_t;
pub type uint_fast8_t = _PDCLIB_uint_fast8_t;
pub type uint_fast16_t = _PDCLIB_uint_fast16_t;
pub type uint_fast32_t = _PDCLIB_uint_fast32_t;
pub type uint_fast64_t = _PDCLIB_uint_fast64_t;
pub type intmax_t = _PDCLIB_intmax_t;
pub type uintmax_t = _PDCLIB_uintmax_t;
pub type wchar_t = _PDCLIB_wchar_t;
pub type wint_t = _PDCLIB_wint_t;
pub type wctrans_t = libc::c_int;
pub type wctype_t = libc::c_int;
extern "C" {
    pub fn iswalnum(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswalpha(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswblank(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswcntrl(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswdigit(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswgraph(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswlower(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswprint(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswpunct(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswspace(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswupper(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswxdigit(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswctype(wc: wint_t, desc: wctype_t) -> libc::c_int;
}
extern "C" {
    pub fn wctype(property: *const libc::c_char) -> wctype_t;
}
extern "C" {
    pub fn towlower(wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towupper(wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towctrans(wc: wint_t, desc: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn wctrans(property: *const libc::c_char) -> wctrans_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XBOXRT_mbstate {
    pub __bindgen_anon_1: XBOXRT_mbstate__bindgen_ty_1,
    pub _Surrogate: u16,
    pub _PendState: libc::c_uchar,
    pub _PendChar: libc::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XBOXRT_mbstate__bindgen_ty_1 {
    pub _St64: [u64; 15usize],
    pub _St32: [u32; 31usize],
    pub _St16: [u16; 62usize],
    pub _StUC: [libc::c_uchar; 124usize],
    pub _StSC: [libc::c_schar; 124usize],
    pub _StC: [libc::c_char; 124usize],
}
#[test]
fn bindgen_test_layout_XBOXRT_mbstate__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<XBOXRT_mbstate__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XBOXRT_mbstate__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(XBOXRT_mbstate__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<XBOXRT_mbstate__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(XBOXRT_mbstate__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StUC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StUC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StSC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StC)
        )
    );
}
#[test]
fn bindgen_test_layout_XBOXRT_mbstate() {
    const UNINIT: ::core::mem::MaybeUninit<XBOXRT_mbstate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XBOXRT_mbstate>(),
        136usize,
        concat!("Size of: ", stringify!(XBOXRT_mbstate))
    );
    assert_eq!(
        ::core::mem::align_of::<XBOXRT_mbstate>(),
        8usize,
        concat!("Alignment of ", stringify!(XBOXRT_mbstate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._Surrogate) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_Surrogate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._PendState) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_PendState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._PendChar) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_PendChar)
        )
    );
}
pub type XBOXRT_mbstate_t = XBOXRT_mbstate;
pub type mbstate_t = XBOXRT_mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(s1: *mut wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemcpy(
        s1: *mut libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wmemmove(
        s1: *mut libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcscat(s1: *mut wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(s1: *const libc::c_ushort, s2: *const libc::c_ushort) -> libc::c_int;
}
extern "C" {
    pub fn wcscoll(s1: *const wchar_t, s2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsncmp(
        s1: *const libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcsxfrm(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> usize;
}
extern "C" {
    pub fn wmemcmp(
        s1: *const libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcschr(s: *const libc::c_ushort, c: libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcscspn(s1: *const wchar_t, s2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(s1: *const wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(s: *const wchar_t, c: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(s1: *const wchar_t, s2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsstr(s1: *const wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(s1: *mut wchar_t, s2: *const wchar_t, ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemchr(
        s: *const libc::c_ushort,
        c: libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcslen(s: *const libc::c_ushort) -> libc::c_uint;
}
extern "C" {
    pub fn mbsinit(ps: *const mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbrtowc(
        pwc: *mut wchar_t,
        s: *const libc::c_char,
        n: usize,
        ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(s: *mut libc::c_char, wc: wchar_t, ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wmemset(wcs: *mut wchar_t, wc: wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstol(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn wcstoll(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn mbrlen(s: *const libc::c_char, n: usize, ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn btowc(c: libc::c_int) -> wint_t;
}
extern "C" {
    pub fn mbsrtowcs(
        dest: *mut wchar_t,
        src: *mut *const libc::c_char,
        len: usize,
        ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wctob(c: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn wcrtomb_s(
        retval: *mut usize,
        s: *mut libc::c_char,
        ssz: usize,
        wc: wchar_t,
        ps: *mut mbstate_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn _snwprintf(
        buffer: *mut wchar_t,
        count: usize,
        format: *const wchar_t,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(pwc: *mut wchar_t, string: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    pub fn memcpy(
        s1: *mut libc::c_void,
        s2: *const libc::c_void,
        n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        s1: *mut libc::c_void,
        s2: *const libc::c_void,
        n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn memcmp(s1: *const libc::c_void, s2: *const libc::c_void, n: libc::c_uint)
        -> libc::c_int;
}
extern "C" {
    pub fn strcmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        s1: *const libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(s1: *mut libc::c_char, s2: *const libc::c_char, n: libc::c_uint)
        -> libc::c_uint;
}
extern "C" {
    pub fn memchr(s: *const libc::c_void, c: libc::c_int, n: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn strchr(s: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strpbrk(s1: *const libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(s: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strstr(s1: *const libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn memset(s: *mut libc::c_void, c: libc::c_int, n: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn strerror(errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(s: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strnicmp(s1: *const libc::c_char, s2: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    pub fn _stricmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " Prints a message to whatever debug facilities might\n be available."]
    pub fn debugPrint(format: *const libc::c_char, ...);
}
extern "C" {
    pub fn debugPrintNum(i: libc::c_int);
}
extern "C" {
    pub fn debugPrintBinary(num: libc::c_int);
}
extern "C" {
    pub fn debugPrintHex(buffer: *const libc::c_char, length: libc::c_int);
}
extern "C" {
    pub fn debugClearScreen();
}
extern "C" {
    pub fn debugAdvanceScreen();
}
extern "C" {
    pub fn debugMoveCursor(x: libc::c_int, y: libc::c_int);
}
extern "C" {
    pub fn debugResetCursor();
}
pub type LPCVOID = *const libc::c_void;
pub type VOID = libc::c_void;
pub type PVOID = *mut libc::c_void;
pub type LPVOID = *mut libc::c_void;
pub type HANDLE = PVOID;
pub type PHANDLE = *mut PVOID;
pub type BOOLEAN = libc::c_uchar;
pub type PBOOLEAN = *mut libc::c_uchar;
pub type SCHAR = libc::c_schar;
pub type PSCHAR = *mut libc::c_schar;
pub type CHAR = libc::c_char;
pub type PCHAR = *mut libc::c_char;
pub type CCHAR = libc::c_char;
pub type LPCH = *mut libc::c_char;
pub type PCH = *mut libc::c_char;
pub type OCHAR = libc::c_char;
pub type POCHAR = *mut libc::c_char;
pub type SHORT = libc::c_short;
pub type PSHORT = *mut libc::c_short;
pub type INT = libc::c_int;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type LONG = libc::c_long;
pub type PLONG = *mut libc::c_long;
pub type LPLONG = *mut libc::c_long;
pub type LONGLONG = libc::c_longlong;
pub type PLONGLONG = *mut libc::c_longlong;
pub type BYTE = libc::c_uchar;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut libc::c_ushort;
pub type CSHORT = libc::c_ushort;
pub type WORD = libc::c_ushort;
pub type WCHAR = libc::c_ushort;
pub type PWSTR = *mut libc::c_ushort;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
pub type LPUINT = *mut libc::c_uint;
pub type DWORD = libc::c_ulong;
pub type PDWORD = *mut libc::c_ulong;
pub type LPDWORD = *mut libc::c_ulong;
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut libc::c_ulong;
pub type ULONGLONG = libc::c_ulonglong;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SIZE_T = libc::c_uint;
pub type PSIZE_T = *mut libc::c_uint;
pub type BOOL = libc::c_int;
pub type PBOOL = *mut libc::c_int;
pub type PCSZ = *const libc::c_char;
pub type PCSTR = *const libc::c_char;
pub type LPCSTR = *const libc::c_char;
pub type QUAD = ULONGLONG;
pub type ULONG_PTR = ULONG;
pub type LONG_PTR = LONG;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: WORD,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub MXCsr: DWORD,
    pub Reserved2: DWORD,
    pub RegisterArea: [BYTE; 128usize],
    pub XmmRegisterArea: [BYTE; 128usize],
    pub Reserved4: [BYTE; 224usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__FLOATING_SAVE_AREA() {
    const UNINIT: ::core::mem::MaybeUninit<_FLOATING_SAVE_AREA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLOATING_SAVE_AREA>(),
        516usize,
        concat!("Size of: ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::core::mem::align_of::<_FLOATING_SAVE_AREA>(),
        1usize,
        concat!("Alignment of ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MXCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(MXCsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegisterArea) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XmmRegisterArea) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(XmmRegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut _FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    pub ContextFlags: DWORD,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CONTEXT>(),
        568usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edi) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esi) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebx) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edx) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ecx) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eax) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eip) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esp) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_RECORD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_RECORD>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_RECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut _EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = *mut STRING;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "< A signed 64-bit integer."]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type PLARGE_INTEGER = *mut _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "< An unsigned 64-bit integer."]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits. */ /**< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type PULARGE_INTEGER = *mut _ULARGE_INTEGER;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "< Points to the next entry of the list or the header if there is no next entry"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "< Points to the previous entry of the list or the header if there is no previous entry"]
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type LIST_ENTRY = _LIST_ENTRY;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub Synchronization: _RTL_CRITICAL_SECTION__bindgen_ty_1,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_CRITICAL_SECTION__bindgen_ty_1 {
    pub Event: _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1,
    pub RawEvent: [ULONG; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaitListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(Event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RawEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(RawEvent)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        28usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Synchronization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(Synchronization)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_SECTION_HEADER {
    pub Flags: DWORD,
    pub VirtualAddress: DWORD,
    pub VirtualSize: DWORD,
    pub FileAddress: DWORD,
    pub FileSize: DWORD,
    pub SectionName: PCSZ,
    pub SectionReferenceCount: LONG,
    pub HeadReferenceCount: *mut WORD,
    pub TailReferenceCount: *mut WORD,
    pub CheckSum: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__XBE_SECTION_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_SECTION_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_SECTION_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionReferenceCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadReferenceCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(HeadReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TailReferenceCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(TailReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
}
pub type XBE_SECTION_HEADER = _XBE_SECTION_HEADER;
pub type PXBE_SECTION_HEADER = *mut _XBE_SECTION_HEADER;
pub type HWND = HANDLE;
pub type HINSTANCE = HANDLE;
pub type HMODULE = HINSTANCE;
pub type FARPROC = ::core::option::Option<unsafe extern "stdcall" fn() -> libc::c_int>;
extern "C" {
    pub fn IsDebuggerPresent() -> BOOL;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
    const UNINIT: ::core::mem::MaybeUninit<_FILETIME> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILETIME>(),
        8usize,
        concat!("Size of: ", stringify!(_FILETIME))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILETIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILETIME))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwLowDateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwLowDateTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwHighDateTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwHighDateTime)
        )
    );
}
pub type FILETIME = _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OVERLAPPED {
    pub Internal: ULONG_PTR,
    pub InternalHigh: ULONG_PTR,
    pub Offset: DWORD,
    pub OffsetHigh: DWORD,
    pub hEvent: HANDLE,
}
#[test]
fn bindgen_test_layout__OVERLAPPED() {
    const UNINIT: ::core::mem::MaybeUninit<_OVERLAPPED> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OVERLAPPED>(),
        20usize,
        concat!("Size of: ", stringify!(_OVERLAPPED))
    );
    assert_eq!(
        ::core::mem::align_of::<_OVERLAPPED>(),
        4usize,
        concat!("Alignment of ", stringify!(_OVERLAPPED))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Internal) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OVERLAPPED),
            "::",
            stringify!(Internal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InternalHigh) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OVERLAPPED),
            "::",
            stringify!(InternalHigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OVERLAPPED),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OffsetHigh) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OVERLAPPED),
            "::",
            stringify!(OffsetHigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hEvent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OVERLAPPED),
            "::",
            stringify!(hEvent)
        )
    );
}
pub type OVERLAPPED = _OVERLAPPED;
pub type LPOVERLAPPED = *mut _OVERLAPPED;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEMTIME {
    pub wYear: WORD,
    pub wMonth: WORD,
    pub wDayOfWeek: WORD,
    pub wDay: WORD,
    pub wHour: WORD,
    pub wMinute: WORD,
    pub wSecond: WORD,
    pub wMilliseconds: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEMTIME() {
    const UNINIT: ::core::mem::MaybeUninit<_SYSTEMTIME> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SYSTEMTIME>(),
        16usize,
        concat!("Size of: ", stringify!(_SYSTEMTIME))
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEMTIME>(),
        2usize,
        concat!("Alignment of ", stringify!(_SYSTEMTIME))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wYear) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wYear)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wMonth) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wMonth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wDayOfWeek) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wDayOfWeek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wDay) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wDay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wHour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wHour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wMinute) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wMinute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wSecond) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wSecond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wMilliseconds) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEMTIME),
            "::",
            stringify!(wMilliseconds)
        )
    );
}
pub type SYSTEMTIME = _SYSTEMTIME;
pub type PSYSTEMTIME = *mut _SYSTEMTIME;
pub type LPSYSTEMTIME = *mut _SYSTEMTIME;
pub type HRESULT = LONG;
pub type LPSTR = *mut CHAR;
pub type LONG64 = libc::c_longlong;
pub type PLONG64 = *mut libc::c_longlong;
extern "C" {
    pub fn InterlockedExchange64(Target: *mut LONG64, Value: LONG64) -> LONG64;
}
extern "C" {
    pub fn InterlockedExchangePointer(Target: *mut PVOID, Value: PVOID) -> PVOID;
}
extern "C" {
    pub fn InterlockedCompareExchangePointer(
        Destination: *mut PVOID,
        Exchange: PVOID,
        Comperand: PVOID,
    ) -> PVOID;
}
pub type LPCTSTR = LPCSTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
#[test]
fn bindgen_test_layout__EXCEPTION_POINTERS() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_POINTERS> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_POINTERS>(),
        8usize,
        concat!("Size of: ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_POINTERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextRecord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ContextRecord)
        )
    );
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
    pub e_magic: WORD,
    pub e_cblp: WORD,
    pub e_cp: WORD,
    pub e_crlc: WORD,
    pub e_cparhdr: WORD,
    pub e_minalloc: WORD,
    pub e_maxalloc: WORD,
    pub e_ss: WORD,
    pub e_sp: WORD,
    pub e_csum: WORD,
    pub e_ip: WORD,
    pub e_cs: WORD,
    pub e_lfarlc: WORD,
    pub e_ovno: WORD,
    pub e_res: [WORD; 4usize],
    pub e_oemid: WORD,
    pub e_oeminfo: WORD,
    pub e_res2: [WORD; 10usize],
    pub e_lfanew: LONG,
}
#[test]
fn bindgen_test_layout__IMAGE_DOS_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_DOS_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_DOS_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_IMAGE_DOS_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_DOS_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DOS_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_cblp) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cblp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_cp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_crlc) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_crlc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_cparhdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cparhdr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_minalloc) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_minalloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_maxalloc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_maxalloc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_ss) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_sp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_sp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_csum) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_csum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_ip) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_cs) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_cs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_lfarlc) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_lfarlc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_ovno) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_ovno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_res) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_res)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_oemid) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_oemid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_oeminfo) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_oeminfo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_res2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_res2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).e_lfanew) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DOS_HEADER),
            "::",
            stringify!(e_lfanew)
        )
    );
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
pub type PIMAGE_DOS_HEADER = *mut _IMAGE_DOS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    pub VirtualAddress: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DATA_DIRECTORY() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_DATA_DIRECTORY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_DATA_DIRECTORY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_DATA_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(Size)
        )
    );
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
pub type PIMAGE_DATA_DIRECTORY = *mut _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub ImageBase: DWORD,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: DWORD,
    pub SizeOfStackCommit: DWORD,
    pub SizeOfHeapReserve: DWORD,
    pub SizeOfHeapCommit: DWORD,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_OPTIONAL_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_OPTIONAL_HEADER>(),
        224usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_OPTIONAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorLinkerVersion) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorLinkerVersion) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfCode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfInitializedData) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfUninitializedData) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfEntryPoint) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseOfCode) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseOfData) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionAlignment) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAlignment) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MajorOperatingSystemVersion) as usize - ptr as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).MinorOperatingSystemVersion) as usize - ptr as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorImageVersion) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorImageVersion) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorSubsystemVersion) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorSubsystemVersion) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Win32VersionValue) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeaders) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Subsystem) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DllCharacteristics) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfStackReserve) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfStackCommit) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeapReserve) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeapCommit) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LoaderFlags) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfRvaAndSizes) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataDirectory) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DataDirectory)
        )
    );
}
pub type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER;
pub type PIMAGE_OPTION_HEADER32 = *mut _IMAGE_OPTIONAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    pub Machine: WORD,
    pub NumberOfSections: WORD,
    pub TimeDateStamp: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
    pub SizeOfOptionalHeader: WORD,
    pub Characteristics: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_FILE_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_FILE_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_FILE_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_FILE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Machine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfSections) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToSymbolTable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfSymbols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfOptionalHeader) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(SizeOfOptionalHeader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
pub type PIMAGE_FILE_HEADER = *mut _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS32 {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER32,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS32() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_NT_HEADERS32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_NT_HEADERS32>(),
        248usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS32))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_NT_HEADERS32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS32),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileHeader) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS32),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OptionalHeader) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS32),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS32;
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    pub Name: [BYTE; 8usize],
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    pub VirtualAddress: DWORD,
    pub SizeOfRawData: DWORD,
    pub PointerToRawData: DWORD,
    pub PointerToRelocations: DWORD,
    pub PointerToLinenumbers: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    pub PhysicalAddress: DWORD,
    pub VirtualSize: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_SECTION_HEADER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PhysicalAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(PhysicalAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(VirtualSize)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_SECTION_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_SECTION_HEADER>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Misc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Misc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfRawData) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(SizeOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToRawData) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToRelocations) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRelocations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToLinenumbers) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfRelocations) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLinenumbers) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER;
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_IMPORT_DESCRIPTOR {
    pub DUMMYUNIONNAME: _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1,
    pub TimeDateStamp: DWORD,
    pub ForwarderChain: DWORD,
    pub Name: DWORD,
    pub FirstThunk: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub OriginalFirstThunk: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OriginalFirstThunk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(OriginalFirstThunk)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_IMPORT_DESCRIPTOR> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DUMMYUNIONNAME) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(DUMMYUNIONNAME)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ForwarderChain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(ForwarderChain)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstThunk) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(FirstThunk)
        )
    );
}
pub type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
pub type PIMAGE_IMPORT_DESCRIPTOR = *mut _IMAGE_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Name: DWORD,
    pub Base: DWORD,
    pub NumberOfFunctions: DWORD,
    pub NumberOfNames: DWORD,
    pub AddressOfFunctions: DWORD,
    pub AddressOfNames: DWORD,
    pub AddressOfNameOrdinals: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_EXPORT_DIRECTORY() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_EXPORT_DIRECTORY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_EXPORT_DIRECTORY>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_EXPORT_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Base) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfFunctions) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfFunctions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfNames) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfNames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfFunctions) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfFunctions)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfNames) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNames)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfNameOrdinals) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNameOrdinals)
        )
    );
}
pub type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY;
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32 {
    pub StartAddressOfRawData: DWORD,
    pub EndAddressOfRawData: DWORD,
    pub AddressOfIndex: DWORD,
    pub AddressOfCallBacks: DWORD,
    pub SizeOfZeroFill: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn Alignment(&self) -> DWORD {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Alignment(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> DWORD {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: DWORD,
        Alignment: DWORD,
        Reserved1: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let Reserved0: u32 = unsafe { ::core::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let Alignment: u32 = unsafe { ::core::mem::transmute(Alignment) };
            Alignment as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved1: u32 = unsafe { ::core::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32() {
    const UNINIT: ::core::mem::MaybeUninit<_IMAGE_TLS_DIRECTORY32> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IMAGE_TLS_DIRECTORY32>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        ::core::mem::align_of::<_IMAGE_TLS_DIRECTORY32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartAddressOfRawData) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(StartAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndAddressOfRawData) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(EndAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfIndex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfCallBacks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfCallBacks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfZeroFill) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(SizeOfZeroFill)
        )
    );
}
pub type IMAGE_TLS_DIRECTORY_32 = _IMAGE_TLS_DIRECTORY32;
pub type PIMAGE_TLS_DIRECTORY_32 = *mut _IMAGE_TLS_DIRECTORY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_CERTIFICATE_HEADER {
    pub SizeOfHeader: DWORD,
    pub TimeDateStamp: DWORD,
    pub TitleID: DWORD,
    pub TitleName: [WCHAR; 40usize],
    pub AlternateTitleIDs: [DWORD; 16usize],
    pub AllowedMedia: DWORD,
    pub GameRegion: DWORD,
    pub GameRatings: DWORD,
    pub DiscNumber: DWORD,
    pub Version: DWORD,
    pub LANKey: [BYTE; 16usize],
    pub SignatureKey: [BYTE; 16usize],
    pub AlternateSignatureKeys: [BYTE; 256usize],
}
#[test]
fn bindgen_test_layout__XBE_CERTIFICATE_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_CERTIFICATE_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_CERTIFICATE_HEADER>(),
        464usize,
        concat!("Size of: ", stringify!(_XBE_CERTIFICATE_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_CERTIFICATE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_CERTIFICATE_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeader) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(SizeOfHeader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TitleID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(TitleID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TitleName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(TitleName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlternateTitleIDs) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(AlternateTitleIDs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllowedMedia) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(AllowedMedia)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GameRegion) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(GameRegion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GameRatings) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(GameRatings)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DiscNumber) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(DiscNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LANKey) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(LANKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignatureKey) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(SignatureKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlternateSignatureKeys) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_CERTIFICATE_HEADER),
            "::",
            stringify!(AlternateSignatureKeys)
        )
    );
}
pub type XBE_CERTIFICATE_HEADER = _XBE_CERTIFICATE_HEADER;
pub type PXBE_CERTIFICATE_HEADER = *mut _XBE_CERTIFICATE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_LIBRARY_HEADER {
    pub LibraryName: [CHAR; 8usize],
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub BuildVersion: WORD,
    pub LibraryFlags: WORD,
}
#[test]
fn bindgen_test_layout__XBE_LIBRARY_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_LIBRARY_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_LIBRARY_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_XBE_LIBRARY_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_LIBRARY_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_XBE_LIBRARY_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LibraryName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_LIBRARY_HEADER),
            "::",
            stringify!(LibraryName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorVersion) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_LIBRARY_HEADER),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MinorVersion) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_LIBRARY_HEADER),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BuildVersion) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_LIBRARY_HEADER),
            "::",
            stringify!(BuildVersion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LibraryFlags) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_LIBRARY_HEADER),
            "::",
            stringify!(LibraryFlags)
        )
    );
}
pub type XBE_LIBRARY_HEADER = _XBE_LIBRARY_HEADER;
pub type PXBE_LIBRARY_HEADER = *mut _XBE_LIBRARY_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_FILE_HEADER {
    pub Magic: DWORD,
    pub Signature: [UCHAR; 256usize],
    pub ImageBase: DWORD,
    pub SizeOfHeaders: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfImageHeader: DWORD,
    pub TimeDateStamp: DWORD,
    pub CertificateHeader: PXBE_CERTIFICATE_HEADER,
    pub NumberOfSections: DWORD,
    pub PointerToSectionTable: PXBE_SECTION_HEADER,
    pub InitFlags: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub PointerToTlsDirectory: PIMAGE_TLS_DIRECTORY_32,
    pub SizeOfStack: DWORD,
    pub SizeOfHeapReserve: DWORD,
    pub SizeOfHeapCommit: DWORD,
    pub PeImageBase: DWORD,
    pub PeSizeOfImage: DWORD,
    pub PeImageCheckSum: DWORD,
    pub PeTimeDateStamp: DWORD,
    pub PeDebugPath: DWORD,
    pub PeDebugFilename: DWORD,
    pub PeDebugFilenameUnicode: DWORD,
    pub PointerToKernelThunkTable: DWORD,
    pub PointerToDebugImportTable: DWORD,
    pub NumberOfLibraries: DWORD,
    pub PointerToLibraries: PXBE_LIBRARY_HEADER,
    pub PointerToKernelLibrary: PXBE_LIBRARY_HEADER,
    pub PointerToXapiLibrary: PXBE_LIBRARY_HEADER,
    pub PointerToLogoBitmap: DWORD,
    pub SizeOfLogoBitmap: DWORD,
}
#[test]
fn bindgen_test_layout__XBE_FILE_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_FILE_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_FILE_HEADER>(),
        376usize,
        concat!("Size of: ", stringify!(_XBE_FILE_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_FILE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_FILE_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ImageBase) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeaders) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfImage) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfImageHeader) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfImageHeader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeDateStamp) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CertificateHeader) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(CertificateHeader)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfSections) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToSectionTable) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToSectionTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InitFlags) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(InitFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressOfEntryPoint) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToTlsDirectory) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToTlsDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfStack) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeapReserve) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfHeapCommit) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeImageBase) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeImageBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeSizeOfImage) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeSizeOfImage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeImageCheckSum) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeImageCheckSum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeTimeDateStamp) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeTimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeDebugPath) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeDebugPath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeDebugFilename) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeDebugFilename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PeDebugFilenameUnicode) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PeDebugFilenameUnicode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToKernelThunkTable) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToKernelThunkTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToDebugImportTable) as usize - ptr as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToDebugImportTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLibraries) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(NumberOfLibraries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToLibraries) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToLibraries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToKernelLibrary) as usize - ptr as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToKernelLibrary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToXapiLibrary) as usize - ptr as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToXapiLibrary)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerToLogoBitmap) as usize - ptr as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(PointerToLogoBitmap)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SizeOfLogoBitmap) as usize - ptr as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_FILE_HEADER),
            "::",
            stringify!(SizeOfLogoBitmap)
        )
    );
}
pub type XBE_FILE_HEADER = _XBE_FILE_HEADER;
pub type PXBE_FILE_HEADER = *mut _XBE_FILE_HEADER;
pub type UINT_PTR = libc::c_uint;
pub type PFLS_CALLBACK_FUNCTION = ::core::option::Option<unsafe extern "stdcall" fn(arg1: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _INIT_ONCE {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__INIT_ONCE() {
    const UNINIT: ::core::mem::MaybeUninit<_INIT_ONCE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_INIT_ONCE>(),
        4usize,
        concat!("Size of: ", stringify!(_INIT_ONCE))
    );
    assert_eq!(
        ::core::mem::align_of::<_INIT_ONCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_INIT_ONCE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_INIT_ONCE),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type INIT_ONCE = _INIT_ONCE;
pub type PINIT_ONCE = *mut _INIT_ONCE;
pub type LPINIT_ONCE = *mut _INIT_ONCE;
pub type PINIT_ONCE_FN = ::core::option::Option<
    unsafe extern "stdcall" fn(arg1: PINIT_ONCE, arg2: PVOID, arg3: *mut PVOID) -> BOOL,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONDITION_VARIABLE {
    pub initOnce: INIT_ONCE,
    pub eventHandles: [PVOID; 2usize],
    pub waitCount: libc::c_int,
}
#[test]
fn bindgen_test_layout__CONDITION_VARIABLE() {
    const UNINIT: ::core::mem::MaybeUninit<_CONDITION_VARIABLE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CONDITION_VARIABLE>(),
        16usize,
        concat!("Size of: ", stringify!(_CONDITION_VARIABLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_CONDITION_VARIABLE>(),
        4usize,
        concat!("Alignment of ", stringify!(_CONDITION_VARIABLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).initOnce) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONDITION_VARIABLE),
            "::",
            stringify!(initOnce)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventHandles) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONDITION_VARIABLE),
            "::",
            stringify!(eventHandles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONDITION_VARIABLE),
            "::",
            stringify!(waitCount)
        )
    );
}
pub type CONDITION_VARIABLE = _CONDITION_VARIABLE;
pub type PCONDITION_VARIABLE = *mut _CONDITION_VARIABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SRWLOCK {
    pub Ptr: DWORD_PTR,
}
#[test]
fn bindgen_test_layout__SRWLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_SRWLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SRWLOCK>(),
        4usize,
        concat!("Size of: ", stringify!(_SRWLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_SRWLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_SRWLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SRWLOCK),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type SRWLOCK = _SRWLOCK;
pub type PSRWLOCK = *mut _SRWLOCK;
pub const _GET_FILEEX_INFO_LEVELS_GetFileExInfoStandard: _GET_FILEEX_INFO_LEVELS = 0;
pub const _GET_FILEEX_INFO_LEVELS_GetFileExMaxInfoLevel: _GET_FILEEX_INFO_LEVELS = 1;
pub type _GET_FILEEX_INFO_LEVELS = libc::c_int;
pub use self::_GET_FILEEX_INFO_LEVELS as GET_FILEEX_INFO_LEVELS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FILE_ATTRIBUTE_DATA {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
}
#[test]
fn bindgen_test_layout__WIN32_FILE_ATTRIBUTE_DATA() {
    const UNINIT: ::core::mem::MaybeUninit<_WIN32_FILE_ATTRIBUTE_DATA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_WIN32_FILE_ATTRIBUTE_DATA>(),
        36usize,
        concat!("Size of: ", stringify!(_WIN32_FILE_ATTRIBUTE_DATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_WIN32_FILE_ATTRIBUTE_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_WIN32_FILE_ATTRIBUTE_DATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwFileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(dwFileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftCreationTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(ftCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftLastAccessTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(ftLastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftLastWriteTime) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(ftLastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nFileSizeHigh) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(nFileSizeHigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nFileSizeLow) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FILE_ATTRIBUTE_DATA),
            "::",
            stringify!(nFileSizeLow)
        )
    );
}
pub type WIN32_FILE_ATTRIBUTE_DATA = _WIN32_FILE_ATTRIBUTE_DATA;
pub type LPWIN32_FILE_ATTRIBUTE_DATA = *mut _WIN32_FILE_ATTRIBUTE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_ATTRIBUTES {
    pub nLength: DWORD,
    pub lpSecurityDescriptor: LPVOID,
    pub bInheritHandle: BOOL,
}
#[test]
fn bindgen_test_layout__SECURITY_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_SECURITY_ATTRIBUTES> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SECURITY_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_SECURITY_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<_SECURITY_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_ATTRIBUTES),
            "::",
            stringify!(nLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lpSecurityDescriptor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_ATTRIBUTES),
            "::",
            stringify!(lpSecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bInheritHandle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_ATTRIBUTES),
            "::",
            stringify!(bInheritHandle)
        )
    );
}
pub type SECURITY_ATTRIBUTES = _SECURITY_ATTRIBUTES;
pub type PSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
pub type LPSECURITY_ATTRIBUTES = *mut _SECURITY_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WIN32_FIND_DATAA {
    pub dwFileAttributes: DWORD,
    pub ftCreationTime: FILETIME,
    pub ftLastAccessTime: FILETIME,
    pub ftLastWriteTime: FILETIME,
    pub nFileSizeHigh: DWORD,
    pub nFileSizeLow: DWORD,
    pub dwReserved0: DWORD,
    pub dwReserved1: DWORD,
    pub cFileName: [CHAR; 260usize],
    pub cAlternateFileName: [CHAR; 14usize],
}
#[test]
fn bindgen_test_layout__WIN32_FIND_DATAA() {
    const UNINIT: ::core::mem::MaybeUninit<_WIN32_FIND_DATAA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_WIN32_FIND_DATAA>(),
        320usize,
        concat!("Size of: ", stringify!(_WIN32_FIND_DATAA))
    );
    assert_eq!(
        ::core::mem::align_of::<_WIN32_FIND_DATAA>(),
        4usize,
        concat!("Alignment of ", stringify!(_WIN32_FIND_DATAA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwFileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(dwFileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftCreationTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(ftCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftLastAccessTime) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(ftLastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ftLastWriteTime) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(ftLastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nFileSizeHigh) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(nFileSizeHigh)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nFileSizeLow) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(nFileSizeLow)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwReserved0) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(dwReserved0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwReserved1) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(dwReserved1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cFileName) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(cFileName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cAlternateFileName) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_WIN32_FIND_DATAA),
            "::",
            stringify!(cAlternateFileName)
        )
    );
}
pub type WIN32_FIND_DATAA = _WIN32_FIND_DATAA;
pub type PWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
pub type LPWIN32_FIND_DATAA = *mut _WIN32_FIND_DATAA;
extern "stdcall" {
    pub fn ZeroMemory(Destination: PVOID, length: SIZE_T);
}
extern "C" {
    pub fn GetLastError() -> DWORD;
}
extern "C" {
    pub fn SetLastError(error: DWORD);
}
extern "stdcall" {
    pub fn OutputDebugStringA(lpOutputString: LPCTSTR);
}
extern "C" {
    pub fn IsBadWritePtr(lp: LPVOID, ucb: UINT_PTR) -> BOOL;
}
extern "C" {
    pub fn RaiseException(
        dwExceptionCode: DWORD,
        dwExceptionFlags: DWORD,
        nNumberOfArguments: DWORD,
        lpArguments: *const ULONG_PTR,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION {
    pub prev: *mut _EXCEPTION_REGISTRATION,
    pub handler: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_REGISTRATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_REGISTRATION>(),
        8usize,
        concat!("Size of: ", stringify!(_EXCEPTION_REGISTRATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_REGISTRATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_REGISTRATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handler) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION),
            "::",
            stringify!(handler)
        )
    );
}
pub type EXCEPTION_REGISTRATION = _EXCEPTION_REGISTRATION;
pub type PEXCEPTION_REGISTRATION = *mut _EXCEPTION_REGISTRATION;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueExecution: _EXCEPTION_DISPOSITION = 0;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueSearch: _EXCEPTION_DISPOSITION = 1;
pub const _EXCEPTION_DISPOSITION_ExceptionNestedException: _EXCEPTION_DISPOSITION = 2;
pub const _EXCEPTION_DISPOSITION_ExceptionCollidedUnwind: _EXCEPTION_DISPOSITION = 3;
pub type _EXCEPTION_DISPOSITION = libc::c_int;
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
extern "C" {
    pub fn FlsAlloc(lpCallback: PFLS_CALLBACK_FUNCTION) -> DWORD;
}
extern "C" {
    pub fn FlsFree(dwFlsIndex: DWORD) -> BOOL;
}
extern "C" {
    pub fn FlsGetValue(dwFlsIndex: DWORD) -> PVOID;
}
extern "C" {
    pub fn FlsSetValue(dwFlsIndex: DWORD, lpFlsData: PVOID) -> BOOL;
}
extern "C" {
    pub fn GetFileAttributesA(lpFileName: LPCSTR) -> DWORD;
}
extern "C" {
    pub fn GetFileAttributesExA(
        lpFileName: LPCSTR,
        fInfoLevelId: GET_FILEEX_INFO_LEVELS,
        lpFileInformation: LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileAttributesA(lpFileName: LPCSTR, dwFileAttributes: DWORD) -> BOOL;
}
extern "C" {
    pub fn GetFileTime(
        hFile: HANDLE,
        lpCreationTime: LPFILETIME,
        lpLastAccessTime: LPFILETIME,
        lpLastWriteTime: LPFILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn SetFileTime(
        hFile: HANDLE,
        lpCreationTime: *const FILETIME,
        lpLastAccessTime: *const FILETIME,
        lpLastWriteTime: *const FILETIME,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateFileA(
        lpFileName: LPCSTR,
        dwDesiredAccess: DWORD,
        dwShareMode: DWORD,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
        dwCreationDisposition: DWORD,
        dwFlagsAndAttributes: DWORD,
        hTemplateFile: HANDLE,
    ) -> HANDLE;
}
extern "C" {
    pub fn ReadFile(
        hFile: HANDLE,
        lpBuffer: LPVOID,
        nNumberOfBytesToRead: DWORD,
        lpNumberOfBytesRead: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn WriteFile(
        hFile: HANDLE,
        lpBuffer: LPCVOID,
        nNumberOfBytesToWrite: DWORD,
        lpNumberOfBytesWritten: LPDWORD,
        lpOverlapped: LPOVERLAPPED,
    ) -> BOOL;
}
extern "C" {
    pub fn SetEndOfFile(hFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn SetFilePointer(
        hFile: HANDLE,
        lDistanceToMove: LONG,
        lpDistanceToMoveHigh: PLONG,
        dwMoveMethod: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn SetFilePointerEx(
        hFile: HANDLE,
        liDistanceToMove: LARGE_INTEGER,
        lpNewFilePointer: PLARGE_INTEGER,
        dwMoveMethod: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetFileSize(hFile: HANDLE, lpFileSizeHigh: LPDWORD) -> DWORD;
}
extern "C" {
    pub fn GetFileSizeEx(hFile: HANDLE, lpFileSize: PLARGE_INTEGER) -> BOOL;
}
extern "C" {
    pub fn FindFirstFileA(lpFileName: LPCSTR, lpFindFileData: LPWIN32_FIND_DATAA) -> HANDLE;
}
extern "C" {
    pub fn FindNextFileA(hFindFile: HANDLE, lpFindFileData: LPWIN32_FIND_DATAA) -> BOOL;
}
extern "C" {
    pub fn FindClose(hFindFile: HANDLE) -> BOOL;
}
extern "C" {
    pub fn DeleteFileA(lpFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn RemoveDirectoryA(lpPathName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn CreateDirectoryA(
        lpPathName: LPCSTR,
        lpSecurityAttributes: LPSECURITY_ATTRIBUTES,
    ) -> BOOL;
}
extern "C" {
    pub fn MoveFileA(lpExistingFileName: LPCSTR, lpNewFileName: LPCSTR) -> BOOL;
}
extern "C" {
    pub fn CopyFileA(
        lpExistingFileName: LPCSTR,
        lpNewFileName: LPCSTR,
        bFailIfExists: BOOL,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceExA(
        lpDirectoryName: LPCSTR,
        lpFreeBytesAvailableToCaller: PULARGE_INTEGER,
        lpTotalNumberOfBytes: PULARGE_INTEGER,
        lpTotalNumberOfFreeBytes: PULARGE_INTEGER,
    ) -> BOOL;
}
extern "C" {
    pub fn GetDiskFreeSpaceA(
        lpRootPathName: LPCSTR,
        lpSectorsPerCluster: LPDWORD,
        lpBytesPerSector: LPDWORD,
        lpNumberOfFreeClusters: LPDWORD,
        lpTotalNumberOfClusters: LPDWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn GetLogicalDrives() -> DWORD;
}
extern "C" {
    pub fn GetLogicalDriveStringsA(nBufferLength: DWORD, lpBuffer: LPSTR) -> DWORD;
}
extern "C" {
    pub fn CloseHandle(hObject: HANDLE) -> BOOL;
}
extern "C" {
    pub fn LoadLibraryExA(lpLibFileName: LPCSTR, hFile: HANDLE, dwFlags: DWORD) -> HMODULE;
}
extern "C" {
    pub fn LoadLibraryA(lpLibFileName: LPCSTR) -> HMODULE;
}
extern "C" {
    pub fn FreeLibrary(hLibModule: HMODULE) -> BOOL;
}
extern "C" {
    pub fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> FARPROC;
}
pub type PHYSICAL_ADDRESS = ULONG;
pub type PPHYSICAL_ADDRESS = *mut ULONG;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut UCHAR;
pub type PFN_COUNT = ULONG;
pub type PFN_NUMBER = ULONG;
pub type PPFN_NUMBER = *mut ULONG;
pub type KPRIORITY = LONG;
pub type DEVICE_TYPE = ULONG;
pub type LOGICAL = ULONG;
pub type PSZ = *mut libc::c_char;
pub type PSTR = *mut libc::c_char;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ULONG;
pub type KPROCESSOR_MODE = CCHAR;
pub const _MODE_KernelMode: _MODE = 0;
pub const _MODE_UserMode: _MODE = 1;
pub const _MODE_MaximumMode: _MODE = 2;
pub type _MODE = libc::c_int;
pub use self::_MODE as MODE;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type OBJECT_STRING = STRING;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type POBJECT_STRING = *mut STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    #[doc = "< Length in bytes of the string stored in the buffer"]
    pub Length: USHORT,
    #[doc = "< Length in bytes of the buffer"]
    pub MaximumLength: USHORT,
    #[doc = "< Pointer to the buffer used for the character-string"]
    pub Buffer: PWSTR,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_UNICODE_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_UNICODE_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type UNICODE_STRING = _UNICODE_STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type PUNICODE_STRING = *mut _UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[doc = " Time information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_FIELDS {
    #[doc = "< Specifies a value from 1601 on"]
    pub Year: SHORT,
    #[doc = "< Specifies a value from 1 to 12"]
    pub Month: SHORT,
    #[doc = "< Specifies a value from 1 to 31"]
    pub Day: SHORT,
    #[doc = "< Specifies a value from 0 to 23"]
    pub Hour: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Minute: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Second: SHORT,
    #[doc = "< Specifies a value from 0 to 999"]
    pub Millisecond: SHORT,
    #[doc = "< Specifies a value from 0 to 6 (Sunday to Saturday)"]
    pub Weekday: SHORT,
}
#[test]
fn bindgen_test_layout__TIME_FIELDS() {
    const UNINIT: ::core::mem::MaybeUninit<_TIME_FIELDS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIME_FIELDS>(),
        16usize,
        concat!("Size of: ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIME_FIELDS>(),
        2usize,
        concat!("Alignment of ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Day) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hour) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Second) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Millisecond) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Millisecond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Weekday) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Weekday)
        )
    );
}
#[doc = " Time information"]
pub type TIME_FIELDS = _TIME_FIELDS;
#[doc = " Time information"]
pub type PTIME_FIELDS = *mut _TIME_FIELDS;
pub const _WAIT_TYPE_WaitAll: _WAIT_TYPE = 0;
pub const _WAIT_TYPE_WaitAny: _WAIT_TYPE = 1;
pub type _WAIT_TYPE = libc::c_int;
pub use self::_WAIT_TYPE as WAIT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 9;
pub type _FSINFOCLASS = libc::c_int;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_LABEL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_LABEL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_LABEL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_LABEL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_VOLUME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_VOLUME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_VOLUME_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_VOLUME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SupportsObjects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(SupportsObjects)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_SIZE_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailableAllocationUnits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(AvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_FULL_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_FULL_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CallerAvailableAllocationUnits) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(CallerAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ActualAvailableAllocationUnits) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(ActualAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: DEVICE_TYPE,
    pub Characteristics: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_DEVICE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_DEVICE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_DEVICE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_DEVICE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: ULONG,
    pub MaximumComponentNameLength: LONG,
    pub FileSystemNameLength: ULONG,
    pub FileSystemName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_ATTRIBUTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_ATTRIBUTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumComponentNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(MaximumComponentNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemName)
        )
    );
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
        28usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    const UNINIT: ::core::mem::MaybeUninit<_SID_IDENTIFIER_AUTHORITY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    #[doc = "< Actually has size 'SubAuthorityCount'"]
    pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    const UNINIT: ::core::mem::MaybeUninit<_SID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthorityCount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdentifierAuthority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthority)
        )
    );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 37;
pub type _FILE_INFORMATION_CLASS = libc::c_int;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DIRECTORY_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DIRECTORY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_DIR_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_BOTH_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BOTH_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BOTH_DIR_INFORMATION>(),
        96usize,
        concat!("Size of: ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BOTH_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortNameLength) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STANDARD_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Directory) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory)
        )
    );
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
    pub IndexNumber: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_INTERNAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_INTERNAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_INTERNAL_INFORMATION),
            "::",
            stringify!(IndexNumber)
        )
    );
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
    pub EaSize: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_EA_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
    pub AccessFlags: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__FILE_ACCESS_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ACCESS_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ACCESS_INFORMATION),
            "::",
            stringify!(AccessFlags)
        )
    );
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAME_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileName: OBJECT_STRING,
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_RENAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_RENAME_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_RENAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_LINK_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_LINK_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_LINK_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_LINK_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAMES_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAMES_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAMES_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAMES_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DISPOSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DISPOSITION_INFORMATION),
            "::",
            stringify!(DeleteFile)
        )
    );
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_POSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_POSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_POSITION_INFORMATION),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
        )
    );
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
    pub Mode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_MODE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MODE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MODE_INFORMATION),
            "::",
            stringify!(Mode)
        )
    );
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALIGNMENT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALIGNMENT_INFORMATION),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
#[test]
fn bindgen_test_layout__FILE_ALL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALL_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasicInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(BasicInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardInformation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(StandardInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InternalInformation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(InternalInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaInformation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(EaInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessInformation) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AccessInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PositionInformation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(PositionInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ModeInformation) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(ModeInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentInformation) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AlignmentInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NameInformation) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(NameInformation)
        )
    );
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_ALLOCATION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALLOCATION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALLOCATION_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_END_OF_FILE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_END_OF_FILE_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub StreamNameLength: ULONG,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_STREAM_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STREAM_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STREAM_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STREAM_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamName)
        )
    );
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(ReadMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(CompletionMode)
        )
    );
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: ULONG,
    pub NamedPipeConfiguration: ULONG,
    pub MaximumInstances: ULONG,
    pub CurrentInstances: ULONG,
    pub InboundQuota: ULONG,
    pub ReadDataAvailable: ULONG,
    pub OutboundQuota: ULONG,
    pub WriteQuotaAvailable: ULONG,
    pub NamedPipeState: ULONG,
    pub NamedPipeEnd: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_LOCAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_LOCAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeConfiguration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeConfiguration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumInstances) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(MaximumInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentInstances) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(CurrentInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InboundQuota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(InboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadDataAvailable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(ReadDataAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutboundQuota) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(OutboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriteQuotaAvailable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(WriteQuotaAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeEnd) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeEnd)
        )
    );
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
    pub CollectDataTime: LARGE_INTEGER,
    pub MaximumCollectionCount: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_REMOTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_REMOTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CollectDataTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(CollectDataTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCollectionCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(MaximumCollectionCount)
        )
    );
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: ULONG,
    pub MailslotQuota: ULONG,
    pub NextMessageSize: ULONG,
    pub MessagesAvailable: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_QUERY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_QUERY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_QUERY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumMessageSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MaximumMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MailslotQuota) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MailslotQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextMessageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(NextMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MessagesAvailable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MessagesAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: PLARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_SET_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_SET_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_SET_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: USHORT,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
#[test]
fn bindgen_test_layout__FILE_COMPRESSION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPRESSION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPRESSION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPRESSION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressedFileSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressedFileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionUnitShift) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionUnitShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChunkShift) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ChunkShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ClusterShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
    pub FileReference: LONGLONG,
    pub ObjectId: [UCHAR; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [UCHAR; 16usize],
    pub BirthObjectId: [UCHAR; 16usize],
    pub DomainId: [UCHAR; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthVolumeId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthVolumeId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthObjectId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DomainId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DomainId)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
    pub Port: HANDLE,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_COMPLETION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPLETION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPLETION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPLETION_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Key)
        )
    );
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
    pub ClusterCount: ULONG,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_MOVE_CLUSTER_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MOVE_CLUSTER_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(ClusterCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub ChangeTime: LARGE_INTEGER,
    pub QuotaUsed: LARGE_INTEGER,
    pub QuotaThreshold: LARGE_INTEGER,
    pub QuotaLimit: LARGE_INTEGER,
    pub Sid: SID,
}
#[test]
fn bindgen_test_layout__FILE_QUOTA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_QUOTA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_QUOTA_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_QUOTA_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaUsed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaUsed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
    pub FileReference: LONGLONG,
    pub Tag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_REPARSE_POINT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_REPARSE_POINT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(Tag)
        )
    );
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NETWORK_OPEN_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ATTRIBUTE_TAG_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(ReparseTag)
        )
    );
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
    pub DestinationFile: HANDLE,
    pub ObjectInformationLength: ULONG,
    pub ObjectInformation: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_TRACKING_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_TRACKING_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_TRACKING_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_TRACKING_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DestinationFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(DestinationFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformationLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformationLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformation)
        )
    );
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[doc = " Object Attributes Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    #[doc = "< Optional handle to the root object directory for the path name specified by the ObjectName member. If RootDirectory is NULL, ObjectName must point to a fully qualified object name that includes the full path to the target object. If RootDirectory is non-NULL, ObjectName specifies an object name relative to the RootDirectory directory."]
    pub RootDirectory: HANDLE,
    #[doc = "< Pointer to an ANSI string that contains the name of the object for which a handle is to be opened. This must either be a fully qualified object name, or a relative path name to the directory specified by the RootDirectory member."]
    pub ObjectName: PANSI_STRING,
    #[doc = "< Bitmask of flags that specify object handle attributes."]
    pub Attributes: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_ATTRIBUTES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(ObjectName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
#[doc = " Object Attributes Structure"]
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
#[doc = " Object Attributes Structure"]
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
pub const _EVENT_TYPE_NotificationEvent: _EVENT_TYPE = 0;
pub const _EVENT_TYPE_SynchronizationEvent: _EVENT_TYPE = 1;
pub type _EVENT_TYPE = libc::c_int;
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[doc = " Memory manager statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_STATISTICS {
    #[doc = "< Length of MM_STATISTICS in bytes"]
    pub Length: ULONG,
    pub TotalPhysicalPages: ULONG,
    pub AvailablePages: ULONG,
    pub VirtualMemoryBytesCommitted: ULONG,
    pub VirtualMemoryBytesReserved: ULONG,
    pub CachePagesCommitted: ULONG,
    pub PoolPagesCommitted: ULONG,
    pub StackPagesCommitted: ULONG,
    pub ImagePagesCommitted: ULONG,
}
#[test]
fn bindgen_test_layout__MM_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_MM_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MM_STATISTICS>(),
        36usize,
        concat!("Size of: ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_MM_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalPhysicalPages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(TotalPhysicalPages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesCommitted) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesReserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesReserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CachePagesCommitted) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(CachePagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolPagesCommitted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(PoolPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackPagesCommitted) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(StackPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ImagePagesCommitted) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(ImagePagesCommitted)
        )
    );
}
#[doc = " Memory manager statistics"]
pub type MM_STATISTICS = _MM_STATISTICS;
#[doc = " Memory manager statistics"]
pub type PMM_STATISTICS = *mut _MM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_HEADER {
    pub dwLaunchDataType: DWORD,
    pub dwTitleId: DWORD,
    pub szLaunchPath: [CHAR; 520usize],
    pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_HEADER>(),
        532usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwLaunchDataType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwLaunchDataType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwTitleId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwTitleId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).szLaunchPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(szLaunchPath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwFlags)
        )
    );
}
pub type LAUNCH_DATA_HEADER = _LAUNCH_DATA_HEADER;
pub type PLAUNCH_DATA_HEADER = *mut _LAUNCH_DATA_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_PAGE {
    pub Header: LAUNCH_DATA_HEADER,
    pub Pad: [UCHAR; 492usize],
    pub LaunchData: [UCHAR; 3072usize],
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_PAGE() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_PAGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_PAGE>(),
        4096usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_PAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pad) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LaunchData) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(LaunchData)
        )
    );
}
pub type LAUNCH_DATA_PAGE = _LAUNCH_DATA_PAGE;
pub type PLAUNCH_DATA_PAGE = *mut _LAUNCH_DATA_PAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_DISPATCHER_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(WaitListHead)
        )
    );
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC {
    pub Type: CSHORT,
    pub Inserted: BOOLEAN,
    pub Padding: UCHAR,
    pub DpcListEntry: LIST_ENTRY,
    pub DeferredRoutine: PVOID,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KDPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC>(),
        28usize,
        concat!("Size of: ", stringify!(_KDPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcListEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DpcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: PKDPC,
    pub Period: LONG,
}
#[test]
fn bindgen_test_layout__KTIMER() {
    const UNINIT: ::core::mem::MaybeUninit<_KTIMER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTIMER>(),
        40usize,
        concat!("Size of: ", stringify!(_KTIMER))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTIMER>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTIMER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(DueTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerListEntry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(TimerListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dpc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Dpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Period) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Period)
        )
    );
}
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type KTIMER = _KTIMER;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type PKTIMER = *mut _KTIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    pub ReadListHead: LIST_ENTRY,
    pub ThreadListHead: LIST_ENTRY,
    pub StackCount: ULONG,
    pub ThreadQuantum: LONG,
    pub BasePriority: SCHAR,
    pub DisableBoost: UCHAR,
    pub DisableQuantum: UCHAR,
}
#[test]
fn bindgen_test_layout__KPROCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_KPROCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KPROCESS>(),
        28usize,
        concat!("Size of: ", stringify!(_KPROCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_KPROCESS>(),
        4usize,
        concat!("Alignment of ", stringify!(_KPROCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ReadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadQuantum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadQuantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableQuantum) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableQuantum)
        )
    );
}
pub type KPROCESS = _KPROCESS;
pub type PKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: PKPROCESS,
    pub KernelApcInProgress: UCHAR,
    pub KernelApcPending: UCHAR,
    pub UserApcPending: UCHAR,
    pub ApcQueueable: UCHAR,
}
#[test]
fn bindgen_test_layout__KAPC_STATE() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC_STATE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE>(),
        24usize,
        concat!("Size of: ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(Process)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcInProgress) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcInProgress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcPending) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcPending) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(UserApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcQueueable) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcQueueable)
        )
    );
}
pub type KAPC_STATE = _KAPC_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KQUEUE {
    pub Header: DISPATCHER_HEADER,
    pub EntryListHead: LIST_ENTRY,
    pub CurrentCount: ULONG,
    pub MaximumCount: ULONG,
    pub ThreadListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KQUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KQUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KQUEUE>(),
        40usize,
        concat!("Size of: ", stringify!(_KQUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KQUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KQUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EntryListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(EntryListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(MaximumCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(ThreadListHead)
        )
    );
}
pub type KQUEUE = _KQUEUE;
pub type PKQUEUE = *mut _KQUEUE;
pub type PRKQUEUE = *mut _KQUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub Thread: *mut _KTHREAD,
    pub Object: PVOID,
    pub NextWaitBlock: *mut _KWAIT_BLOCK,
    pub WaitKey: SHORT,
    pub WaitType: SHORT,
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_KWAIT_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KWAIT_BLOCK>(),
        24usize,
        concat!("Size of: ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_KWAIT_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Object) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextWaitBlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(NextWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitKey) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitType) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitType)
        )
    );
}
pub type KWAIT_BLOCK = _KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: SHORT,
    pub ApcMode: CHAR,
    pub Inserted: UCHAR,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub KernelRoutine: PVOID,
    pub RundownRoutine: PVOID,
    pub NormalRoutine: PVOID,
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KAPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC>(),
        40usize,
        concat!("Size of: ", stringify!(_KAPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcMode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(KernelRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RundownRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(RundownRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalRoutine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalContext) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KAPC = _KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
#[test]
fn bindgen_test_layout__KSEMAPHORE() {
    const UNINIT: ::core::mem::MaybeUninit<_KSEMAPHORE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSEMAPHORE>(),
        20usize,
        concat!("Size of: ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSEMAPHORE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Limit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Limit)
        )
    );
}
pub type KSEMAPHORE = _KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD {
    pub Header: DISPATCHER_HEADER,
    pub MutantListHead: LIST_ENTRY,
    pub KernelTime: ULONG,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub KernelStack: PVOID,
    pub TlsData: PVOID,
    pub State: UCHAR,
    pub Alerted: [UCHAR; 2usize],
    pub Alertable: UCHAR,
    pub NpxState: UCHAR,
    pub Saturation: CHAR,
    pub Priority: SCHAR,
    pub Padding: UCHAR,
    pub ApcState: KAPC_STATE,
    pub ContextSwitches: ULONG,
    pub WaitStatus: LONG,
    pub WaitIrql: UCHAR,
    pub WaitMode: CHAR,
    pub WaitNext: UCHAR,
    pub WaitReason: UCHAR,
    pub WaitBlockList: PKWAIT_BLOCK,
    pub WaitListEntry: LIST_ENTRY,
    pub WaitTime: ULONG,
    pub KernelApcDisable: ULONG,
    pub Quantum: LONG,
    pub BasePriority: SCHAR,
    pub DecrementCount: UCHAR,
    pub PriorityDecrement: SCHAR,
    pub DisableBoost: UCHAR,
    pub NpxIrql: UCHAR,
    pub SuspendCount: CHAR,
    pub Preempted: UCHAR,
    pub HasTerminated: UCHAR,
    pub Queue: PKQUEUE,
    pub QueueListEntry: LIST_ENTRY,
    pub Timer: KTIMER,
    pub TimerWaitBlock: KWAIT_BLOCK,
    pub SuspendApc: KAPC,
    pub SuspendSemaphore: KSEMAPHORE,
    pub ThreadListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KTHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_KTHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTHREAD>(),
        272usize,
        concat!("Size of: ", stringify!(_KTHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(MutantListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelStack) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TlsData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TlsData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alerted) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alerted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alertable) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alertable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxState) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Saturation) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Saturation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcState) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ApcState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextSwitches) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ContextSwitches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitStatus) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitIrql) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitMode) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitNext) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitNext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitReason) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitReason)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitBlockList) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitBlockList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitTime) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcDisable) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelApcDisable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Quantum) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Quantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DecrementCount) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DecrementCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PriorityDecrement) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(PriorityDecrement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxIrql) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendCount) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Preempted) as usize - ptr as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Preempted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HasTerminated) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(HasTerminated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Queue) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueListEntry) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(QueueListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerWaitBlock) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TimerWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendApc) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendApc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendSemaphore) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendSemaphore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ThreadListEntry)
        )
    );
}
pub type KTHREAD = _KTHREAD;
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
pub const _TIMER_TYPE_NotificationTimer: _TIMER_TYPE = 0;
pub const _TIMER_TYPE_SynchronizationTimer: _TIMER_TYPE = 1;
pub type _TIMER_TYPE = libc::c_int;
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    pub ServiceRoutine: PVOID,
    pub ServiceContext: PVOID,
    pub BusInterruptLevel: ULONG,
    pub Irql: ULONG,
    pub Connected: UCHAR,
    pub ShareVector: UCHAR,
    pub Mode: UCHAR,
    pub Padding7: UCHAR,
    pub ServiceCount: ULONG,
    pub DispatchCode: [ULONG; 22usize],
}
#[test]
fn bindgen_test_layout__KINTERRUPT() {
    const UNINIT: ::core::mem::MaybeUninit<_KINTERRUPT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KINTERRUPT>(),
        112usize,
        concat!("Size of: ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KINTERRUPT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusInterruptLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(BusInterruptLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irql) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Irql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Connected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareVector) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ShareVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding7) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Padding7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DispatchCode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(DispatchCode)
        )
    );
}
pub type KINTERRUPT = _KINTERRUPT;
pub type PKINTERRUPT = *mut _KINTERRUPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
#[test]
fn bindgen_test_layout__KSYSTEM_TIME() {
    const UNINIT: ::core::mem::MaybeUninit<_KSYSTEM_TIME> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSYSTEM_TIME>(),
        12usize,
        concat!("Size of: ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSYSTEM_TIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High1Time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High1Time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High2Time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High2Time)
        )
    );
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub const _FIRMWARE_REENTRY_HalHaltRoutine: _FIRMWARE_REENTRY = 0;
pub const _FIRMWARE_REENTRY_HalRebootRoutine: _FIRMWARE_REENTRY = 1;
pub const _FIRMWARE_REENTRY_HalQuickRebootRoutine: _FIRMWARE_REENTRY = 2;
pub const _FIRMWARE_REENTRY_HalKdRebootRoutine: _FIRMWARE_REENTRY = 3;
pub const _FIRMWARE_REENTRY_HalFatalErrorRebootRoutine: _FIRMWARE_REENTRY = 4;
pub const _FIRMWARE_REENTRY_HalMaximumRoutine: _FIRMWARE_REENTRY = 5;
pub type _FIRMWARE_REENTRY = libc::c_int;
pub use self::_FIRMWARE_REENTRY as FIRMWARE_REENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE {
    pub AllocateProcedure: PVOID,
    pub FreeProcedure: PVOID,
    pub CloseProcedure: PVOID,
    pub DeleteProcedure: PVOID,
    pub ParseProcedure: PVOID,
    pub DefaultObject: PVOID,
    pub PoolTag: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_TYPE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_TYPE>(),
        28usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_TYPE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocateProcedure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(AllocateProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeProcedure) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(FreeProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CloseProcedure) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(CloseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteProcedure) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DeleteProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ParseProcedure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(ParseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DefaultObject) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DefaultObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(PoolTag)
        )
    );
}
pub type OBJECT_TYPE = _OBJECT_TYPE;
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER {
    pub PointerCount: LONG,
    pub HandleCount: LONG,
    pub Type: POBJECT_TYPE,
    pub Flags: ULONG,
    pub Body: QUAD,
}
#[test]
fn bindgen_test_layout__OBJECT_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(PointerCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Body) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Body)
        )
    );
}
pub type OBJECT_HEADER = _OBJECT_HEADER;
pub type POBJECT_HEADER = *mut _OBJECT_HEADER;
pub type PKDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Dpc: PKDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: SHORT,
    pub Size: UCHAR,
    pub Busy: UCHAR,
    pub DeviceListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE>(),
        12usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Busy) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Busy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListHead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(DeviceListHead)
        )
    );
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PKSTART_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(StartContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: PVOID,
    pub Alignment: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_SEGMENT_ELEMENT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEMAPHORE_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub MaximumCount: LONG,
}
#[test]
fn bindgen_test_layout__SEMAPHORE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_SEMAPHORE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(MaximumCount)
        )
    );
}
pub type SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
pub type PSEMAPHORE_BASIC_INFORMATION = *mut _SEMAPHORE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUTANT_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub OwnedByCaller: UCHAR,
    pub AbandonedState: UCHAR,
}
#[test]
fn bindgen_test_layout__MUTANT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MUTANT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MUTANT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MUTANT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnedByCaller) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(OwnedByCaller)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AbandonedState) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(AbandonedState)
        )
    );
}
pub type MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
pub type PMUTANT_BASIC_INFORMATION = *mut _MUTANT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_BASIC_INFORMATION {
    pub Depth: LONG,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION),
            "::",
            stringify!(Depth)
        )
    );
}
pub type IO_COMPLETION_BASIC_INFORMATION = _IO_COMPLETION_BASIC_INFORMATION;
pub type PIO_COMPLETION_BASIC_INFORMATION = *mut _IO_COMPLETION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_BASIC_INFORMATION {
    pub EventType: EVENT_TYPE,
    pub EventState: LONG,
}
#[test]
fn bindgen_test_layout__EVENT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_EVENT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EVENT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_EVENT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventState)
        )
    );
}
pub type EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
pub type PEVENT_BASIC_INFORMATION = *mut _EVENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_STATISTICS {
    pub Length: ULONG,
    pub ThreadCount: ULONG,
    pub HandleCount: ULONG,
}
#[test]
fn bindgen_test_layout__PS_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_PS_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PS_STATISTICS>(),
        12usize,
        concat!("Size of: ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_PS_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(ThreadCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(HandleCount)
        )
    );
}
pub type PS_STATISTICS = _PS_STATISTICS;
pub type PPS_STATISTICS = *mut _PS_STATISTICS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETHREAD {
    pub Tcb: KTHREAD,
    pub CreateTime: LARGE_INTEGER,
    pub ExitTime: LARGE_INTEGER,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_1,
    pub __bindgen_anon_2: _ETHREAD__bindgen_ty_2,
    pub UniqueThread: HANDLE,
    pub StartAddress: PVOID,
    pub IrpList: LIST_ENTRY,
    pub DebugData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_1 {
    pub ExitStatus: NTSTATUS,
    pub OfsChain: PVOID,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(ExitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OfsChain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(OfsChain)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_2 {
    pub ReaperListEntry: LIST_ENTRY,
    pub ActiveTimerListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaperListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ReaperListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ActiveTimerListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ActiveTimerListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__ETHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD>(),
        320usize,
        concat!("Size of: ", stringify!(_ETHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_ETHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(Tcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitTime) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(ExitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UniqueThread) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(UniqueThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartAddress) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(StartAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpList) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(IrpList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DebugData) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(DebugData)
        )
    );
}
pub type ETHREAD = _ETHREAD;
pub type PETHREAD = *mut _ETHREAD;
pub type PCREATE_THREAD_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Thread: PETHREAD, ThreadId: HANDLE, Create: BOOLEAN),
>;
#[doc = "< Interrupt is level-triggered. Used for traditional PCI line-based interrupts."]
pub const _KINTERRUPT_MODE_LevelSensitive: _KINTERRUPT_MODE = 0;
#[doc = "< Interrupt is edge-triggered. Used for PCI message-signaled interrupts"]
pub const _KINTERRUPT_MODE_Latched: _KINTERRUPT_MODE = 1;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub type _KINTERRUPT_MODE = libc::c_int;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub type PKSERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Interrupt: PKINTERRUPT, ServiceContext: PVOID) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_BASIC_INFORMATION {
    pub RemainingTime: LARGE_INTEGER,
    pub TimerState: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TIMER_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_TIMER_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIMER_BASIC_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIMER_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemainingTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(RemainingTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(TimerState)
        )
    );
}
pub type TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
pub type PTIMER_BASIC_INFORMATION = *mut _TIMER_BASIC_INFORMATION;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_KRNL_VERSION {
    pub Major: USHORT,
    pub Minor: USHORT,
    pub Build: USHORT,
    pub Qfe: USHORT,
}
#[test]
fn bindgen_test_layout__XBOX_KRNL_VERSION() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_KRNL_VERSION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_KRNL_VERSION>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_KRNL_VERSION>(),
        2usize,
        concat!("Alignment of ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Build) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Build)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Qfe) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Qfe)
        )
    );
}
pub type XBOX_KRNL_VERSION = _XBOX_KRNL_VERSION;
pub type PXBOX_KRNL_VERSION = *mut _XBOX_KRNL_VERSION;
#[doc = " Information about the XBOX-hardware"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_HARDWARE_INFO {
    pub Flags: ULONG,
    pub GpuRevision: UCHAR,
    pub McpRevision: UCHAR,
    pub reserved: [UCHAR; 2usize],
}
#[test]
fn bindgen_test_layout__XBOX_HARDWARE_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_HARDWARE_INFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_HARDWARE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_HARDWARE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GpuRevision) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(GpuRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).McpRevision) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(McpRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Information about the XBOX-hardware"]
pub type XBOX_HARDWARE_INFO = _XBOX_HARDWARE_INFO;
pub type XBOX_KEY_DATA = [UCHAR; 16usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    const UNINIT: ::core::mem::MaybeUninit<_GENERIC_MAPPING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::core::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut _GENERIC_MAPPING;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    #[doc = "< Pointer to the next (or first, if this is a header) entry in the singly linked list (NULL if there is none)"]
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_SINGLE_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Next: SINGLE_LIST_ENTRY,
    pub Depth: USHORT,
    pub Sequence: USHORT,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sequence) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Sequence)
        )
    );
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(Alignment)
        )
    );
}
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type SLIST_HEADER = _SLIST_HEADER;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    const UNINIT: ::core::mem::MaybeUninit<_KEVENT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KEVENT>(),
        16usize,
        concat!("Size of: ", stringify!(_KEVENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KEVENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEVENT),
            "::",
            stringify!(Header)
        )
    );
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE_ENTRY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(DeviceListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SortKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(SortKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(Inserted)
        )
    );
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_CONTEXT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_CONTEXT>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Key)
        )
    );
}
pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Flags: UCHAR,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub FinalStatus: NTSTATUS,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub LockCount: LONG,
    pub Lock: KEVENT,
    pub Event: KEVENT,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECT>(),
        80usize,
        concat!("Size of: ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinalStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FinalStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RelatedFileObject) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(RelatedFileObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionContext) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CompletionContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Event)
        )
    );
}
impl _FILE_OBJECT {
    #[inline]
    pub fn DeletePending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeletePending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeleteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedRead(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedRead(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedWrite(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedWrite(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedDelete(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedDelete(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeletePending: BOOLEAN,
        ReadAccess: BOOLEAN,
        WriteAccess: BOOLEAN,
        DeleteAccess: BOOLEAN,
        SharedRead: BOOLEAN,
        SharedWrite: BOOLEAN,
        SharedDelete: BOOLEAN,
        Reserved: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeletePending: u8 = unsafe { ::core::mem::transmute(DeletePending) };
            DeletePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadAccess: u8 = unsafe { ::core::mem::transmute(ReadAccess) };
            ReadAccess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WriteAccess: u8 = unsafe { ::core::mem::transmute(WriteAccess) };
            WriteAccess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeleteAccess: u8 = unsafe { ::core::mem::transmute(DeleteAccess) };
            DeleteAccess as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SharedRead: u8 = unsafe { ::core::mem::transmute(SharedRead) };
            SharedRead as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SharedWrite: u8 = unsafe { ::core::mem::transmute(SharedWrite) };
            SharedWrite as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SharedDelete: u8 = unsafe { ::core::mem::transmute(SharedDelete) };
            SharedDelete as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FILE_OBJECT = _FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[doc = " This struct represents an I/O request packet"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    #[doc = "< Flags for the packet"]
    pub Flags: ULONG,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub PendingReturned: BOOLEAN,
    #[doc = "< Has the packet been canceled?"]
    pub Cancel: BOOLEAN,
    pub UserIosb: PIO_STATUS_BLOCK,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_1,
    pub UserBuffer: PVOID,
    pub SegmentArray: PFILE_SEGMENT_ELEMENT,
    pub LockedBufferLength: ULONG,
    pub Tail: _IRP__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub AsynchronousParameters: _IRP__bindgen_ty_1__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub UserApcContext: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchronousParameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AsynchronousParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub Overlay: _IRP__bindgen_ty_2__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub __bindgen_anon_2: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 5usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DriverContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueueEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DeviceQueueEntry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STATUS_LOCATION,
    pub PacketType: ULONG,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentStackLocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(CurrentStackLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PacketType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PacketType)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OriginalFileObject) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(OriginalFileObject)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Apc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Apc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(CompletionKey)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP>(),
        104usize,
        concat!("Size of: ", stringify!(_IRP))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(ThreadListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(IoStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentLocation) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(CurrentLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PendingReturned) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(PendingReturned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cancel) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Cancel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserIosb) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserIosb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserEvent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserBuffer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegmentArray) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(SegmentArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockedBufferLength) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(LockedBufferLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tail) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Tail)
        )
    );
}
#[doc = " This struct represents an I/O request packet"]
pub type IRP = _IRP;
#[doc = " This struct represents an I/O request packet"]
pub type PIRP = *mut _IRP;
pub type PDRIVER_STARTIO = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP),
>;
pub type PDRIVER_DELETEDEVICE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT)>;
pub type PDRIVER_DISMOUNTVOLUME = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverDeleteDevice: PDRIVER_DELETEDEVICE,
    pub DriverDismountVolume: PDRIVER_DISMOUNTVOLUME,
    pub MajorFunction: [PDRIVER_DISPATCH; 14usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DRIVER_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_OBJECT>(),
        68usize,
        concat!("Size of: ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverStartIo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStartIo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDeleteDevice) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDeleteDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDismountVolume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDismountVolume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(MajorFunction)
        )
    );
}
pub type DRIVER_OBJECT = _DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: PDRIVER_OBJECT,
    pub MountedOrSelfDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: PIRP,
    pub Flags: ULONG,
    pub DeviceExtension: PVOID,
    pub DeviceType: UCHAR,
    pub StartIoFlags: UCHAR,
    pub StackSize: CCHAR,
    pub DeletePending: BOOLEAN,
    pub SectorSize: ULONG,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub DeviceLock: KEVENT,
    pub StartIoKey: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT>(),
        72usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReferenceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DriverObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MountedOrSelfDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(MountedOrSelfDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceExtension) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceExtension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoFlags) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackSize) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StackSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceLock) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoKey) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoKey)
        )
    );
}
pub type DEVICE_OBJECT = _DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DIRECTORY_INFORMATION {
    pub Name: OBJECT_STRING,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
pub type POBJECT_DIRECTORY_INFORMATION = *mut _OBJECT_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERWLOCK {
    pub LockCount: LONG,
    pub WritersWaitingCount: ULONG,
    pub ReadersWaitingCount: ULONG,
    pub ReadersEntryCount: ULONG,
    pub WriterEvent: KEVENT,
    pub ReaderSemaphore: KSEMAPHORE,
}
#[test]
fn bindgen_test_layout__ERWLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_ERWLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERWLOCK>(),
        52usize,
        concat!("Size of: ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERWLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WritersWaitingCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WritersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersWaitingCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersEntryCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersEntryCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriterEvent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WriterEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaderSemaphore) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReaderSemaphore)
        )
    );
}
pub type ERWLOCK = _ERWLOCK;
pub type PERWLOCK = *mut _ERWLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XBOX_REFURB_INFO {
    pub Signature: ULONG,
    pub PowerCycleCount: ULONG,
    pub FirstSetTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__XBOX_REFURB_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_REFURB_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_REFURB_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_REFURB_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerCycleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(PowerCycleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstSetTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(FirstSetTime)
        )
    );
}
pub type XBOX_REFURB_INFO = _XBOX_REFURB_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KFLOATING_SAVE {
    pub ControlWord: ULONG,
    pub StatusWord: ULONG,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: ULONG,
    pub DataOffset: ULONG,
    pub DataSelector: ULONG,
    pub Cr0NpxState: ULONG,
    pub Spare1: ULONG,
}
#[test]
fn bindgen_test_layout__KFLOATING_SAVE() {
    const UNINIT: ::core::mem::MaybeUninit<_KFLOATING_SAVE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KFLOATING_SAVE>(),
        32usize,
        concat!("Size of: ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KFLOATING_SAVE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Cr0NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Spare1)
        )
    );
}
pub type KFLOATING_SAVE = _KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_PTE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__HARDWARE_PTE() {
    assert_eq!(
        ::core::mem::size_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Size of: ", stringify!(_HARDWARE_PTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_HARDWARE_PTE))
    );
}
impl _HARDWARE_PTE {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuardOrEndOfAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuardOrEndOfAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        Write: ULONG,
        Owner: ULONG,
        WriteThrough: ULONG,
        CacheDisable: ULONG,
        Accessed: ULONG,
        Dirty: ULONG,
        LargePage: ULONG,
        Global: ULONG,
        GuardOrEndOfAllocation: ULONG,
        PersistAllocation: ULONG,
        reserved: ULONG,
        PageFrameNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u32 = unsafe { ::core::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u32 = unsafe { ::core::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u32 = unsafe { ::core::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u32 = unsafe { ::core::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u32 = unsafe { ::core::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u32 = unsafe { ::core::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u32 = unsafe { ::core::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u32 = unsafe { ::core::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GuardOrEndOfAllocation: u32 =
                unsafe { ::core::mem::transmute(GuardOrEndOfAllocation) };
            GuardOrEndOfAllocation as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PersistAllocation: u32 = unsafe { ::core::mem::transmute(PersistAllocation) };
            PersistAllocation as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let PageFrameNumber: u32 = unsafe { ::core::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HARDWARE_PTE = _HARDWARE_PTE;
pub type PHARDWARE_PTE = *mut _HARDWARE_PTE;
pub type PPS_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcArgument1: PVOID, ApcArgument2: PVOID, ApcArgument3: PVOID),
>;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrEventPair: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_WrFsCacheIn: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_WrFsCacheOut: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_Spare4: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_Spare5: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_Spare6: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 27;
pub type _KWAIT_REASON = libc::c_int;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: PRKTHREAD,
    pub Abandoned: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KMUTANT() {
    const UNINIT: ::core::mem::MaybeUninit<_KMUTANT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KMUTANT>(),
        32usize,
        concat!("Size of: ", stringify!(_KMUTANT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KMUTANT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KMUTANT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListEntry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(MutantListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(OwnerThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Abandoned) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Abandoned)
        )
    );
}
pub type KMUTANT = _KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARE_ACCESS {
    pub OpenCount: UCHAR,
    pub Readers: UCHAR,
    pub Writers: UCHAR,
    pub Deleters: UCHAR,
    pub SharedRead: UCHAR,
    pub SharedWrite: UCHAR,
    pub SharedDelete: UCHAR,
}
#[test]
fn bindgen_test_layout__SHARE_ACCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_SHARE_ACCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SHARE_ACCESS>(),
        7usize,
        concat!("Size of: ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_SHARE_ACCESS>(),
        1usize,
        concat!("Alignment of ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OpenCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(OpenCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Readers) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Writers) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Deleters) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Deleters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedRead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedWrite) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedDelete) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedDelete)
        )
    );
}
pub type SHARE_ACCESS = _SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
pub type PKSYNCHRONIZE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(SynchronizeContext: PVOID) -> BOOLEAN>;
pub type PKRUNDOWN_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(Apc: PKAPC)>;
pub type PKNORMAL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        NormalContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKKERNEL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Apc: PKAPC,
        NormalRoutine: *mut PKNORMAL_ROUTINE,
        NormalContext: *mut PVOID,
        SystemArgument1: *mut PVOID,
        SystemArgument2: *mut PVOID,
    ),
>;
pub type PHAL_SHUTDOWN_NOTIFICATION = ::core::option::Option<
    unsafe extern "stdcall" fn(ShutdownRegistration: *mut _HAL_SHUTDOWN_REGISTRATION),
>;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HAL_SHUTDOWN_REGISTRATION {
    #[doc = "< Function pointer which will be called on shutdown"]
    pub NotificationRoutine: PHAL_SHUTDOWN_NOTIFICATION,
    #[doc = "< Priority of the notification.The higher the priority, the earliert the callback function is called"]
    pub Priority: LONG,
    #[doc = "< Used to put the notifications into a linked list"]
    pub ListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__HAL_SHUTDOWN_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_HAL_SHUTDOWN_REGISTRATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        16usize,
        concat!("Size of: ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NotificationRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(NotificationRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type HAL_SHUTDOWN_REGISTRATION = _HAL_SHUTDOWN_REGISTRATION;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type PHAL_SHUTDOWN_REGISTRATION = *mut _HAL_SHUTDOWN_REGISTRATION;
pub type pfXcSHAInit = ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR)>;
pub type pfXcSHAUpdate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG),
>;
pub type pfXcSHAFinal =
    ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbDigest: PUCHAR)>;
pub type pfXcRC4Key = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR),
>;
pub type pfXcRC4Crypt = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR),
>;
pub type pfXcHMAC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    ),
>;
pub type pfXcPKEncPublic = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKDecPrivate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKGetKeyLen =
    ::core::option::Option<unsafe extern "stdcall" fn(pbPubKey: PUCHAR) -> ULONG>;
pub type pfXcVerifyPKCS1Signature = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN,
>;
pub type pfXcModExp = ::core::option::Option<
    unsafe extern "stdcall" fn(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG,
>;
pub type pfXcDESKeyParity =
    ::core::option::Option<unsafe extern "stdcall" fn(pbKey: PUCHAR, dwKeyLength: ULONG)>;
pub type pfXcKeyTable = ::core::option::Option<
    unsafe extern "stdcall" fn(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR),
>;
pub type pfXcBlockCrypt = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    ),
>;
pub type pfXcBlockCryptCBC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    ),
>;
pub type pfXcCryptService =
    ::core::option::Option<unsafe extern "stdcall" fn(dwOp: ULONG, pArgs: PVOID) -> ULONG>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYPTO_VECTOR {
    pub pXcSHAInit: pfXcSHAInit,
    pub pXcSHAUpdate: pfXcSHAUpdate,
    pub pXcSHAFinal: pfXcSHAFinal,
    pub pXcRC4Key: pfXcRC4Key,
    pub pXcRC4Crypt: pfXcRC4Crypt,
    pub pXcHMAC: pfXcHMAC,
    pub pXcPKEncPublic: pfXcPKEncPublic,
    pub pXcPKDecPrivate: pfXcPKDecPrivate,
    pub pXcPKGetKeyLen: pfXcPKGetKeyLen,
    pub pXcVerifyPKCS1Signature: pfXcVerifyPKCS1Signature,
    pub pXcModExp: pfXcModExp,
    pub pXcDESKeyParity: pfXcDESKeyParity,
    pub pXcKeyTable: pfXcKeyTable,
    pub pXcBlockCrypt: pfXcBlockCrypt,
    pub pXcBlockCryptCBC: pfXcBlockCryptCBC,
    pub pXcCryptService: pfXcCryptService,
}
#[test]
fn bindgen_test_layout_CRYPTO_VECTOR() {
    const UNINIT: ::core::mem::MaybeUninit<CRYPTO_VECTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CRYPTO_VECTOR>(),
        64usize,
        concat!("Size of: ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYPTO_VECTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAInit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAUpdate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAFinal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAFinal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Key) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Crypt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Crypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcHMAC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcHMAC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKEncPublic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKEncPublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKDecPrivate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKDecPrivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKGetKeyLen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKGetKeyLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcVerifyPKCS1Signature) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcVerifyPKCS1Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcModExp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcModExp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcDESKeyParity) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcDESKeyParity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcKeyTable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcKeyTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCrypt) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCryptCBC) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCryptCBC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcCryptService) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcCryptService)
        )
    );
}
pub type PCRYPTO_VECTOR = *mut CRYPTO_VECTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_TABLE {
    pub HandleCount: LONG,
    pub FirstFreeTableEntry: LONG_PTR,
    pub NextHandleNeedingPool: HANDLE,
    pub RootTable: *mut *mut PVOID,
    pub BuiltinRootTable: [*mut PVOID; 8usize],
}
#[test]
fn bindgen_test_layout__OBJECT_HANDLE_TABLE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HANDLE_TABLE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HANDLE_TABLE>(),
        48usize,
        concat!("Size of: ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HANDLE_TABLE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstFreeTableEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(FirstFreeTableEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextHandleNeedingPool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(NextHandleNeedingPool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootTable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(RootTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BuiltinRootTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(BuiltinRootTable)
        )
    );
}
pub type OBJECT_HANDLE_TABLE = _OBJECT_HANDLE_TABLE;
pub type POBJECT_HANDLE_TABLE = *mut _OBJECT_HANDLE_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNFREE {
    pub PackedPfnFlink: USHORT,
    pub PackedPfnBlink: USHORT,
}
#[test]
fn bindgen_test_layout__MMPFNFREE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNFREE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNFREE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNFREE>(),
        2usize,
        concat!("Alignment of ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnFlink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnFlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnBlink) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnBlink)
        )
    );
}
pub type MMPFNFREE = _MMPFNFREE;
pub type PMMPFNFREE = *mut _MMPFNFREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNREGION {
    pub FreePagesByColor: [MMPFNFREE; 32usize],
    pub AvailablePages: PFN_COUNT,
}
#[test]
fn bindgen_test_layout__MMPFNREGION() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNREGION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNREGION>(),
        132usize,
        concat!("Size of: ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNREGION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreePagesByColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(FreePagesByColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(AvailablePages)
        )
    );
}
pub type MMPFNREGION = _MMPFNREGION;
pub type PMMPFNREGION = *mut _MMPFNREGION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTE {
    pub __bindgen_anon_1: _MMPTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE__bindgen_ty_1 {
    pub Long: ULONG,
    pub Hard: HARDWARE_PTE,
    pub List: _MMPTE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OneEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        OneEntry: ULONG,
        NextEntry: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OneEntry: u32 = unsafe { ::core::mem::transmute(OneEntry) };
            OneEntry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let NextEntry: u32 = unsafe { ::core::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTE__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Long)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Hard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).List) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(List)
        )
    );
}
#[test]
fn bindgen_test_layout__MMPTE() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE))
    );
}
pub type MMPTE = _MMPTE;
pub type PMMPTE = *mut _MMPTE;
pub const _MMPFN_BUSY_TYPE_MmUnknownUsage: _MMPFN_BUSY_TYPE = 0;
pub const _MMPFN_BUSY_TYPE_MmStackUsage: _MMPFN_BUSY_TYPE = 1;
pub const _MMPFN_BUSY_TYPE_MmVirtualPageTableUsage: _MMPFN_BUSY_TYPE = 2;
pub const _MMPFN_BUSY_TYPE_MmSystemPageTableUsage: _MMPFN_BUSY_TYPE = 3;
pub const _MMPFN_BUSY_TYPE_MmPoolUsage: _MMPFN_BUSY_TYPE = 4;
pub const _MMPFN_BUSY_TYPE_MmVirtualMemoryUsage: _MMPFN_BUSY_TYPE = 5;
pub const _MMPFN_BUSY_TYPE_MmSystemMemoryUsage: _MMPFN_BUSY_TYPE = 6;
pub const _MMPFN_BUSY_TYPE_MmImageUsage: _MMPFN_BUSY_TYPE = 7;
pub const _MMPFN_BUSY_TYPE_MmFsCacheUsage: _MMPFN_BUSY_TYPE = 8;
pub const _MMPFN_BUSY_TYPE_MmContiguousUsage: _MMPFN_BUSY_TYPE = 9;
pub const _MMPFN_BUSY_TYPE_MmDebuggerUsage: _MMPFN_BUSY_TYPE = 10;
pub const _MMPFN_BUSY_TYPE_MmMaximumUsage: _MMPFN_BUSY_TYPE = 11;
pub type _MMPFN_BUSY_TYPE = libc::c_int;
pub use self::_MMPFN_BUSY_TYPE as MMPFN_BUSY_TYPE;
pub type PMMREMOVE_PAGE_ROUTINE = ::core::option::Option<
    unsafe extern "fastcall" fn(BusyType: MMPFN_BUSY_TYPE, TargetPte: PMMPTE) -> PFN_NUMBER,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTERANGE {
    pub HeadPte: MMPTE,
    pub FirstCommittedPte: PMMPTE,
    pub LastCommittedPte: PMMPTE,
    pub LastReservedPte: PMMPTE,
    pub AvailablePages: *mut PFN_COUNT,
    pub RemovePageRoutine: PMMREMOVE_PAGE_ROUTINE,
}
#[test]
fn bindgen_test_layout__MMPTERANGE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTERANGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTERANGE>(),
        24usize,
        concat!("Size of: ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTERANGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadPte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(HeadPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstCommittedPte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(FirstCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastCommittedPte) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastReservedPte) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastReservedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemovePageRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(RemovePageRoutine)
        )
    );
}
pub type MMPTERANGE = _MMPTERANGE;
pub type PMMPTERANGE = *mut _MMPTERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMADDRESS_NODE {
    pub StartingVpn: ULONG_PTR,
    pub EndingVpn: ULONG_PTR,
    pub Parent: *mut _MMADDRESS_NODE,
    pub LeftChild: *mut _MMADDRESS_NODE,
    pub RightChild: *mut _MMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMADDRESS_NODE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMADDRESS_NODE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMADDRESS_NODE>(),
        20usize,
        concat!("Size of: ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMADDRESS_NODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingVpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(StartingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndingVpn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(EndingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LeftChild) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(LeftChild)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RightChild) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(RightChild)
        )
    );
}
pub type MMADDRESS_NODE = _MMADDRESS_NODE;
pub type PMMADDRESS_NODE = *mut _MMADDRESS_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMGLOBALDATA {
    pub RetailPfnRegion: PMMPFNREGION,
    pub SystemPteRange: PMMPTERANGE,
    pub AvailablePages: PULONG,
    pub AllocatedPagesByUsage: *mut PFN_COUNT,
    pub AddressSpaceLock: PRTL_CRITICAL_SECTION,
    pub VadRoot: *mut PMMADDRESS_NODE,
    pub VadHint: *mut PMMADDRESS_NODE,
    pub VadFreeHint: *mut PMMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMGLOBALDATA() {
    const UNINIT: ::core::mem::MaybeUninit<_MMGLOBALDATA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMGLOBALDATA>(),
        32usize,
        concat!("Size of: ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMGLOBALDATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RetailPfnRegion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(RetailPfnRegion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemPteRange) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(SystemPteRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocatedPagesByUsage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AllocatedPagesByUsage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressSpaceLock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AddressSpaceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadRoot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadRoot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadHint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadHint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadFreeHint) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadFreeHint)
        )
    );
}
pub type MMGLOBALDATA = _MMGLOBALDATA;
pub type PMMGLOBALDATA = *mut _MMGLOBALDATA;
pub type PIDE_INTERRUPT_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_FINISHIO_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_POLL_RESET_COMPLETE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn() -> BOOLEAN>;
pub type PIDE_TIMEOUT_EXPIRED_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_START_PACKET_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP)>;
pub type PIDE_START_NEXT_PACKET_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IDE_CHANNEL_OBJECT {
    pub InterruptRoutine: PIDE_INTERRUPT_ROUTINE,
    pub FinishIoRoutine: PIDE_FINISHIO_ROUTINE,
    pub PollResetCompleteRoutine: PIDE_POLL_RESET_COMPLETE_ROUTINE,
    pub TimeoutExpiredRoutine: PIDE_TIMEOUT_EXPIRED_ROUTINE,
    pub StartPacketRoutine: PIDE_START_PACKET_ROUTINE,
    pub StartNextPacketRoutine: PIDE_START_NEXT_PACKET_ROUTINE,
    pub InterruptIrql: KIRQL,
    pub ExpectingBusMasterInterrupt: BOOLEAN,
    pub StartPacketBusy: BOOLEAN,
    pub StartPacketRequested: BOOLEAN,
    pub Timeout: UCHAR,
    pub IoRetries: UCHAR,
    pub MaximumIoRetries: UCHAR,
    pub CurrentIrp: PIRP,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub PhysicalRegionDescriptorTablePhysical: ULONG,
    pub TimerDpc: KDPC,
    pub FinishDpc: KDPC,
    pub Timer: KTIMER,
    pub InterruptObject: KINTERRUPT,
}
#[test]
fn bindgen_test_layout__IDE_CHANNEL_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_IDE_CHANNEL_OBJECT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IDE_CHANNEL_OBJECT>(),
        264usize,
        concat!("Size of: ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IDE_CHANNEL_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishIoRoutine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishIoRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PollResetCompleteRoutine) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PollResetCompleteRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeoutExpiredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimeoutExpiredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartNextPacketRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartNextPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptIrql) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptIrql)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ExpectingBusMasterInterrupt) as usize - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(ExpectingBusMasterInterrupt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketBusy) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketBusy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRequested) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRequested)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timeout) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoRetries) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(IoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumIoRetries) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(MaximumIoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PhysicalRegionDescriptorTablePhysical) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PhysicalRegionDescriptorTablePhysical)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerDpc) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimerDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishDpc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptObject) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptObject)
        )
    );
}
pub type IDE_CHANNEL_OBJECT = _IDE_CHANNEL_OBJECT;
pub type PIDE_CHANNEL_OBJECT = *mut _IDE_CHANNEL_OBJECT;
pub type PKSYSTEM_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(StartRoutine: PKSTART_ROUTINE, StartContext: PVOID),
>;
extern "stdcall" {
    #[doc = " Decrements the reference count of the section and unloads it if the reference count reaches zero.\n @param Section The section to be unloaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeUnloadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XePublicKeyData: [UCHAR; 284usize];
}
extern "stdcall" {
    #[doc = " Loads the supplied section into memory or increases its reference count if it's already loaded.\n @param Section The section to be loaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeLoadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XeImageFileName: [ANSI_STRING; 1usize];
}
extern "stdcall" {
    pub fn XcVerifyPKCS1Signature(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN;
}
extern "stdcall" {
    pub fn XcUpdateCrypto(pNewVector: PCRYPTO_VECTOR, pROMVector: PCRYPTO_VECTOR);
}
extern "stdcall" {
    #[doc = " Updates the internal state of the SHA-1 algorithm by hashing some input data.\n @param pbSHAContext A pointer to the buffer holding the internal state of the algorithm\n @param pbInput A pointer to the bytes which are to get hashed\n @oaram dwInputLength The number of bytes in the buffer given in the pbInput parameter"]
    pub fn XcSHAUpdate(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG);
}
extern "stdcall" {
    #[doc = " Initializes a buffer which will get used to generate a SHA-1 hash.\n @param pbSHAContext A pointer to a 116-byte buffer to be used as storage for the internal state of the algorithm"]
    pub fn XcSHAInit(pbSHAContext: PUCHAR);
}
extern "stdcall" {
    #[doc = " Extracts the final SHA-1 hash from the buffer used to calculate the hash.\n @param pbSHAContext A pointer to the buffer used to hold the internal state of the algorithm\n @param pbDigest A pointer to a 20-byte buffer in which the hash will be stored"]
    pub fn XcSHAFinal(pbSHAContext: PUCHAR, pbDigest: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Key(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Crypt(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR);
}
extern "stdcall" {
    pub fn XcPKGetKeyLen(pbPubKey: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKEncPublic(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKDecPrivate(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcModExp(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG;
}
extern "stdcall" {
    pub fn XcKeyTable(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcHMAC(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcDESKeyParity(pbKey: PUCHAR, dwKeyLength: ULONG);
}
extern "stdcall" {
    pub fn XcCryptService(dwOp: ULONG, pArgs: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn XcBlockCryptCBC(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcBlockCrypt(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    );
}
extern "C" {
    pub static mut XboxSignatureKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxLANKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxKrnlVersion: XBOX_KRNL_VERSION;
}
extern "C" {
    pub static mut XboxHardwareInfo: XBOX_HARDWARE_INFO;
}
extern "C" {
    pub static mut XboxHDKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxEEPROMKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxAlternateSignatureKeys: [XBOX_KEY_DATA; 0usize];
}
extern "stdcall" {
    #[doc = " Writes a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with zeroes\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled"]
    pub fn RtlZeroMemory(Destination: *mut VOID, Length: SIZE_T);
}
extern "stdcall" {
    pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlVsprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlVsnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlUpperString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Returns the uppercased equivalent of a single character\n @param Character The character which will be converted\n @return The uppercased character"]
    pub fn RtlUpperChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    #[doc = " Initiates an unwind of procedure call frames\n THIS FUNCTION IS NOT SAFE TO CALL FROM C CODE! It does not follow the stdcall convention and trashes registers that are supposed to be callee-saved.\n @param TargetFrame A pointer to the call frame that is the target of the unwind. If this parameter is NULL, the function performs an exit unwind.\n @param TargetIp The continuation address of the unwind. If NULL, the function will return normally. This parameter is ignored if TargetFrame is NULL.\n @param ExceptionRecord A pointer to an EXCEPTION_RECORD structure.\n @param ReturnValue A value to be placed in the integer function return register before continuing execution."]
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteSize(
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToInteger(
        String: PUNICODE_STRING,
        Base: ULONG,
        Value: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified Unicode source string into an ANSI string.\n @param DestinationString A pointer to an ANSI_STRING structure to hold the converted ANSI string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the UNICODE_STRING structure that contains the source string to be converted to ANSI.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeAnsiString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PSTRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.\n @param CriticalSection A pointer to the critical section object.\n @return If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero. If another thread already owns the critical section, the return value is zero."]
    pub fn RtlTryEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " The RtlTimeToTimeFields routine converts system time into a TIME_FIELDS structure\n @param Time Pointer to a buffer containing the absolute system time as a large integer, accurate to 100-nanosecond resolution\n @param TimeFields Pointer to a caller-allocated buffer, which must be at least sizeof(TIME_FIELDS), to contain the returned information"]
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
}
extern "stdcall" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
}
extern "C" {
    pub fn RtlSprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlSnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlRip(ApiName: PVOID, Expression: PVOID, Message: PVOID);
}
extern "stdcall" {
    pub fn RtlRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeSize(
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeN(
        UnicodeString: PWSTR,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMoveMemory(Destination: PVOID, Source: *const PVOID, Length: ULONG);
}
extern "stdcall" {
    pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: PGENERIC_MAPPING);
}
extern "stdcall" {
    #[doc = " Returns the lowercase equivalent of a single character\n @param Character The character which will be converted\n @return The lowercased character"]
    pub fn RtlLowerChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlLeaveCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Releases ownership of the specified critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlLeaveCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlIntegerToUnicodeString(
        Value: ULONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlIntegerToChar(Value: ULONG, Base: ULONG, OutputLength: LONG, String: PSZ)
        -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initializes a critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlInitializeCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of Unicode characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the UNICODE_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of ANSI characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the ANSI_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
extern "stdcall" {
    pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlAnsiStringToUnicodeString.\n @param UnicodeString A pointer to a Unicode string whose buffer was previously allocated by RtlAnsiStringToUnicodeString."]
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlUnicodeStringToAnsiString.\n @param AnsiString A pointer to an ANSI string whose buffer was previously allocated by RtlUnicodeStringToAnsiString."]
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with repetitions of a ULONG value\n @param Destination A pointer to the (ULONG-aligned) memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Pattern The ULONG-value with which the memory block will be filled"]
    pub fn RtlFillMemoryUlong(Destination: PVOID, Length: SIZE_T, Pattern: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with a specified value\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Fill The byte-value with which the memory block will be filled"]
    pub fn RtlFillMemory(Destination: PVOID, Length: ULONG, Fill: UCHAR);
}
extern "stdcall" {
    pub fn RtlExtendedMagicDivide(
        Dividend: LARGE_INTEGER,
        MagicDivisor: LARGE_INTEGER,
        ShiftCount: CCHAR,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedLargeIntegerDivide(
        Dividend: LARGE_INTEGER,
        Divisor: ULONG,
        Remainder: PULONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedIntegerMultiply(
        Multiplicand: LARGE_INTEGER,
        Multiplier: LONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first unicode string\n @param String2 Pointer to the second unicode string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlEnterCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    pub fn RtlCreateUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCWSTR,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PUNICODE_STRING);
}
extern "stdcall" {
    pub fn RtlCopyString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> LONG;
}
extern "stdcall" {
    #[doc = " Returns how many bytes in a block of memory match a specified pattern.\n @param Source Pointer to a block of memory. Must be aligned on a ULONG boundary.\n @param Length Number of bytes over which the comparison should be done. Must be a multiple of sizeof(ULONG).\n @param Pattern Pattern to be compared byte by byte, repeatedly, through the specified memory range.\n @return The number of bytes that were compared and found to be equal. If all bytes compare as equal, the \"Length\"-value is returned. If \"Source\" is not ULONG-aligned or if \"Length\" is not a multiple of sizeof(ULONG), zero is returned."]
    pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Compares two blocks of memory and returns the number of bytes that match.\n @param Source1 A pointer to the first block of memory.\n @param Source2 A pointer to the second block of memory.\n @param Length The number of bytes to compare.\n @return The number of bytes in the two blocks that match. If all bytes match, the \"Length\"-value is returned."]
    pub fn RtlCompareMemory(Source1: *const VOID, Source2: *const VOID, Length: SIZE_T) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Converts a single-byte character string (C-style string, NOT an ANSI_STRING object!) to an integer value\n @param String Pointer to a null-terminated single-byte string\n @param Base Specifies the base (decimal, binary, octal, hexadecimal). If not given, the routine looks for prefixes in the given string (0x, 0o, 0b), default is decimal.\n @param Value Pointer to a ULONG variable where the converted value will be stored\n @return STATUS_SUCCESS if the string was successfully converted, STATUS_INVALID_PARAMETER otherwise"]
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: ULONG,
        FramesToCapture: ULONG,
        BackTrace: *mut PVOID,
        BackTraceHash: PULONG,
    ) -> USHORT;
}
extern "stdcall" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "stdcall" {
    #[doc = " Reports a failed assertion to an attached debugger.\n @param FailedAssertion A string containing the expression that made the assertion fail\n @param FileName A string containing the name of the file containing the assertion\n @param LineNumber The linenumber containing the assertion\n @param Message An optional message (will also be shown by the debugger)"]
    pub fn RtlAssert(FailedAssertion: PVOID, FileName: PVOID, LineNumber: ULONG, Message: PCHAR);
}
extern "stdcall" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendUnicodeStringToString(
        Destination: PUNICODE_STRING,
        Source: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendStringToString(Destination: PSTRING, Source: PSTRING) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified ANSI source string into a Unicode string.\n @param DestinationString A pointer to a UNICODE_STRING structure to hold the converted Unicode string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the ANSI_STRING structure that contains the source string to be converted to Unicode.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeUnicodeString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PSTRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Reads a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub static mut PsThreadObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> !;
}
extern "stdcall" {
    pub fn PsSetCreateThreadNotifyRoutine(NotifyRoutine: PCREATE_THREAD_NOTIFY_ROUTINE)
        -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsQueryStatistics(ProcessStatistics: PPS_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThreadEx(
        ThreadHandle: PHANDLE,
        ThreadExtensionSize: SIZE_T,
        KernelStackSize: SIZE_T,
        TlsDataSize: SIZE_T,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        CreateSuspended: BOOLEAN,
        DebuggerThread: BOOLEAN,
        SystemRoutine: PKSYSTEM_ROUTINE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThread(
        ThreadHandle: PHANDLE,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        DebuggerThread: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initialize the ethernet PHY\n @param forceReset Whether to force a reset\n @param param Optional parameters (seemingly unused)\n @return Status code (zero on success)"]
    pub fn PhyInitialize(forceReset: BOOLEAN, param: PVOID) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Returns link status information either from NIC registers or from the last value cached by the kernel\n @param update If FALSE, the kernel returns the cached value, otherwise the hardware is polled and the cached value updated\n @return Flags describing the status of the NIC. See XNET_ETHERNET_LINK bit masks."]
    pub fn PhyGetLinkState(update: BOOLEAN) -> DWORD;
}
extern "C" {
    pub static mut ObpObjectHandleTable: OBJECT_HANDLE_TABLE;
}
extern "C" {
    pub static mut ObSymbolicLinkObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObReferenceObjectByPointer(Object: PVOID, ObjectType: POBJECT_TYPE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByName(
        ObjectName: POBJECT_STRING,
        Attributes: ULONG,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByHandle(
        Handle: HANDLE,
        ObjectType: POBJECT_TYPE,
        ReturnedObject: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByPointer(
        Object: PVOID,
        ObjectType: POBJECT_TYPE,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObMakeTemporaryObject(Object: PVOID);
}
extern "stdcall" {
    pub fn ObInsertObject(
        Object: PVOID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectPointerBias: ULONG,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ObDirectoryObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObCreateObject(
        ObjectType: POBJECT_TYPE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectBodySize: ULONG,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " yields execution of the current thread for one timeslice"]
    pub fn NtYieldExecution() -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtWriteFileGather(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". Also see NtWaitForSingleObject.\n @param Handle The handle to the wait object.\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObjectEx(
        Handle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". When used with a semaphore, the semaphore gets decremented and the threaad continues, or the thread waits until the semaphore-count becomes non-zero and then decrements the seamphore count and continues.\n @param Handle The handle to the wait object.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObject(
        Handle: HANDLE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified objects attain a state of \"signaled\". The wait can be specified to either wait until all objects are signaled or until one of the objects is signaled. Also see NtWaitForSingleObject.\n @param Count Specifies the number of objects that are to be waited on.\n @param Handles An array of handles to wait objects.\n @param WaitType Specifies the type of wait to perform (WaitAll or WaitAny)\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. The index of the object in the array that satisfied the wait is returned. Can also be STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForMultipleObjectsEx(
        Count: ULONG,
        Handles: *const HANDLE,
        WaitType: WAIT_TYPE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtUserIoApcDispatcher(
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Reserved: ULONG,
    );
}
extern "stdcall" {
    #[doc = " Suspends the target thread and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to suspend.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSignalAndWaitForSingleObjectEx(
        SignalHandle: HANDLE,
        WaitHandle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetTimerEx(
        TimerHandle: HANDLE,
        DueTime: PLARGE_INTEGER,
        TimerApcRoutine: PTIMER_APC_ROUTINE,
        ApcMode: KPROCESSOR_MODE,
        TimerContext: PVOID,
        ResumeTimer: BOOLEAN,
        Period: LONG,
        PreviousState: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets the current system time and optionally returns the old system time.\n @param SystemTime A pointer to the new value for the system time.\n @param PreviousTime An optional pointer to a variable that receives the previous system time.\n @return The status of the operation. STATUS_SUCCESS when successfull, STATUS_ACCESS_VIOLATION if the input parameter cannot be read or the output cannot be written, STATUS_INVALID_PARAMETER if the input time is negative."]
    pub fn NtSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state.\n @param EventHandle A HANDLE to the event object to be set.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resumes the target thread (see NtSuspendThread) and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to resume.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtRemoveIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: *mut PVOID,
        ApcContext: *mut PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a semaphore object. When the semaphore is released, the current count of the semaphore is incremented by \"ReleaseCount\". Any threads that are waiting for the semaphore are examined to see if the current semaphore value is sufficient to satisfy their wait. If the value specified by \"ReleaseCount\" would cause the maximum count for the semaphore to be exceeded, then the count for the semaphore is not affected and an error status is returned.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param ReleaseCount The release count for the semaphore. The count must be greater than zero and less than the maximum value specified for the semaphore.\n @param PreviousCount An optional pointer to a variable that receives the previous count for the semaphore.\n @return The status of the release operation, STATUS_SUCCESS on success."]
    pub fn NtReleaseSemaphore(
        SemaphoreHandle: HANDLE,
        ReleaseCount: LONG,
        PreviousCount: PLONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a mutant object (mutex).\n @param MutantHandle The handle to the mutant object.\n @param PreviousCount An optional pointer to a variable that receives the previous mutant count.\n @return The status of the operation."]
    pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFileScatter(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueueApcThread(
        ThreadHandle: HANDLE,
        ApcRoutine: PPS_APC_ROUTINE,
        ApcArgument1: PVOID,
        ApcArgument2: PVOID,
        ApcArgument3: PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVirtualMemory(
        BaseAddress: PVOID,
        MemoryInformation: PMEMORY_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryTimer(
        TimerHandle: HANDLE,
        TimerInformation: PTIMER_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQuerySymbolicLinkObject(
        LinkHandle: HANDLE,
        LinkTarget: POBJECT_STRING,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a semaphore object.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param SemaphoreInformation A pointer to a buffer (SEMAPHORE_BASIC_INFORMATION-structure) that receives the queried information.\n @return The status code of the query operation, STATUS_SUCCESS on success."]
    pub fn NtQuerySemaphore(
        SemaphoreHandle: HANDLE,
        SemaphoreInformation: PSEMAPHORE_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a mutant object.\n @param MutantHandle A handle to a mutant object.\n @param MutantInformation A pointer to a MUTANT_BASIC_INFORMATION-structure that receives the requested information.\n @return The status of the operation."]
    pub fn NtQueryMutant(
        MutantHandle: HANDLE,
        MutantInformation: PMUTANT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryIoCompletion(
        IoCompletionHandle: HANDLE,
        IoCompletionInformation: PIO_COMPLETION_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryFullAttributesFile(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryEvent(
        EventHandle: HANDLE,
        EventInformation: PEVENT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryObject(
        DirectoryHandle: HANDLE,
        Buffer: PVOID,
        Length: ULONG,
        RestartScan: BOOLEAN,
        Context: PULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        FileName: POBJECT_STRING,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state, and immediately resets it to the non-signaled state after waking all waiting threads.\n @param EventHandle A HANDLE to the event object to be pulsed.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtProtectVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        NewProtect: ULONG,
        OldProtect: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenSymbolicLinkObject(
        LinkHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFreeVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDuplicateObject(
        SourceHandle: HANDLE,
        TargetHandle: PHANDLE,
        Options: ULONG,
    ) -> NTSTATUS;
}
pub const _MEDIA_TYPE_Unknown: _MEDIA_TYPE = 0;
pub const _MEDIA_TYPE_F5_1Pt2_512: _MEDIA_TYPE = 1;
pub const _MEDIA_TYPE_F3_1Pt44_512: _MEDIA_TYPE = 2;
pub const _MEDIA_TYPE_F3_2Pt88_512: _MEDIA_TYPE = 3;
pub const _MEDIA_TYPE_F3_20Pt8_512: _MEDIA_TYPE = 4;
pub const _MEDIA_TYPE_F3_720_512: _MEDIA_TYPE = 5;
pub const _MEDIA_TYPE_F5_360_512: _MEDIA_TYPE = 6;
pub const _MEDIA_TYPE_F5_320_512: _MEDIA_TYPE = 7;
pub const _MEDIA_TYPE_F5_320_1024: _MEDIA_TYPE = 8;
pub const _MEDIA_TYPE_F5_180_512: _MEDIA_TYPE = 9;
pub const _MEDIA_TYPE_F5_160_512: _MEDIA_TYPE = 10;
pub const _MEDIA_TYPE_RemovableMedia: _MEDIA_TYPE = 11;
pub const _MEDIA_TYPE_FixedMedia: _MEDIA_TYPE = 12;
pub const _MEDIA_TYPE_F3_120M_512: _MEDIA_TYPE = 13;
pub const _MEDIA_TYPE_F3_640_512: _MEDIA_TYPE = 14;
pub const _MEDIA_TYPE_F5_640_512: _MEDIA_TYPE = 15;
pub const _MEDIA_TYPE_F5_720_512: _MEDIA_TYPE = 16;
pub const _MEDIA_TYPE_F3_1Pt2_512: _MEDIA_TYPE = 17;
pub const _MEDIA_TYPE_F3_1Pt23_1024: _MEDIA_TYPE = 18;
pub const _MEDIA_TYPE_F5_1Pt23_1024: _MEDIA_TYPE = 19;
pub const _MEDIA_TYPE_F3_128Mb_512: _MEDIA_TYPE = 20;
pub const _MEDIA_TYPE_F3_230Mb_512: _MEDIA_TYPE = 21;
pub const _MEDIA_TYPE_F8_256_128: _MEDIA_TYPE = 22;
pub const _MEDIA_TYPE_F3_200Mb_512: _MEDIA_TYPE = 23;
pub const _MEDIA_TYPE_F3_240M_512: _MEDIA_TYPE = 24;
pub const _MEDIA_TYPE_F3_32M_512: _MEDIA_TYPE = 25;
pub type _MEDIA_TYPE = libc::c_int;
pub use self::_MEDIA_TYPE as MEDIA_TYPE;
pub type PMEDIA_TYPE = *mut _MEDIA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GEOMETRY {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
}
#[test]
fn bindgen_test_layout__DISK_GEOMETRY() {
    const UNINIT: ::core::mem::MaybeUninit<_DISK_GEOMETRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISK_GEOMETRY>(),
        24usize,
        concat!("Size of: ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISK_GEOMETRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cylinders) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(Cylinders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MediaType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(MediaType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TracksPerCylinder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(TracksPerCylinder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerTrack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(SectorsPerTrack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type DISK_GEOMETRY = _DISK_GEOMETRY;
pub type PDISK_GEOMETRY = *mut _DISK_GEOMETRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION {
    pub StartingOffset: LARGE_INTEGER,
    pub PartitionLength: LARGE_INTEGER,
    pub HiddenSectors: DWORD,
    pub PartitionNumber: DWORD,
    pub PartitionType: BYTE,
    pub BootIndicator: BOOLEAN,
    pub RecognizedPartition: BOOLEAN,
    pub RewritePartition: BOOLEAN,
}
#[test]
fn bindgen_test_layout__PARTITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_PARTITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PARTITION_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_PARTITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(StartingOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HiddenSectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(HiddenSectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionNumber) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BootIndicator) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(BootIndicator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecognizedPartition) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RecognizedPartition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RewritePartition) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RewritePartition)
        )
    );
}
pub type PARTITION_INFORMATION = _PARTITION_INFORMATION;
pub type PPARTITION_INFORMATION = *mut _PARTITION_INFORMATION;
extern "stdcall" {
    pub fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtCreateTimer(
        TimerHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TimerType: TIMER_TYPE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Create a semaphore object with the specified initial and maximum count.\n @param SemaphoreHandle A pointer to a variable that receives the value of the semaphore object handle.\n @param ObjectAttributes An optional pointer to a structure that specifies the object's attributes.\n @param InitialCount The initial count for the semaphore, this value must be positive and less than or equal to the maximum count.\n @param MaximumCount The maximum count for the semaphore, this value must be greater than zero.\n @return STATUS_SUCCESS on success or error code."]
    pub fn NtCreateSemaphore(
        SemaphoreHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialCount: LONG,
        MaximumCount: LONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates a mutant object (mutex), sets its initial count to one (which means \"signaled\"), and opens a handle to the object.\n @param MutantHandle A pointer to a variable that receives the mutant object handle.\n @param ObjectAttributes A pointer to a OBJECT_ATTRIBUTES-structure that specifies object attributes.\n @pararm InitialOwner A boolean value that specifies whether the creator of the mutant object wants immediate ownership.\n @return The status of the operation."]
    pub fn NtCreateMutant(
        MutantHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialOwner: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateIoCompletion(
        IoCompletionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Count: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates an event object, sets the initial state of the event to the specified value, and opens a handle to the object.\n @param EventHandle A pointer to a variable that will receive the event object handle.\n @param ObjectAttributes A pointer to the object attributes structure supplied by the caller to be used for the specified object.\n @param EventType The type of the event, which can be SynchronizationEvent or a NotificationEvent.\n @param InitialState The initial state of the event object. Set to TRUE to initialize the event object to the Signaled state. Set to FALSE to initialize the event object to the not-Signaled state.\n @return STATUS_SUCCESS when the call is successfull, otherwise an NTSTATUS error code. STATUS_OBJECT_NAME_EXISTS if an event object of the same name already exists and was opened instead of creating a new one."]
    pub fn NtCreateEvent(
        EventHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EventType: EVENT_TYPE,
        InitialState: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Closes an object handle.\n @param Handle Handle to an object\n @return STATE_SUCCESS on success, error code (e.g. STATUS_INVALID_HANDLE, STATUS_HANDLE_NOT_CLOSABLE) otherwise"]
    pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resets an even object to the non-signaled state.\n @param EventHandle A HANDLE to the event object that is to be reset.\n @return STATE_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtAllocateVirtualMemory(
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        Protect: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn MmSetAddressProtect(BaseAddress: PVOID, NumberOfBytes: ULONG, NewProtect: ULONG);
}
extern "stdcall" {
    pub fn MmQueryStatistics(MemoryStatistics: PMM_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmQueryAllocationSize(BaseAddress: PVOID) -> SIZE_T;
}
extern "stdcall" {
    pub fn MmQueryAddressProtect(VirtualAddress: PVOID) -> ULONG;
}
extern "stdcall" {
    #[doc = " Marks a contiguous area of memory to be preserved across a quick reboot.\n @param BaseAddress The virtual address of the memory area.\n @param NumberOfBytes The number of bytes to be preserved.\n @param Persist TRUE if the memory should be persistent, else FALSE."]
    pub fn MmPersistContiguousMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T, Persist: BOOLEAN);
}
extern "stdcall" {
    pub fn MmMapIoSpace(PhysicalAddress: ULONG_PTR, NumberOfBytes: SIZE_T, Protect: ULONG)
        -> PVOID;
}
extern "stdcall" {
    pub fn MmLockUnlockPhysicalPage(PhysicalAddress: ULONG_PTR, UnlockPage: BOOLEAN);
}
extern "stdcall" {
    pub fn MmLockUnlockBufferPages(BaseAddress: PVOID, NumberOfBytes: SIZE_T, UnlockPages: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Checks whether a page fault would occur for a read operation on a specified address.\n @param VirtualAddress The virtual address to be checked.\n @return TRUE if a page fault would occur, FALSE if not."]
    pub fn MmIsAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
extern "C" {
    pub static mut MmGlobalData: MMGLOBALDATA;
}
extern "stdcall" {
    #[doc = " Returns the physical address for a virtual address.\n @param BaseAddress A valid virtual address for which the physical address is to be returned.\n @return The corresponding physical address."]
    pub fn MmGetPhysicalAddress(BaseAddress: PVOID) -> ULONG_PTR;
}
extern "stdcall" {
    pub fn MmFreeSystemMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
extern "stdcall" {
    pub fn MmDeleteKernelStack(KernelStackBase: PVOID, KernelStackLimit: PVOID);
}
extern "stdcall" {
    pub fn MmDbgWriteCheck(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE) -> PVOID;
}
extern "stdcall" {
    pub fn MmDbgReleaseAddress(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE);
}
extern "stdcall" {
    pub fn MmDbgQueryAvailablePages() -> PFN_COUNT;
}
extern "stdcall" {
    pub fn MmDbgFreeMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmDbgAllocateMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmCreateKernelStack(NumberOfBytes: SIZE_T, DebuggerThread: BOOLEAN) -> PVOID;
}
extern "stdcall" {
    pub fn MmClaimGpuInstanceMemory(
        NumberOfBytes: SIZE_T,
        NumberOfPaddingBytes: *mut SIZE_T,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateSystemMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemoryEx(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: ULONG_PTR,
        HighestAcceptableAddress: ULONG_PTR,
        Alignment: ULONG_PTR,
        Protect: ULONG,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemory(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "C" {
    pub static mut LaunchDataPage: PLAUNCH_DATA_PAGE;
}
extern "C" {
    pub static mut KiBugCheckData: [ULONG; 0usize];
}
extern "stdcall" {
    pub fn KeWaitForSingleObject(
        Object: PVOID,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeWaitForMultipleObjects(
        Count: ULONG,
        Object: *mut PVOID,
        WaitType: WAIT_TYPE,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
    ) -> NTSTATUS;
}
extern "C" {
    pub static KeTimeIncrement: ULONG;
}
extern "C" {
    #[doc = " Contains the number of milliseconds elapsed since the system was started."]
    pub static mut KeTickCount: DWORD;
}
extern "stdcall" {
    pub fn KeTestAlertThread(ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "C" {
    pub static mut KeSystemTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeSynchronizeExecution(
        Interrupt: PKINTERRUPT,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSuspendThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    #[doc = " Stalls the caller on the current processor for a specified time Interval.\n @param MicroSeconds Specifies the number of microseconds to stall."]
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
extern "stdcall" {
    pub fn KeSetTimerEx(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: LONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Sets the run-time priority of a thread.\n @param Thread Pointer to the thread.\n @param Priority Specifies the priority of the thread, usually to the real-time priority value, LOW_REALTIME_PRIORITY. The value LOW_PRIORITY is reserved for system use.\n @return Returns the old priority of the thread."]
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetPriorityProcess(Process: PKPROCESS, BasePriority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetEventBoostPriority(Event: PRKEVENT, Thread: *mut PRKTHREAD);
}
extern "stdcall" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeSetDisableBoostThread(Thread: PKTHREAD, Disable: LOGICAL) -> LOGICAL;
}
extern "stdcall" {
    pub fn KeSetBasePriorityThread(Thread: PKTHREAD, Increment: LONG) -> LONG;
}
extern "stdcall" {
    pub fn KeSaveFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeRundownQueue(Queue: PRKQUEUE) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    pub fn KeRestoreFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
extern "stdcall" {
    #[doc = " Removes a DPC object from the deferred procedure call queue\n @param Dpc A pointer to the DPC object"]
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveQueue(
        Queue: PRKQUEUE,
        WaitMode: KPROCESSOR_MODE,
        Timeout: PLARGE_INTEGER,
    ) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveEntryDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeReleaseSemaphore(
        Semaphore: PRKSEMAPHORE,
        Increment: KPRIORITY,
        Adjustment: LONG,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeReleaseMutant(
        Mutant: PRKMUTANT,
        Increment: KPRIORITY,
        Abandoned: BOOLEAN,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToSynchLevel() -> KIRQL;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToDpcLevel() -> KIRQL;
}
extern "stdcall" {
    #[doc = " Obtains the current system time.\n @param CurrentTime The system time in 100-nanosecond intervals since January 1, 1601, in GMT."]
    pub fn KeQuerySystemTime(CurrentTime: PLARGE_INTEGER);
}
extern "stdcall" {
    pub fn KeQueryPerformanceFrequency() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryPerformanceCounter() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryInterruptTime() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryBasePriorityThread(Thread: PKTHREAD) -> LONG;
}
extern "stdcall" {
    pub fn KePulseEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeLeaveCriticalRegion();
}
extern "stdcall" {
    #[doc = " Checks whether the code is executed in a DPC context\n @return TRUE if the code is running in a DPC context, FALSE otherwise"]
    pub fn KeIsExecutingDpc() -> BOOLEAN;
}
extern "C" {
    pub static mut KeInterruptTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID, SystemArgument2: PVOID)
        -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueueApc(
        Apc: PRKAPC,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
        Increment: KPRIORITY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertHeadQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
        SortKey: ULONG,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
extern "stdcall" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG, Limit: LONG);
}
extern "stdcall" {
    pub fn KeInitializeQueue(Queue: PRKQUEUE, Count: ULONG);
}
extern "stdcall" {
    pub fn KeInitializeMutant(Mutant: PRKMUTANT, InitialOwner: BOOLEAN);
}
extern "stdcall" {
    pub fn KeInitializeInterrupt(
        Interrupt: PKINTERRUPT,
        ServiceRoutine: PKSERVICE_ROUTINE,
        ServiceContext: PVOID,
        Vector: ULONG,
        Irql: KIRQL,
        InterruptMode: KINTERRUPT_MODE,
        ShareVector: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE, State: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Initializes a DPC object describing the parameters for a deferred procedure\n call\n @param Dpc Pointer to a DPC struct that gets initialized\n @param DeferredRoutine Pointer to the function that gets called by the DPC\n @param DeferredContext An arbitrary user-defined pointer that gets passed to the procedure when called"]
    pub fn KeInitializeDpc(
        Dpc: *mut KDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
extern "stdcall" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
extern "stdcall" {
    pub fn KeInitializeApc(
        Apc: PRKAPC,
        Thread: PRKTHREAD,
        KernelRoutine: PKKERNEL_ROUTINE,
        RundownRoutine: PKRUNDOWN_ROUTINE,
        NormalRoutine: PKNORMAL_ROUTINE,
        ProcessorMode: KPROCESSOR_MODE,
        NormalContext: PVOID,
    );
}
extern "stdcall" {
    #[doc = " Returns a pointer to the thread object belonging to the current thread.\n @return A pointer to an opaque thread object."]
    pub fn KeGetCurrentThread() -> PKTHREAD;
}
extern "stdcall" {
    pub fn KeGetCurrentIrql() -> KIRQL;
}
extern "stdcall" {
    pub fn KeEnterCriticalRegion();
}
extern "stdcall" {
    pub fn KeDisconnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Puts the current thread into an alertable or nonalertable wait state for a specified interval\n @param WaitMode Specifies the processor mode in which the caller is waiting, which can be either KernelMode or UserMode.\n @param Alertable TRUE if the wait is alertable.\n @param Interval Specifies the absolute or relative time, in units of 100 nanoseconds, for which the wait is to occur. A negative value indicates relative time. Absolute expiration times track any changes in system time, relative expiration times are not affected by system time changes.\n @return STATUS_SUCCESS (the delay completed because the specified interval elapsed), STATUS_ALERTED (the delay completed because the thread was alerted) or STATUS_USER_APC (a user-mode APC was delivered before the specified interval expired)."]
    pub fn KeDelayExecutionThread(
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Interval: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Connects an interrupt object, allowing it to receive interrupts\n @return FALSE if the interrupt is already connected or cannot be connected, TRUE if it was conected successfully"]
    pub fn KeConnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeCancelTimer(Timer: PKTIMER) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeBugCheckEx(
        BugCheckCode: ULONG,
        BugCheckParameter1: ULONG_PTR,
        BugCheckParameter2: ULONG_PTR,
        BugCheckParameter3: ULONG_PTR,
        BugCheckParameter4: ULONG_PTR,
    ) -> !;
}
extern "stdcall" {
    pub fn KeBugCheck(BugCheckCode: ULONG) -> !;
}
extern "stdcall" {
    pub fn KeBoostPriorityThread(Thread: PKTHREAD, Increment: KPRIORITY);
}
extern "stdcall" {
    pub fn KeAlertThread(Thread: PKTHREAD, ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeAlertResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "C" {
    pub static mut KdDebuggerNotPresent: BOOLEAN;
}
extern "C" {
    pub static mut KdDebuggerEnabled: BOOLEAN;
}
extern "stdcall" {
    pub fn IoSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoSynchronousDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        ReturnedOutputBufferLength: PULONG,
        InternalDeviceIoControl: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoStartPacket(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Key: PULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT, Key: ULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoSetShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
    );
}
extern "stdcall" {
    pub fn IoSetIoCompletion(
        IoCompletion: PVOID,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
extern "stdcall" {
    pub fn IoQueueThreadIrp(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoQueryVolumeInformation(
        FileObject: PFILE_OBJECT,
        FsInformationClass: FS_INFORMATION_CLASS,
        Length: ULONG,
        FsInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoQueryFileInformation(
        FileObject: PFILE_OBJECT,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        FileInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoMarkIrpMustComplete(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoInvalidDeviceRequest(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
extern "stdcall" {
    pub fn IoFreeIrp(Irp: PIRP);
}
extern "C" {
    pub static mut IoFileObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDismountVolumeByName(DeviceName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDismountVolume(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub static mut IoDeviceObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoCreateSymbolicLink(
        SymbolicLinkName: POBJECT_STRING,
        DeviceName: POBJECT_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        Options: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateDevice(
        DriverObject: PDRIVER_OBJECT,
        DeviceExtensionSize: ULONG,
        DeviceName: POBJECT_STRING,
        DeviceType: DEVICE_TYPE,
        Exclusive: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut IoCompletionObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoCheckShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoBuildSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        InternalDeviceIoControl: BOOLEAN,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildAsynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoAllocateIrp(StackSize: CCHAR) -> PIRP;
}
extern "C" {
    pub static mut IdexChannelObject: IDE_CHANNEL_OBJECT;
}
extern "stdcall" {
    pub fn HalWriteSMCScratchRegister(ScratchRegister: ULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalWriteSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        WriteWordValue: BOOLEAN,
        DataValue: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReturnToFirmware(Routine: FIRMWARE_REENTRY) -> !;
}
extern "stdcall" {
    #[doc = " Registers or unregisters a shutdown notification which contains a function\n pointer that will be called on shutdown\n @param ShutdownRegistration Pointer to a HAL_SHUTDOWN_REGISTRATION describing the notification settings\n @param Register TRUE to register the notification, FALSE to unregister"]
    pub fn HalRegisterShutdownNotification(
        ShutdownRegistration: PHAL_SHUTDOWN_REGISTRATION,
        Register: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadWritePCISpace(
        BusNumber: ULONG,
        SlotNumber: ULONG,
        RegisterNumber: ULONG,
        Buffer: PVOID,
        Length: ULONG,
        WritePCISpace: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadSMCTrayState(TrayState: PULONG, TrayStateChangeCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReadSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        ReadWordValue: BOOLEAN,
        DataValue: *mut ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Checks whether the console is in the middle of a reset or shutdown sequence.\n @return TRUE if the console is in the middle of a reset or shutdown sequence, else FALSE."]
    pub fn HalIsResetOrShutdownPending() -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Initiates a shutdown. May return if the SMBus-lock is already owned, the shutdown will start as soon as the lock is available."]
    pub fn HalInitiateShutdown();
}
extern "stdcall" {
    pub fn HalGetInterruptVector(BusInterruptLevel: ULONG, Irql: PKIRQL) -> ULONG;
}
extern "stdcall" {
    pub fn HalEnableSystemInterrupt(BusInterruptLevel: ULONG, InterruptMode: KINTERRUPT_MODE);
}
extern "stdcall" {
    #[doc = " Switches the console to secure mode, where a tray eject or tray open interrupt causes the console to reboot. After the console is switched into secure mode, it cannot switch back."]
    pub fn HalEnableSecureTrayEject();
}
extern "C" {
    pub static mut HalDiskSerialNumber: STRING;
}
extern "C" {
    pub static mut HalDiskModelNumber: STRING;
}
extern "C" {
    pub static mut HalDiskCachePartitionCount: ULONG;
}
extern "stdcall" {
    pub fn HalDisableSystemInterrupt(BusInterruptLevel: ULONG);
}
extern "C" {
    pub static mut HalBootSMCVideoMode: DWORD;
}
extern "stdcall" {
    pub fn FscSetCacheSize(NumberOfCachePages: PFN_COUNT) -> NTSTATUS;
}
extern "stdcall" {
    pub fn FscInvalidateIdleBlocks();
}
extern "stdcall" {
    pub fn FscGetCacheSize() -> PFN_COUNT;
}
extern "C" {
    pub static mut ExTimerObjectType: OBJECT_TYPE;
}
extern "C" {
    pub static mut ExSemaphoreObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExSaveNonVolatileSetting(
        ValueIndex: ULONG,
        Type: ULONG,
        Value: PVOID,
        ValueLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExReleaseReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExReadWriteRefurbInfo(
        RefurbInfo: *mut XBOX_REFURB_INFO,
        ValueLength: ULONG,
        DoWrite: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn ExRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    #[doc = " Returns the size of the pool block.\n @param PoolBlock The address of the pool block.\n @return The size of the pool block."]
    pub fn ExQueryPoolBlockSize(PoolBlock: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn ExQueryNonVolatileSetting(
        ValueIndex: ULONG,
        Type: PULONG,
        Value: PVOID,
        ValueLength: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ExMutantObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExInterlockedAddLargeInteger(
        Addend: PLARGE_INTEGER,
        Increment: LARGE_INTEGER,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn ExInitializeReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    #[doc = " Deallocates a block of pool memory.\n @param P Specifies the address of the block of pool memory being deallocated."]
    pub fn ExFreePool(P: PVOID);
}
extern "C" {
    pub static mut ExEventObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @param Tag The pool tag to use for the allocated memory. Specify the pool tag as a character literal of up to four characters delimited by single quotation marks (for example, 'Tag1'). The string is usually specified in reverse order (for example, '1gaT'). Each ASCII character in the tag must be a value in the range 0x20 (space) to 0x126 (tilde). Each allocation code path should use a unique pool tag to help debuggers and verifiers identify the code path.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePoolWithTag(NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePool(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockShared(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockExclusive(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn DbgUnLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    #[doc = " WARNING: This function crashes my XBox, so probably don't use.\n Displays a prompt-string on the debugging console, then reads a line of text from the debugging console.\n @param Prompt The string that gets output on the debugging console.\n @param Response Specifies where to store the response string read from the debugging console.\n @param MaximumResponseLength Maximum number of characters that fit into the response-buffer.\n @return Number of characters stored into the response buffer, including newline."]
    pub fn DbgPrompt(Prompt: PCH, Response: PCH, MaximumResponseLength: ULONG) -> ULONG;
}
extern "C" {
    #[doc = " \"printf\"-style output function for the kernel debugger.\n @param Format \"printf\"-style format string\n @param ... Arguments matching the format string.\n @return A status-code."]
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
extern "stdcall" {
    pub fn DbgLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
extern "stdcall" {
    pub fn DbgBreakPoint();
}
extern "stdcall" {
    pub fn AvSetSavedDataAddress(Address: PVOID);
}
extern "stdcall" {
    pub fn AvSetDisplayMode(
        RegisterBase: PVOID,
        Step: ULONG,
        DisplayMode: ULONG,
        SourceColorFormat: ULONG,
        Pitch: ULONG,
        FrameBuffer: ULONG,
    ) -> ULONG;
}
extern "stdcall" {
    pub fn AvSendTVEncoderOption(RegisterBase: PVOID, Option: ULONG, Param: ULONG, Result: PULONG);
}
extern "stdcall" {
    pub fn AvGetSavedDataAddress() -> PVOID;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a USHORT\n @param Source The USHORT-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUshortByteSwap(Source: USHORT) -> USHORT;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a ULONG\n @param Source The ULONG-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUlongByteSwap(Source: ULONG) -> ULONG;
}
extern "fastcall" {
    pub fn ObfReferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn ObfDereferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn KiUnlockDispatcherDatabase(OldIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Raises the hardware priority to the specified IRQL value, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n @param NewIrql Specifies the new IRQL to which the hardware priority is to be raised.\n @return The original IRQL value to be used in a subsequent call to KfLowerIrql."]
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
extern "fastcall" {
    #[doc = " Restores the IRQL on the current processor to its original value.\n @param NewIrql Specifies the IRQL that was returned from KfRaiseIrql."]
    pub fn KfLowerIrql(NewIrql: KIRQL);
}
extern "fastcall" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
extern "fastcall" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "fastcall" {
    pub fn InterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSINGLE_LIST_ENTRY,
    ) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically increments a LONG-value\n @param Addend Pointer to the LONG-variable which is to be incremented\n @return The resulting incremented value (also stored at 'Addend')"]
    pub fn InterlockedIncrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedExchangeAdd(Addend: *mut LONG, Increment: LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedExchange(Target: *mut LONG, Value: LONG) -> LONG;
}
extern "fastcall" {
    #[doc = " Atomically decrements a LONG-value\n @param Addend Pointer to the LONG-variable which is to be decremented\n @return The resulting decremented value (also stored at 'Addend')"]
    pub fn InterlockedDecrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedCompareExchange(
        Destination: *mut LONG,
        ExChange: LONG,
        Comparand: LONG,
    ) -> LONG;
}
extern "fastcall" {
    #[doc = " Requests a software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalRequestSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Clears a possible pending software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalClearSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Atomically removes an entry from the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @return A pointer to the LIST_ENTRY which was removed from the list (NULL if the list was empty)."]
    pub fn ExfInterlockedRemoveHeadList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the end of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the last list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertTailList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the first list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertHeadList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Compares one integer variable to another and, if they're equal, sets the first variable to a caller-supplied value.\n @param Destination A pointer to an integer that will be compared and possibly replaced.\n @param Exchange A pointer to an integer that will replace the one at Destination if the comparison results in equality.\n @param Comparand A pointer to an integer with which the value at Destination will be compared.\n @return The inital value of the variable at Destination when the call occured."]
    pub fn ExInterlockedCompareExchange64(
        Destination: *mut LONGLONG,
        Exchange: PLONGLONG,
        Comparand: PLONGLONG,
    ) -> LONGLONG;
}
extern "fastcall" {
    #[doc = " Performs an interlocked addition of a ULONG increment value to a LARGE_INTEGER variable.\n @param Addend A pointer to the LARGE_INTEGER variable that is incremented by the value of Increment.\n @param Increment Specifies a ULONG value that is added to the variable that Addend points to."]
    pub fn ExInterlockedAddLargeStatistic(Addend: PLARGE_INTEGER, Increment: ULONG);
}
extern "C" {
    pub fn VirtualAlloc(
        lpAddress: LPVOID,
        dwSize: SIZE_T,
        flAllocationType: DWORD,
        flProtect: DWORD,
    ) -> LPVOID;
}
extern "C" {
    pub fn VirtualFree(lpAddress: LPVOID, dwSize: SIZE_T, dwFreeType: DWORD) -> BOOL;
}
extern "C" {
    pub fn VirtualQuery(
        lpAddress: LPCVOID,
        lpBuffer: PMEMORY_BASIC_INFORMATION,
        dwLength: SIZE_T,
    ) -> SIZE_T;
}
pub type LPTHREAD_START_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(lpThreadParameter: LPVOID) -> DWORD>;
extern "C" {
    pub fn CreateThread(
        lpThreadAttributes: LPSECURITY_ATTRIBUTES,
        dwStackSize: SIZE_T,
        lpStartAddress: LPTHREAD_START_ROUTINE,
        lpParameter: LPVOID,
        dwCreationFlags: DWORD,
        lpThreadId: LPDWORD,
    ) -> HANDLE;
}
extern "C" {
    pub fn ExitThread(dwExitCode: DWORD);
}
extern "C" {
    pub fn GetExitCodeThread(hThread: HANDLE, lpExitCode: LPDWORD) -> BOOL;
}
extern "C" {
    pub fn GetCurrentThread() -> HANDLE;
}
extern "C" {
    pub fn GetCurrentThreadId() -> DWORD;
}
extern "C" {
    pub fn GetThreadId(Thread: HANDLE) -> DWORD;
}
extern "C" {
    pub fn SwitchToThread() -> BOOL;
}
extern "C" {
    pub fn SetThreadPriority(hThread: HANDLE, nPriority: libc::c_int) -> BOOL;
}
extern "C" {
    pub fn TlsAlloc() -> DWORD;
}
extern "C" {
    pub fn TlsFree(dwTlsIndex: DWORD) -> BOOL;
}
extern "C" {
    pub fn TlsGetValue(dwTlsIndex: DWORD) -> LPVOID;
}
extern "C" {
    pub fn TlsSetValue(dwTlsIndex: DWORD, lpTlsValue: LPVOID) -> BOOL;
}
extern "C" {
    pub fn QueryPerformanceCounter(lpPerformanceCount: *mut LARGE_INTEGER) -> BOOL;
}
extern "C" {
    pub fn QueryPerformanceFrequency(lpFrequency: *mut LARGE_INTEGER) -> BOOL;
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type LPCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
pub type PCRITICAL_SECTION = PRTL_CRITICAL_SECTION;
extern "C" {
    pub fn InitializeCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn InitializeCriticalSectionAndSpinCount(
        lpCriticalSection: LPCRITICAL_SECTION,
        dwSpinCount: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn DeleteCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn EnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn TryEnterCriticalSection(lpCriticalSection: LPCRITICAL_SECTION) -> BOOL;
}
extern "C" {
    pub fn LeaveCriticalSection(lpCriticalSection: LPCRITICAL_SECTION);
}
extern "C" {
    pub fn InitializeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn SleepConditionVariableCS(
        ConditionVariable: PCONDITION_VARIABLE,
        CriticalSection: PCRITICAL_SECTION,
        dwMilliseconds: DWORD,
    ) -> BOOL;
}
extern "C" {
    pub fn SleepConditionVariableSRW(
        ConditionVariable: PCONDITION_VARIABLE,
        SRWLock: PSRWLOCK,
        dwMilliseconds: DWORD,
        Flags: ULONG,
    ) -> BOOL;
}
extern "C" {
    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn UninitializeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);
}
extern "C" {
    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn InitializeSRWLock(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);
}
extern "C" {
    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;
}
extern "C" {
    pub fn InitOnceExecuteOnce(
        InitOnce: PINIT_ONCE,
        InitFn: PINIT_ONCE_FN,
        Context: PVOID,
        Parameter: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn InitOnceBeginInitialize(
        lpInitOnce: LPINIT_ONCE,
        dwFlags: DWORD,
        fPending: PBOOL,
        lpContext: *mut LPVOID,
    ) -> BOOL;
}
extern "C" {
    pub fn InitOnceComplete(lpInitOnce: LPINIT_ONCE, dwFlags: DWORD, lpContext: LPVOID) -> BOOL;
}
extern "C" {
    pub fn Sleep(dwMilliseconds: DWORD);
}
extern "C" {
    pub fn SleepEx(dwMilliseconds: DWORD, bAlertable: BOOL) -> DWORD;
}
extern "C" {
    pub fn WaitForSingleObjectEx(hHandle: HANDLE, dwMilliseconds: DWORD, bAlertable: BOOL)
        -> DWORD;
}
extern "C" {
    pub fn WaitForSingleObject(hHandle: HANDLE, dwMilliseconds: DWORD) -> DWORD;
}
extern "C" {
    pub fn WaitForMultipleObjectsEx(
        nCount: DWORD,
        lpHandles: *const HANDLE,
        bWaitAll: BOOL,
        dwMilliseconds: DWORD,
        bAlertable: BOOL,
    ) -> DWORD;
}
extern "C" {
    pub fn WaitForMultipleObjects(
        nCount: DWORD,
        lpHandles: *const HANDLE,
        bWaitAll: BOOL,
        dwMilliseconds: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn CreateSemaphore(
        lpSemaphoreAttributes: LPSECURITY_ATTRIBUTES,
        lInitialCount: LONG,
        lMaximumCount: LONG,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn ReleaseSemaphore(
        hSemaphore: HANDLE,
        lReleaseCount: LONG,
        lpPreviousCount: LPLONG,
    ) -> BOOL;
}
extern "C" {
    pub fn CreateMutexA(
        lpMutexAttributes: LPSECURITY_ATTRIBUTES,
        bInitialOwner: BOOL,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn ReleaseMutex(hMutex: HANDLE) -> BOOL;
}
extern "C" {
    pub fn CreateEventA(
        lpEventAttributes: LPSECURITY_ATTRIBUTES,
        bManualReset: BOOL,
        bInitialState: BOOL,
        lpName: LPCSTR,
    ) -> HANDLE;
}
extern "C" {
    pub fn SetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn ResetEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn PulseEvent(hEvent: HANDLE) -> BOOL;
}
extern "C" {
    pub fn GetSystemTime(lpSystemTime: LPSYSTEMTIME);
}
extern "C" {
    pub fn GetSystemTimePreciseAsFileTime(lpSystemTimeAsFileTime: LPFILETIME);
}
extern "C" {
    pub fn GetTickCount() -> DWORD;
}
extern "C" {
    pub fn GetLocalTime(lpSystemTime: LPSYSTEMTIME);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_INFO {
    pub DUMMYUNIONNAME: _SYSTEM_INFO__bindgen_ty_1,
    pub dwPageSize: DWORD,
    pub dwActiveProcessorMask: DWORD_PTR,
    pub dwNumberOfProcessors: DWORD,
    pub dwAllocationGranularity: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_INFO__bindgen_ty_1 {
    pub DUMMYSTRUCTNAME: _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1 {
    pub wProcessorArchitecture: WORD,
    pub wReserved: WORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wProcessorArchitecture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wProcessorArchitecture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wReserved) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(wReserved)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SYSTEM_INFO__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_INFO__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_INFO__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_SYSTEM_INFO__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DUMMYSTRUCTNAME) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO__bindgen_ty_1),
            "::",
            stringify!(DUMMYSTRUCTNAME)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_SYSTEM_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SYSTEM_INFO>(),
        20usize,
        concat!("Size of: ", stringify!(_SYSTEM_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_SYSTEM_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DUMMYUNIONNAME) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO),
            "::",
            stringify!(DUMMYUNIONNAME)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwPageSize) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO),
            "::",
            stringify!(dwPageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwActiveProcessorMask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO),
            "::",
            stringify!(dwActiveProcessorMask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwNumberOfProcessors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO),
            "::",
            stringify!(dwNumberOfProcessors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwAllocationGranularity) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_INFO),
            "::",
            stringify!(dwAllocationGranularity)
        )
    );
}
pub type SYSTEM_INFO = _SYSTEM_INFO;
pub type LPSYSTEM_INFO = *mut _SYSTEM_INFO;
extern "C" {
    pub fn GetSystemInfo(lpSystemInfo: LPSYSTEM_INFO);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_ZONE_INFORMATION {
    pub Bias: LONG,
    pub StandardName: [WCHAR; 32usize],
    pub StandardDate: SYSTEMTIME,
    pub StandardBias: LONG,
    pub DaylightName: [WCHAR; 32usize],
    pub DaylightDate: SYSTEMTIME,
    pub DaylightBias: LONG,
}
#[test]
fn bindgen_test_layout__TIME_ZONE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_TIME_ZONE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIME_ZONE_INFORMATION>(),
        172usize,
        concat!("Size of: ", stringify!(_TIME_ZONE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIME_ZONE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TIME_ZONE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bias) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(Bias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(StandardName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardDate) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(StandardDate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardBias) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(StandardBias)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DaylightName) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(DaylightName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DaylightDate) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(DaylightDate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DaylightBias) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_ZONE_INFORMATION),
            "::",
            stringify!(DaylightBias)
        )
    );
}
pub type TIME_ZONE_INFORMATION = _TIME_ZONE_INFORMATION;
pub type PTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
pub type LPTIME_ZONE_INFORMATION = *mut _TIME_ZONE_INFORMATION;
extern "C" {
    pub fn GetTimeZoneInformation(lpTimeZoneInformation: LPTIME_ZONE_INFORMATION) -> DWORD;
}
pub type u8_t = libc::c_uchar;
pub type s8_t = libc::c_schar;
pub type u16_t = libc::c_ushort;
pub type s16_t = libc::c_short;
pub type u32_t = libc::c_uint;
pub type s32_t = libc::c_int;
pub type mem_ptr_t = libc::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sio_status_s {
    _unused: [u8; 0],
}
pub type sio_status_t = sio_status_s;
pub type u64_t = u64;
pub type s64_t = i64;
pub type imaxdiv_t = _PDCLIB_imaxdiv_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn isalnum(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isalpha(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isblank(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn iscntrl(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isdigit(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isgraph(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn islower(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isprint(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ispunct(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isspace(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isupper(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isxdigit(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn tolower(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn toupper(c: libc::c_int) -> libc::c_int;
}
#[doc = " No error, everything OK."]
pub const err_enum_t_ERR_OK: err_enum_t = 0;
#[doc = " Out of memory error."]
pub const err_enum_t_ERR_MEM: err_enum_t = -1;
#[doc = " Buffer error."]
pub const err_enum_t_ERR_BUF: err_enum_t = -2;
#[doc = " Timeout."]
pub const err_enum_t_ERR_TIMEOUT: err_enum_t = -3;
#[doc = " Routing problem."]
pub const err_enum_t_ERR_RTE: err_enum_t = -4;
#[doc = " Operation in progress"]
pub const err_enum_t_ERR_INPROGRESS: err_enum_t = -5;
#[doc = " Illegal value."]
pub const err_enum_t_ERR_VAL: err_enum_t = -6;
#[doc = " Operation would block."]
pub const err_enum_t_ERR_WOULDBLOCK: err_enum_t = -7;
#[doc = " Address in use."]
pub const err_enum_t_ERR_USE: err_enum_t = -8;
#[doc = " Already connecting."]
pub const err_enum_t_ERR_ALREADY: err_enum_t = -9;
#[doc = " Conn already established."]
pub const err_enum_t_ERR_ISCONN: err_enum_t = -10;
#[doc = " Not connected."]
pub const err_enum_t_ERR_CONN: err_enum_t = -11;
#[doc = " Low-level netif error"]
pub const err_enum_t_ERR_IF: err_enum_t = -12;
#[doc = " Connection aborted."]
pub const err_enum_t_ERR_ABRT: err_enum_t = -13;
#[doc = " Connection reset."]
pub const err_enum_t_ERR_RST: err_enum_t = -14;
#[doc = " Connection closed."]
pub const err_enum_t_ERR_CLSD: err_enum_t = -15;
#[doc = " Illegal argument."]
pub const err_enum_t_ERR_ARG: err_enum_t = -16;
#[doc = " Definitions for error constants."]
pub type err_enum_t = libc::c_int;
pub type err_t = s8_t;
extern "C" {
    pub fn lwip_strerr(err: err_t) -> *const libc::c_char;
}
extern "C" {
    pub fn err_to_errno(err: err_t) -> libc::c_int;
}
extern "C" {
    pub fn lwip_htons(x: u16_t) -> u16_t;
}
extern "C" {
    pub fn lwip_htonl(x: u32_t) -> u32_t;
}
extern "C" {
    pub fn lwip_itoa(result: *mut libc::c_char, bufsize: usize, number: libc::c_int);
}
extern "C" {
    pub fn lwip_strnicmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn lwip_stricmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn lwip_strnstr(
        buffer: *const libc::c_char,
        token: *const libc::c_char,
        n: usize,
    ) -> *mut libc::c_char;
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip4_addr {
    pub addr: u32_t,
}
#[test]
fn bindgen_test_layout_ip4_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ip4_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip4_addr>(),
        4usize,
        concat!("Size of: ", stringify!(ip4_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip4_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip4_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip4_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " This is the aligned version of ip4_addr_t,\nused as local variable, on the stack, etc."]
pub type ip4_addr_t = ip4_addr;
extern "C" {
    pub fn ip4_addr_isbroadcast_u32(addr: u32_t, netif: *const netif) -> u8_t;
}
extern "C" {
    pub fn ip4_addr_netmask_valid(netmask: u32_t) -> u8_t;
}
extern "C" {
    pub fn ipaddr_addr(cp: *const libc::c_char) -> u32_t;
}
extern "C" {
    pub fn ip4addr_aton(cp: *const libc::c_char, addr: *mut ip4_addr_t) -> libc::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip4addr_ntoa(addr: *const ip4_addr_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn ip4addr_ntoa_r(
        addr: *const ip4_addr_t,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> *mut libc::c_char;
}
#[doc = " This is the aligned version of ip6_addr_t,\nused as local variable, on the stack, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ip6_addr {
    pub addr: [u32_t; 4usize],
}
#[test]
fn bindgen_test_layout_ip6_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ip6_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(ip6_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip6_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip6_addr),
            "::",
            stringify!(addr)
        )
    );
}
#[doc = " This is the aligned version of ip6_addr_t,\nused as local variable, on the stack, etc."]
pub type ip6_addr_t = ip6_addr;
extern "C" {
    pub fn ip6addr_aton(cp: *const libc::c_char, addr: *mut ip6_addr_t) -> libc::c_int;
}
extern "C" {
    #[doc = " returns ptr to static buffer; not reentrant!"]
    pub fn ip6addr_ntoa(addr: *const ip6_addr_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn ip6addr_ntoa_r(
        addr: *const ip6_addr_t,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> *mut libc::c_char;
}
#[doc = " IPv4"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V4: lwip_ip_addr_type = 0;
#[doc = " IPv6"]
pub const lwip_ip_addr_type_IPADDR_TYPE_V6: lwip_ip_addr_type = 6;
#[doc = " IPv4+IPv6 (\"dual-stack\")"]
pub const lwip_ip_addr_type_IPADDR_TYPE_ANY: lwip_ip_addr_type = 46;
#[doc = " @ingroup ipaddr\n IP address types for use in ip_addr_t.type member.\n @see tcp_new_ip_type(), udp_new_ip_type(), raw_new_ip_type()."]
pub type lwip_ip_addr_type = libc::c_int;
#[doc = " @ingroup ipaddr\n A union struct for both IP version's addresses.\n ATTENTION: watch out for its size when adding IPv6 address scope!"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ip_addr {
    pub u_addr: ip_addr__bindgen_ty_1,
    #[doc = " @ref lwip_ip_addr_type"]
    pub type_: u8_t,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ip_addr__bindgen_ty_1 {
    pub ip6: ip6_addr_t,
    pub ip4: ip4_addr_t,
}
#[test]
fn bindgen_test_layout_ip_addr__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<ip_addr__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
}
#[test]
fn bindgen_test_layout_ip_addr() {
    const UNINIT: ::core::mem::MaybeUninit<ip_addr> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<ip_addr>(),
        20usize,
        concat!("Size of: ", stringify!(ip_addr))
    );
    assert_eq!(
        ::core::mem::align_of::<ip_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(ip_addr))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr),
            "::",
            stringify!(u_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ip_addr),
            "::",
            stringify!(type_)
        )
    );
}
#[doc = " @ingroup ipaddr\n A union struct for both IP version's addresses.\n ATTENTION: watch out for its size when adding IPv6 address scope!"]
pub type ip_addr_t = ip_addr;
extern "C" {
    pub static ip_addr_any_type: ip_addr_t;
}
extern "C" {
    pub fn ipaddr_ntoa(addr: *const ip_addr_t) -> *mut libc::c_char;
}
extern "C" {
    pub fn ipaddr_ntoa_r(
        addr: *const ip_addr_t,
        buf: *mut libc::c_char,
        buflen: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn ipaddr_aton(cp: *const libc::c_char, addr: *mut ip_addr_t) -> libc::c_int;
}
extern "C" {
    pub static ip_addr_any: ip_addr_t;
}
extern "C" {
    pub static ip_addr_broadcast: ip_addr_t;
}
extern "C" {
    pub static ip6_addr_any: ip_addr_t;
}
#[doc = " Includes spare room for transport layer header, e.g. UDP header.\n Use this if you intend to pass the pbuf to functions like udp_send()."]
pub const pbuf_layer_PBUF_TRANSPORT: pbuf_layer = 76;
#[doc = " Includes spare room for IP header.\n Use this if you intend to pass the pbuf to functions like raw_send()."]
pub const pbuf_layer_PBUF_IP: pbuf_layer = 56;
#[doc = " Includes spare room for link layer header (ethernet header).\n Use this if you intend to pass the pbuf to functions like ethernet_output().\n @see PBUF_LINK_HLEN"]
pub const pbuf_layer_PBUF_LINK: pbuf_layer = 16;
#[doc = " Includes spare room for additional encapsulation header before ethernet\n headers (e.g. 802.11).\n Use this if you intend to pass the pbuf to functions like netif->linkoutput().\n @see PBUF_LINK_ENCAPSULATION_HLEN"]
pub const pbuf_layer_PBUF_RAW_TX: pbuf_layer = 0;
#[doc = " Use this for input packets in a netif driver when calling netif->input()\n in the most common case - ethernet-layer netif driver."]
pub const pbuf_layer_PBUF_RAW: pbuf_layer = 0;
#[doc = " @ingroup pbuf\n Enumeration of pbuf layers"]
pub type pbuf_layer = libc::c_int;
#[doc = " pbuf data is stored in RAM, used for TX mostly, struct pbuf and its payload\nare allocated in one piece of contiguous memory (so the first payload byte\ncan be calculated from struct pbuf).\npbuf_alloc() allocates PBUF_RAM pbufs as unchained pbufs (although that might\nchange in future versions).\nThis should be used for all OUTGOING packets (TX)."]
pub const pbuf_type_PBUF_RAM: pbuf_type = 640;
#[doc = " pbuf data is stored in ROM, i.e. struct pbuf and its payload are located in\ntotally different memory areas. Since it points to ROM, payload does not\nhave to be copied when queued for transmission."]
pub const pbuf_type_PBUF_ROM: pbuf_type = 1;
#[doc = " pbuf comes from the pbuf pool. Much like PBUF_ROM but payload might change\nso it has to be duplicated when queued before transmitting, depending on\nwho has a 'ref' to it."]
pub const pbuf_type_PBUF_REF: pbuf_type = 65;
#[doc = " pbuf payload refers to RAM. This one comes from a pool and should be used\nfor RX. Payload can be chained (scatter-gather RX) but like PBUF_RAM, struct\npbuf and its payload are allocated in one piece of contiguous memory (so\nthe first payload byte can be calculated from struct pbuf).\nDon't use this for TX, if the pool becomes empty e.g. because of TCP queuing,\nyou are unable to receive TCP acks!"]
pub const pbuf_type_PBUF_POOL: pbuf_type = 386;
#[doc = " @ingroup pbuf\n Enumeration of pbuf types"]
pub type pbuf_type = libc::c_int;
#[doc = " Main packet buffer struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *mut libc::c_void,
    #[doc = " total length of this buffer and all next buffers in chain\n belonging to the same packet.\n\n For non-queue packet chains this is the invariant:\n p->tot_len == p->len + (p->next? p->next->tot_len: 0)"]
    pub tot_len: u16_t,
    #[doc = " length of this buffer"]
    pub len: u16_t,
    #[doc = " a bit field indicating pbuf type and allocation sources\n(see PBUF_TYPE_FLAG_*, PBUF_ALLOC_FLAG_* and PBUF_TYPE_ALLOC_SRC_MASK)"]
    pub type_internal: u8_t,
    #[doc = " misc flags"]
    pub flags: u8_t,
    #[doc = " the reference count always equals the number of pointers\n that refer to this pbuf. This can be pointers from an application,\n the stack itself, or pbuf->next pointers from a chain."]
    pub ref_: u8_t,
    #[doc = " For incoming packets, this contains the input netif's index"]
    pub if_idx: u8_t,
}
#[test]
fn bindgen_test_layout_pbuf() {
    const UNINIT: ::core::mem::MaybeUninit<pbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pbuf>(),
        16usize,
        concat!("Size of: ", stringify!(pbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<pbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(pbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tot_len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(tot_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        10usize,
        concat!("Offset of field: ", stringify!(pbuf), "::", stringify!(len))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_internal) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(type_internal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).if_idx) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf),
            "::",
            stringify!(if_idx)
        )
    );
}
#[doc = " Helper struct for const-correctness only.\n The only meaning of this one is to provide a const payload pointer\n for PBUF_ROM type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_rom {
    #[doc = " next pbuf in singly linked pbuf chain"]
    pub next: *mut pbuf,
    #[doc = " pointer to the actual data in the buffer"]
    pub payload: *const libc::c_void,
}
#[test]
fn bindgen_test_layout_pbuf_rom() {
    const UNINIT: ::core::mem::MaybeUninit<pbuf_rom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pbuf_rom>(),
        8usize,
        concat!("Size of: ", stringify!(pbuf_rom))
    );
    assert_eq!(
        ::core::mem::align_of::<pbuf_rom>(),
        4usize,
        concat!("Alignment of ", stringify!(pbuf_rom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_rom),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_rom),
            "::",
            stringify!(payload)
        )
    );
}
#[doc = " Prototype for a function to free a custom pbuf"]
pub type pbuf_free_custom_fn = ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf)>;
#[doc = " A custom pbuf: like a pbuf, but following a function pointer to free it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pbuf_custom {
    #[doc = " The actual pbuf"]
    pub pbuf: pbuf,
    #[doc = " This function is called when pbuf_free deallocates this pbuf(_custom)"]
    pub custom_free_function: pbuf_free_custom_fn,
}
#[test]
fn bindgen_test_layout_pbuf_custom() {
    const UNINIT: ::core::mem::MaybeUninit<pbuf_custom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pbuf_custom>(),
        20usize,
        concat!("Size of: ", stringify!(pbuf_custom))
    );
    assert_eq!(
        ::core::mem::align_of::<pbuf_custom>(),
        4usize,
        concat!("Alignment of ", stringify!(pbuf_custom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pbuf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_custom),
            "::",
            stringify!(pbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom_free_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pbuf_custom),
            "::",
            stringify!(custom_free_function)
        )
    );
}
extern "C" {
    pub fn pbuf_alloc(l: pbuf_layer, length: u16_t, type_: pbuf_type) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloc_reference(
        payload: *mut libc::c_void,
        length: u16_t,
        type_: pbuf_type,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_alloced_custom(
        l: pbuf_layer,
        length: u16_t,
        type_: pbuf_type,
        p: *mut pbuf_custom,
        payload_mem: *mut libc::c_void,
        payload_mem_len: u16_t,
    ) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_realloc(p: *mut pbuf, size: u16_t);
}
extern "C" {
    pub fn pbuf_header(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_header_force(p: *mut pbuf, header_size: s16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_add_header_force(p: *mut pbuf, header_size_increment: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_remove_header(p: *mut pbuf, header_size: usize) -> u8_t;
}
extern "C" {
    pub fn pbuf_free_header(q: *mut pbuf, size: u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_ref(p: *mut pbuf);
}
extern "C" {
    pub fn pbuf_free(p: *mut pbuf) -> u8_t;
}
extern "C" {
    pub fn pbuf_clen(p: *const pbuf) -> u16_t;
}
extern "C" {
    pub fn pbuf_cat(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_chain(head: *mut pbuf, tail: *mut pbuf);
}
extern "C" {
    pub fn pbuf_dechain(p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_copy(p_to: *mut pbuf, p_from: *const pbuf) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial_pbuf(
        p_to: *mut pbuf,
        p_from: *const pbuf,
        copy_len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_copy_partial(
        p: *const pbuf,
        dataptr: *mut libc::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_get_contiguous(
        p: *const pbuf,
        buffer: *mut libc::c_void,
        bufsize: usize,
        len: u16_t,
        offset: u16_t,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn pbuf_take(buf: *mut pbuf, dataptr: *const libc::c_void, len: u16_t) -> err_t;
}
extern "C" {
    pub fn pbuf_take_at(
        buf: *mut pbuf,
        dataptr: *const libc::c_void,
        len: u16_t,
        offset: u16_t,
    ) -> err_t;
}
extern "C" {
    pub fn pbuf_skip(in_: *mut pbuf, in_offset: u16_t, out_offset: *mut u16_t) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_coalesce(p: *mut pbuf, layer: pbuf_layer) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_clone(l: pbuf_layer, type_: pbuf_type, p: *mut pbuf) -> *mut pbuf;
}
extern "C" {
    pub fn pbuf_get_at(p: *const pbuf, offset: u16_t) -> u8_t;
}
extern "C" {
    pub fn pbuf_try_get_at(p: *const pbuf, offset: u16_t) -> libc::c_int;
}
extern "C" {
    pub fn pbuf_put_at(p: *mut pbuf, offset: u16_t, data: u8_t);
}
extern "C" {
    pub fn pbuf_memcmp(p: *const pbuf, offset: u16_t, s2: *const libc::c_void, n: u16_t) -> u16_t;
}
extern "C" {
    pub fn pbuf_memfind(
        p: *const pbuf,
        mem: *const libc::c_void,
        mem_len: u16_t,
        start_offset: u16_t,
    ) -> u16_t;
}
extern "C" {
    pub fn pbuf_strstr(p: *const pbuf, substr: *const libc::c_char) -> u16_t;
}
pub type mem_size_t = usize;
extern "C" {
    pub fn mem_init();
}
extern "C" {
    pub fn mem_trim(mem: *mut libc::c_void, size: mem_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn mem_malloc(size: mem_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn mem_calloc(count: mem_size_t, size: mem_size_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn mem_free(mem: *mut libc::c_void);
}
pub const memp_t_MEMP_RAW_PCB: memp_t = 0;
pub const memp_t_MEMP_UDP_PCB: memp_t = 1;
pub const memp_t_MEMP_TCP_PCB: memp_t = 2;
pub const memp_t_MEMP_TCP_PCB_LISTEN: memp_t = 3;
pub const memp_t_MEMP_TCP_SEG: memp_t = 4;
pub const memp_t_MEMP_REASSDATA: memp_t = 5;
pub const memp_t_MEMP_FRAG_PBUF: memp_t = 6;
pub const memp_t_MEMP_NETBUF: memp_t = 7;
pub const memp_t_MEMP_NETCONN: memp_t = 8;
pub const memp_t_MEMP_TCPIP_MSG_API: memp_t = 9;
pub const memp_t_MEMP_SYS_TIMEOUT: memp_t = 10;
pub const memp_t_MEMP_NETDB: memp_t = 11;
pub const memp_t_MEMP_ND6_QUEUE: memp_t = 12;
pub const memp_t_MEMP_IP6_REASSDATA: memp_t = 13;
pub const memp_t_MEMP_MLD6_GROUP: memp_t = 14;
pub const memp_t_MEMP_PBUF: memp_t = 15;
pub const memp_t_MEMP_PBUF_POOL: memp_t = 16;
pub const memp_t_MEMP_MAX: memp_t = 17;
#[doc = " Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end"]
pub type memp_t = libc::c_int;
#[doc = " Memory pool descriptor"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct memp_desc {
    #[doc = " Textual description"]
    pub desc: *const libc::c_char,
    #[doc = " Element size"]
    pub size: u16_t,
}
#[test]
fn bindgen_test_layout_memp_desc() {
    const UNINIT: ::core::mem::MaybeUninit<memp_desc> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<memp_desc>(),
        8usize,
        concat!("Size of: ", stringify!(memp_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<memp_desc>(),
        4usize,
        concat!("Alignment of ", stringify!(memp_desc))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).desc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(memp_desc),
            "::",
            stringify!(desc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(memp_desc),
            "::",
            stringify!(size)
        )
    );
}
extern "C" {
    pub fn memp_init_pool(desc: *const memp_desc);
}
extern "C" {
    pub fn memp_malloc_pool(desc: *const memp_desc) -> *mut libc::c_void;
}
extern "C" {
    pub fn memp_free_pool(desc: *const memp_desc, mem: *mut libc::c_void);
}
extern "C" {
    pub static memp_pools: [*const memp_desc; 17usize];
}
extern "C" {
    pub fn memp_init();
}
extern "C" {
    pub fn memp_malloc(type_: memp_t) -> *mut libc::c_void;
}
extern "C" {
    pub fn memp_free(type_: memp_t, mem: *mut libc::c_void);
}
#[doc = " Protocol related stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_proto {
    pub xmit: u16_t,
    pub recv: u16_t,
    pub fw: u16_t,
    pub drop: u16_t,
    pub chkerr: u16_t,
    pub lenerr: u16_t,
    pub memerr: u16_t,
    pub rterr: u16_t,
    pub proterr: u16_t,
    pub opterr: u16_t,
    pub err: u16_t,
    pub cachehit: u16_t,
}
#[test]
fn bindgen_test_layout_stats_proto() {
    const UNINIT: ::core::mem::MaybeUninit<stats_proto> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_proto>(),
        24usize,
        concat!("Size of: ", stringify!(stats_proto))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_proto>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_proto))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(xmit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fw) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(fw)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chkerr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(chkerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenerr) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(lenerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memerr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(memerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rterr) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(rterr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proterr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(proterr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).opterr) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(opterr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cachehit) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_proto),
            "::",
            stringify!(cachehit)
        )
    );
}
#[doc = " IGMP stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_igmp {
    pub xmit: u16_t,
    pub recv: u16_t,
    pub drop: u16_t,
    pub chkerr: u16_t,
    pub lenerr: u16_t,
    pub memerr: u16_t,
    pub proterr: u16_t,
    pub rx_v1: u16_t,
    pub rx_group: u16_t,
    pub rx_general: u16_t,
    pub rx_report: u16_t,
    pub tx_join: u16_t,
    pub tx_leave: u16_t,
    pub tx_report: u16_t,
}
#[test]
fn bindgen_test_layout_stats_igmp() {
    const UNINIT: ::core::mem::MaybeUninit<stats_igmp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_igmp>(),
        28usize,
        concat!("Size of: ", stringify!(stats_igmp))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_igmp>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_igmp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xmit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(xmit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recv) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(recv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).chkerr) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(chkerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lenerr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(lenerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).memerr) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(memerr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).proterr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(proterr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_v1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_v1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_group) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_group)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_general) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_general)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_report) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(rx_report)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_join) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_join)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_leave) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_leave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_report) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_igmp),
            "::",
            stringify!(tx_report)
        )
    );
}
#[doc = " Memory stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mem {
    pub name: *const libc::c_char,
    pub err: u16_t,
    pub avail: mem_size_t,
    pub used: mem_size_t,
    pub max: mem_size_t,
    pub illegal: u16_t,
}
#[test]
fn bindgen_test_layout_stats_mem() {
    const UNINIT: ::core::mem::MaybeUninit<stats_mem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_mem>(),
        24usize,
        concat!("Size of: ", stringify!(stats_mem))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_mem>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_mem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).avail) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(avail)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).illegal) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mem),
            "::",
            stringify!(illegal)
        )
    );
}
#[doc = " System element stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_syselem {
    pub used: u16_t,
    pub max: u16_t,
    pub err: u16_t,
}
#[test]
fn bindgen_test_layout_stats_syselem() {
    const UNINIT: ::core::mem::MaybeUninit<stats_syselem> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_syselem>(),
        6usize,
        concat!("Size of: ", stringify!(stats_syselem))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_syselem>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_syselem))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).used) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(used)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).err) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_syselem),
            "::",
            stringify!(err)
        )
    );
}
#[doc = " System stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_sys {
    pub sem: stats_syselem,
    pub mutex: stats_syselem,
    pub mbox: stats_syselem,
}
#[test]
fn bindgen_test_layout_stats_sys() {
    const UNINIT: ::core::mem::MaybeUninit<stats_sys> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_sys>(),
        18usize,
        concat!("Size of: ", stringify!(stats_sys))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_sys>(),
        2usize,
        concat!("Alignment of ", stringify!(stats_sys))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(sem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mutex) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mbox) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_sys),
            "::",
            stringify!(mbox)
        )
    );
}
#[doc = " SNMP MIB2 stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mib2 {
    pub ipinhdrerrors: u32_t,
    pub ipinaddrerrors: u32_t,
    pub ipinunknownprotos: u32_t,
    pub ipindiscards: u32_t,
    pub ipindelivers: u32_t,
    pub ipoutrequests: u32_t,
    pub ipoutdiscards: u32_t,
    pub ipoutnoroutes: u32_t,
    pub ipreasmoks: u32_t,
    pub ipreasmfails: u32_t,
    pub ipfragoks: u32_t,
    pub ipfragfails: u32_t,
    pub ipfragcreates: u32_t,
    pub ipreasmreqds: u32_t,
    pub ipforwdatagrams: u32_t,
    pub ipinreceives: u32_t,
    pub tcpactiveopens: u32_t,
    pub tcppassiveopens: u32_t,
    pub tcpattemptfails: u32_t,
    pub tcpestabresets: u32_t,
    pub tcpoutsegs: u32_t,
    pub tcpretranssegs: u32_t,
    pub tcpinsegs: u32_t,
    pub tcpinerrs: u32_t,
    pub tcpoutrsts: u32_t,
    pub udpindatagrams: u32_t,
    pub udpnoports: u32_t,
    pub udpinerrors: u32_t,
    pub udpoutdatagrams: u32_t,
    pub icmpinmsgs: u32_t,
    pub icmpinerrors: u32_t,
    pub icmpindestunreachs: u32_t,
    pub icmpintimeexcds: u32_t,
    pub icmpinparmprobs: u32_t,
    pub icmpinsrcquenchs: u32_t,
    pub icmpinredirects: u32_t,
    pub icmpinechos: u32_t,
    pub icmpinechoreps: u32_t,
    pub icmpintimestamps: u32_t,
    pub icmpintimestampreps: u32_t,
    pub icmpinaddrmasks: u32_t,
    pub icmpinaddrmaskreps: u32_t,
    pub icmpoutmsgs: u32_t,
    pub icmpouterrors: u32_t,
    pub icmpoutdestunreachs: u32_t,
    pub icmpouttimeexcds: u32_t,
    pub icmpoutechos: u32_t,
    pub icmpoutechoreps: u32_t,
}
#[test]
fn bindgen_test_layout_stats_mib2() {
    const UNINIT: ::core::mem::MaybeUninit<stats_mib2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_mib2>(),
        192usize,
        concat!("Size of: ", stringify!(stats_mib2))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_mib2>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_mib2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipinhdrerrors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinhdrerrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipinaddrerrors) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinaddrerrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipinunknownprotos) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinunknownprotos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipindiscards) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipindiscards)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipindelivers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipindelivers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipoutrequests) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutrequests)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipoutdiscards) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutdiscards)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipoutnoroutes) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipoutnoroutes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipreasmoks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmoks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipreasmfails) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmfails)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipfragoks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragoks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipfragfails) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragfails)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipfragcreates) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipfragcreates)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipreasmreqds) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipreasmreqds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipforwdatagrams) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipforwdatagrams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipinreceives) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(ipinreceives)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpactiveopens) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpactiveopens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcppassiveopens) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcppassiveopens)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpattemptfails) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpattemptfails)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpestabresets) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpestabresets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpoutsegs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpoutsegs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpretranssegs) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpretranssegs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpinsegs) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpinsegs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpinerrs) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpinerrs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcpoutrsts) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(tcpoutrsts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udpindatagrams) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpindatagrams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udpnoports) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpnoports)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udpinerrors) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpinerrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udpoutdatagrams) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(udpoutdatagrams)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinmsgs) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinmsgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinerrors) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinerrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpindestunreachs) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpindestunreachs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpintimeexcds) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimeexcds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinparmprobs) as usize - ptr as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinparmprobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinsrcquenchs) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinsrcquenchs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinredirects) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinredirects)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinechos) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinechos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinechoreps) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinechoreps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpintimestamps) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimestamps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpintimestampreps) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpintimestampreps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinaddrmasks) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinaddrmasks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpinaddrmaskreps) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpinaddrmaskreps)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpoutmsgs) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutmsgs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpouterrors) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpouterrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpoutdestunreachs) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutdestunreachs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpouttimeexcds) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpouttimeexcds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpoutechos) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutechos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmpoutechoreps) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2),
            "::",
            stringify!(icmpoutechoreps)
        )
    );
}
#[doc = " @ingroup netif_mib2\n SNMP MIB2 interface stats"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_mib2_netif_ctrs {
    #[doc = " The total number of octets received on the interface, including framing characters"]
    pub ifinoctets: u32_t,
    #[doc = " The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were\n not addressed to a multicast or broadcast address at this sub-layer"]
    pub ifinucastpkts: u32_t,
    #[doc = " The number of packets, delivered by this sub-layer to a higher (sub-)layer, which were\n addressed to a multicast or broadcast address at this sub-layer"]
    pub ifinnucastpkts: u32_t,
    #[doc = " The number of inbound packets which were chosen to be discarded even though no errors had\n been detected to prevent their being deliverable to a higher-layer protocol. One possible\n reason for discarding such a packet could be to free up buffer space"]
    pub ifindiscards: u32_t,
    #[doc = " For packet-oriented interfaces, the number of inbound packets that contained errors\n preventing them from being deliverable to a higher-layer protocol.  For character-\n oriented or fixed-length interfaces, the number of inbound transmission units that\n contained errors preventing them from being deliverable to a higher-layer protocol."]
    pub ifinerrors: u32_t,
    #[doc = " For packet-oriented interfaces, the number of packets received via the interface which\n were discarded because of an unknown or unsupported protocol.  For character-oriented\n or fixed-length interfaces that support protocol multiplexing the number of transmission\n units received via the interface which were discarded because of an unknown or unsupported\n protocol. For any interface that does not support protocol multiplexing, this counter will\n always be 0"]
    pub ifinunknownprotos: u32_t,
    #[doc = " The total number of octets transmitted out of the interface, including framing characters."]
    pub ifoutoctets: u32_t,
    #[doc = " The total number of packets that higher-level protocols requested be transmitted, and\n which were not addressed to a multicast or broadcast address at this sub-layer, including\n those that were discarded or not sent."]
    pub ifoutucastpkts: u32_t,
    #[doc = " The total number of packets that higher-level protocols requested be transmitted, and which\n were addressed to a multicast or broadcast address at this sub-layer, including\n those that were discarded or not sent."]
    pub ifoutnucastpkts: u32_t,
    #[doc = " The number of outbound packets which were chosen to be discarded even though no errors had\n been detected to prevent their being transmitted.  One possible reason for discarding\n such a packet could be to free up buffer space."]
    pub ifoutdiscards: u32_t,
    #[doc = " For packet-oriented interfaces, the number of outbound packets that could not be transmitted\n because of errors. For character-oriented or fixed-length interfaces, the number of outbound\n transmission units that could not be transmitted because of errors."]
    pub ifouterrors: u32_t,
}
#[test]
fn bindgen_test_layout_stats_mib2_netif_ctrs() {
    const UNINIT: ::core::mem::MaybeUninit<stats_mib2_netif_ctrs> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_mib2_netif_ctrs>(),
        44usize,
        concat!("Size of: ", stringify!(stats_mib2_netif_ctrs))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_mib2_netif_ctrs>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_mib2_netif_ctrs))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifinoctets) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinoctets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifinucastpkts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinucastpkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifinnucastpkts) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinnucastpkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifindiscards) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifindiscards)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifinerrors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinerrors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifinunknownprotos) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifinunknownprotos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifoutoctets) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutoctets)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifoutucastpkts) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutucastpkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifoutnucastpkts) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutnucastpkts)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifoutdiscards) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifoutdiscards)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifouterrors) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_mib2_netif_ctrs),
            "::",
            stringify!(ifouterrors)
        )
    );
}
#[doc = " lwIP stats container"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct stats_ {
    #[doc = " Link level"]
    pub link: stats_proto,
    #[doc = " ARP"]
    pub etharp: stats_proto,
    #[doc = " Fragmentation"]
    pub ip_frag: stats_proto,
    #[doc = " IP"]
    pub ip: stats_proto,
    #[doc = " ICMP"]
    pub icmp: stats_proto,
    #[doc = " UDP"]
    pub udp: stats_proto,
    #[doc = " TCP"]
    pub tcp: stats_proto,
    #[doc = " System"]
    pub sys: stats_sys,
    #[doc = " IPv6"]
    pub ip6: stats_proto,
    #[doc = " ICMP6"]
    pub icmp6: stats_proto,
    #[doc = " IPv6 fragmentation"]
    pub ip6_frag: stats_proto,
    #[doc = " Multicast listener discovery"]
    pub mld6: stats_igmp,
    #[doc = " Neighbor discovery"]
    pub nd6: stats_proto,
    #[doc = " SNMP MIB2"]
    pub mib2: stats_mib2,
}
#[test]
fn bindgen_test_layout_stats_() {
    const UNINIT: ::core::mem::MaybeUninit<stats_> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<stats_>(),
        504usize,
        concat!("Size of: ", stringify!(stats_))
    );
    assert_eq!(
        ::core::mem::align_of::<stats_>(),
        4usize,
        concat!("Alignment of ", stringify!(stats_))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(link)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).etharp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(etharp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_frag) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip_frag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(icmp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).udp) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(udp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tcp) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(tcp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sys) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(sys)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6) as usize - ptr as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icmp6) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(icmp6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_frag) as usize - ptr as usize },
        234usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(ip6_frag)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mld6) as usize - ptr as usize },
        258usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(mld6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nd6) as usize - ptr as usize },
        286usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(nd6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mib2) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(stats_),
            "::",
            stringify!(mib2)
        )
    );
}
extern "C" {
    #[doc = " Global variable containing lwIP internal statistics. Add this to your debugger's watchlist."]
    pub static mut lwip_stats: stats_;
}
extern "C" {
    #[doc = " Init statistics"]
    pub fn stats_init();
}
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_DHCP:
    lwip_internal_netif_client_data_index = 0;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_AUTOIP:
    lwip_internal_netif_client_data_index = 1;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_DHCP6:
    lwip_internal_netif_client_data_index = 2;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MLD6:
    lwip_internal_netif_client_data_index = 3;
pub const lwip_internal_netif_client_data_index_LWIP_NETIF_CLIENT_DATA_INDEX_MAX:
    lwip_internal_netif_client_data_index = 4;
#[doc = " @}"]
pub type lwip_internal_netif_client_data_index = libc::c_int;
#[doc = " Delete a filter entry"]
pub const netif_mac_filter_action_NETIF_DEL_MAC_FILTER: netif_mac_filter_action = 0;
#[doc = " Add a filter entry"]
pub const netif_mac_filter_action_NETIF_ADD_MAC_FILTER: netif_mac_filter_action = 1;
#[doc = " MAC Filter Actions, these are passed to a netif's igmp_mac_filter or\n mld_mac_filter callback function."]
pub type netif_mac_filter_action = libc::c_int;
#[doc = " Function prototype for netif init functions. Set up flags and output/linkoutput\n callback functions in this function.\n\n @param netif The netif to initialize"]
pub type netif_init_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->input functions. This function is saved as 'input'\n callback function in the netif struct. Call it when a packet has been received.\n\n @param p The received packet, copied into a pbuf\n @param inp The netif which received the packet\n @return ERR_OK if the packet was handled\n         != ERR_OK is the packet was NOT handled, in this case, the caller has\n                   to free the pbuf"]
pub type netif_input_fn =
    ::core::option::Option<unsafe extern "C" fn(p: *mut pbuf, inp: *mut netif) -> err_t>;
#[doc = " Function prototype for netif->output functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'etharp_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IP address to which the packet shall be sent"]
pub type netif_output_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip4_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->output_ip6 functions. Called by lwIP when a packet\n shall be sent. For ethernet netif, set this to 'ethip6_output' and set\n 'linkoutput'.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (p->payload points to IP header)\n @param ipaddr The IPv6 address to which the packet shall be sent"]
pub type netif_output_ip6_fn = ::core::option::Option<
    unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf, ipaddr: *const ip6_addr_t) -> err_t,
>;
#[doc = " Function prototype for netif->linkoutput functions. Only used for ethernet\n netifs. This function is called by ARP when a packet shall be sent.\n\n @param netif The netif which shall send a packet\n @param p The packet to send (raw ethernet packet)"]
pub type netif_linkoutput_fn =
    ::core::option::Option<unsafe extern "C" fn(netif: *mut netif, p: *mut pbuf) -> err_t>;
#[doc = " Function prototype for netif status- or link-callback functions."]
pub type netif_status_callback_fn = ::core::option::Option<unsafe extern "C" fn(netif: *mut netif)>;
#[doc = " Function prototype for netif mld_mac_filter functions"]
pub type netif_mld_mac_filter_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        group: *const ip6_addr_t,
        action: netif_mac_filter_action,
    ) -> err_t,
>;
pub type netif_addr_idx_t = u8_t;
#[doc = " Generic data structure used for all lwIP network interfaces.\n  The following fields should be filled in by the initialization\n  function for the device driver: hwaddr_len, hwaddr[], mtu, flags"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct netif {
    #[doc = " IP address configuration in network byte order"]
    pub ip_addr: ip_addr_t,
    pub netmask: ip_addr_t,
    pub gw: ip_addr_t,
    #[doc = " Array of IPv6 addresses for this netif."]
    pub ip6_addr: [ip_addr_t; 3usize],
    #[doc = " The state of each IPv6 address (Tentative, Preferred, etc).\n @see ip6_addr.h"]
    pub ip6_addr_state: [u8_t; 3usize],
    #[doc = " Remaining valid and preferred lifetime of each IPv6 address, in seconds.\n For valid lifetimes, the special value of IP6_ADDR_LIFE_STATIC (0)\n indicates the address is static and has no lifetimes."]
    pub ip6_addr_valid_life: [u32_t; 3usize],
    pub ip6_addr_pref_life: [u32_t; 3usize],
    #[doc = " This function is called by the network device driver\n  to pass a packet up the TCP/IP stack."]
    pub input: netif_input_fn,
    #[doc = " This function is called by the IP module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually etharp_output()"]
    pub output: netif_output_fn,
    #[doc = " This function is called by ethernet_output() when it wants\n  to send a packet on the interface. This function outputs\n  the pbuf as-is on the link medium."]
    pub linkoutput: netif_linkoutput_fn,
    #[doc = " This function is called by the IPv6 module when it wants\n  to send a packet on the interface. This function typically\n  first resolves the hardware address, then sends the packet.\n  For ethernet physical layer, this is usually ethip6_output()"]
    pub output_ip6: netif_output_ip6_fn,
    #[doc = " This field can be set by the device driver and could point\n  to state information for the device."]
    pub state: *mut libc::c_void,
    pub client_data: [*mut libc::c_void; 4usize],
    #[doc = " maximum transfer unit (in bytes)"]
    pub mtu: u16_t,
    #[doc = " maximum transfer unit (in bytes), updated by RA"]
    pub mtu6: u16_t,
    #[doc = " link level hardware address of this interface"]
    pub hwaddr: [u8_t; 6usize],
    #[doc = " number of bytes used in hwaddr"]
    pub hwaddr_len: u8_t,
    #[doc = " flags (@see @ref netif_flags)"]
    pub flags: u8_t,
    #[doc = " descriptive abbreviation"]
    pub name: [libc::c_char; 2usize],
    #[doc = " number of this interface. Used for @ref if_api and @ref netifapi_netif,\n as well as for IPv6 zones"]
    pub num: u8_t,
    #[doc = " is this netif enabled for IPv6 autoconfiguration"]
    pub ip6_autoconfig_enabled: u8_t,
    #[doc = " Number of Router Solicitation messages that remain to be sent."]
    pub rs_count: u8_t,
    #[doc = " link type (from \"snmp_ifType\" enum from snmp_mib2.h)"]
    pub link_type: u8_t,
    #[doc = " (estimate) link speed"]
    pub link_speed: u32_t,
    #[doc = " timestamp at last change made (up/down)"]
    pub ts: u32_t,
    #[doc = " counters"]
    pub mib2_counters: stats_mib2_netif_ctrs,
    #[doc = " This function could be called to add or delete an entry in the IPv6 multicast\nfilter table of the ethernet MAC."]
    pub mld_mac_filter: netif_mld_mac_filter_fn,
}
#[test]
fn bindgen_test_layout_netif() {
    const UNINIT: ::core::mem::MaybeUninit<netif> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif>(),
        260usize,
        concat!("Size of: ", stringify!(netif))
    );
    assert_eq!(
        ::core::mem::align_of::<netif>(),
        4usize,
        concat!("Alignment of ", stringify!(netif))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip_addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gw) as usize - ptr as usize },
        40usize,
        concat!("Offset of field: ", stringify!(netif), "::", stringify!(gw))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_addr) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_addr_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_addr_valid_life) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr_valid_life)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_addr_pref_life) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_addr_pref_life)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).input) as usize - ptr as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(input)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linkoutput) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(linkoutput)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_ip6) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(output_ip6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).client_data) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(client_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mtu6) as usize - ptr as usize },
        186usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mtu6)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hwaddr_len) as usize - ptr as usize },
        194usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(hwaddr_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        195usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        198usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6_autoconfig_enabled) as usize - ptr as usize },
        199usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(ip6_autoconfig_enabled)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rs_count) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(rs_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link_type) as usize - ptr as usize },
        201usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(link_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link_speed) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(link_speed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ts) as usize - ptr as usize },
        208usize,
        concat!("Offset of field: ", stringify!(netif), "::", stringify!(ts))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mib2_counters) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mib2_counters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mld_mac_filter) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(netif),
            "::",
            stringify!(mld_mac_filter)
        )
    );
}
extern "C" {
    #[doc = " The default network interface."]
    pub static mut netif_default: *mut netif;
}
extern "C" {
    pub fn netif_init();
}
extern "C" {
    pub fn netif_add_noaddr(
        netif: *mut netif,
        state: *mut libc::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_add(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
        state: *mut libc::c_void,
        init: netif_init_fn,
        input: netif_input_fn,
    ) -> *mut netif;
}
extern "C" {
    pub fn netif_set_addr(
        netif: *mut netif,
        ipaddr: *const ip4_addr_t,
        netmask: *const ip4_addr_t,
        gw: *const ip4_addr_t,
    );
}
extern "C" {
    pub fn netif_remove(netif: *mut netif);
}
extern "C" {
    pub fn netif_find(name: *const libc::c_char) -> *mut netif;
}
extern "C" {
    pub fn netif_set_default(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_ipaddr(netif: *mut netif, ipaddr: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_netmask(netif: *mut netif, netmask: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_gw(netif: *mut netif, gw: *const ip4_addr_t);
}
extern "C" {
    pub fn netif_set_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_up(netif: *mut netif);
}
extern "C" {
    pub fn netif_set_link_down(netif: *mut netif);
}
extern "C" {
    pub fn netif_input(p: *mut pbuf, inp: *mut netif) -> err_t;
}
extern "C" {
    pub fn netif_ip6_addr_set(netif: *mut netif, addr_idx: s8_t, addr6: *const ip6_addr_t);
}
extern "C" {
    pub fn netif_ip6_addr_set_parts(
        netif: *mut netif,
        addr_idx: s8_t,
        i0: u32_t,
        i1: u32_t,
        i2: u32_t,
        i3: u32_t,
    );
}
extern "C" {
    pub fn netif_ip6_addr_set_state(netif: *mut netif, addr_idx: s8_t, state: u8_t);
}
extern "C" {
    pub fn netif_get_ip6_addr_match(netif: *mut netif, ip6addr: *const ip6_addr_t) -> s8_t;
}
extern "C" {
    pub fn netif_create_ip6_linklocal_address(netif: *mut netif, from_mac_48bit: u8_t);
}
extern "C" {
    pub fn netif_add_ip6_address(
        netif: *mut netif,
        ip6addr: *const ip6_addr_t,
        chosen_idx: *mut s8_t,
    ) -> err_t;
}
extern "C" {
    pub fn netif_name_to_index(name: *const libc::c_char) -> u8_t;
}
extern "C" {
    pub fn netif_index_to_name(idx: u8_t, name: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn netif_get_by_index(idx: u8_t) -> *mut netif;
}
#[doc = " @ingroup netif\n Extended netif status callback (NSC) reasons flags.\n May be extended in the future!"]
pub type netif_nsc_reason_t = u16_t;
#[doc = " @ingroup netif\n Argument supplied to netif_ext_callback_fn."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union netif_ext_callback_args_t {
    pub link_changed: netif_ext_callback_args_t_link_changed_s,
    pub status_changed: netif_ext_callback_args_t_status_changed_s,
    pub ipv4_changed: netif_ext_callback_args_t_ipv4_changed_s,
    pub ipv6_set: netif_ext_callback_args_t_ipv6_set_s,
    pub ipv6_addr_state_changed: netif_ext_callback_args_t_ipv6_addr_state_changed_s,
}
#[doc = " Args to LWIP_NSC_LINK_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_link_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_link_changed_s() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t_link_changed_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t_link_changed_s>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_link_changed_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t_link_changed_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_link_changed_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_link_changed_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Args to LWIP_NSC_STATUS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_status_changed_s {
    #[doc = " 1: up; 0: down"]
    pub state: u8_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_status_changed_s() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t_status_changed_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t_status_changed_s>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_status_changed_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t_status_changed_s>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_status_changed_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_status_changed_s),
            "::",
            stringify!(state)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV4_ADDRESS_CHANGED|LWIP_NSC_IPV4_GATEWAY_CHANGED|LWIP_NSC_IPV4_NETMASK_CHANGED|LWIP_NSC_IPV4_SETTINGS_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv4_changed_s {
    #[doc = " Old IPv4 address"]
    pub old_address: *const ip_addr_t,
    pub old_netmask: *const ip_addr_t,
    pub old_gw: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv4_changed_s() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t_ipv4_changed_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t_ipv4_changed_s>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t_ipv4_changed_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_address)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_netmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_netmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_gw) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv4_changed_s),
            "::",
            stringify!(old_gw)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV6_SET callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_set_s {
    #[doc = " Index of changed IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address"]
    pub old_address: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv6_set_s() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t_ipv6_set_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t_ipv6_set_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t_ipv6_set_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s),
            "::",
            stringify!(addr_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_set_s),
            "::",
            stringify!(old_address)
        )
    );
}
#[doc = " Args to LWIP_NSC_IPV6_ADDR_STATE_CHANGED callback"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct netif_ext_callback_args_t_ipv6_addr_state_changed_s {
    #[doc = " Index of affected IPv6 address"]
    pub addr_index: s8_t,
    #[doc = " Old IPv6 address state"]
    pub old_state: u8_t,
    #[doc = " Affected IPv6 address"]
    pub address: *const ip_addr_t,
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t_ipv6_addr_state_changed_s() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t_ipv6_addr_state_changed_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t_ipv6_addr_state_changed_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr_index) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(addr_index)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).old_state) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(old_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t_ipv6_addr_state_changed_s),
            "::",
            stringify!(address)
        )
    );
}
#[test]
fn bindgen_test_layout_netif_ext_callback_args_t() {
    const UNINIT: ::core::mem::MaybeUninit<netif_ext_callback_args_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<netif_ext_callback_args_t>(),
        12usize,
        concat!("Size of: ", stringify!(netif_ext_callback_args_t))
    );
    assert_eq!(
        ::core::mem::align_of::<netif_ext_callback_args_t>(),
        4usize,
        concat!("Alignment of ", stringify!(netif_ext_callback_args_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).link_changed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(link_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status_changed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(status_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv4_changed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv4_changed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6_set) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv6_set)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ipv6_addr_state_changed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(netif_ext_callback_args_t),
            "::",
            stringify!(ipv6_addr_state_changed)
        )
    );
}
#[doc = " @ingroup netif\n Function used for extended netif status callbacks\n Note: When parsing reason argument, keep in mind that more reasons may be added in the future!\n @param netif netif that is affected by change\n @param reason change reason\n @param args depends on reason, see reason description"]
pub type netif_ext_callback_fn = ::core::option::Option<
    unsafe extern "C" fn(
        netif: *mut netif,
        reason: netif_nsc_reason_t,
        args: *const netif_ext_callback_args_t,
    ),
>;
pub type __builtin_va_list = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STATUS_LOCATION {
    pub _address: u8,
}
