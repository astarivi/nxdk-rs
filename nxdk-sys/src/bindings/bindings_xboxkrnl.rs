/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MAXDWORD: u32 = 4294967295;
pub const CONTEXT_X86: u32 = 65536;
pub const CONTEXT_i386: u32 = 65536;
pub const CONTEXT_CONTROL: u32 = 65537;
pub const CONTEXT_INTEGER: u32 = 65538;
pub const CONTEXT_SEGMENTS: u32 = 65540;
pub const CONTEXT_FLOATING_POINT: u32 = 65544;
pub const CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const INVALID_FILE_ATTRIBUTES: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const AV_PACK_NONE: u32 = 0;
pub const AV_PACK_STANDARD: u32 = 1;
pub const AV_PACK_RFU: u32 = 2;
pub const AV_PACK_SCART: u32 = 3;
pub const AV_PACK_HDTV: u32 = 4;
pub const AV_PACK_VGA: u32 = 5;
pub const AV_PACK_SVIDEO: u32 = 6;
pub const PAGE_SIZE: u32 = 4096;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_VALID_ATTRIBUTES: u32 = 498;
pub const LDT_TITLE: u32 = 0;
pub const LDT_LAUNCH_DASHBOARD: u32 = 1;
pub const LDT_FROM_DASHBOARD: u32 = 2;
pub const LDT_NONE: u32 = 4294967295;
pub const XBOX_HW_FLAG_INTERNAL_USB_HUB: u32 = 1;
pub const XBOX_HW_FLAG_DEVKIT_KERNEL: u32 = 2;
pub const XBOX_480P_MACROVISION_ENABLED: u32 = 4;
pub const XBOX_HW_FLAG_ARCADE: u32 = 8;
pub const XBOX_KEY_LENGTH: u32 = 16;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_CREATE_OPERATION: u32 = 8;
pub const IRP_READ_OPERATION: u32 = 16;
pub const IRP_WRITE_OPERATION: u32 = 32;
pub const IRP_CLOSE_OPERATION: u32 = 64;
pub const IRP_DEFER_IO_COMPLETION: u32 = 128;
pub const IRP_OB_QUERY_NAME: u32 = 256;
pub const IRP_UNLOCK_USER_BUFFER: u32 = 512;
pub const IRP_SCATTER_GATHER_OPERATION: u32 = 1024;
pub const IRP_UNMAP_SEGMENT_ARRAY: u32 = 2048;
pub const IRP_NO_CANCELIO: u32 = 4096;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const XNET_ETHERNET_LINK_ACTIVE: u32 = 1;
pub const XNET_ETHERNET_LINK_100MBPS: u32 = 2;
pub const XNET_ETHERNET_LINK_10MBPS: u32 = 4;
pub const XNET_ETHERNET_LINK_FULL_DUPLEX: u32 = 8;
pub const XNET_ETHERNET_LINK_HALF_DUPLEX: u32 = 16;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const IOCTL_DISK_BASE: u32 = 7;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_FOR_RECOVERY: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const FILE_COPY_STRUCTURED_STORAGE: u32 = 65;
pub const FILE_STRUCTURED_STORAGE: u32 = 1089;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const ERESOURCE_INCREMENT: u32 = 4;
pub const EVENT_INCREMENT: u32 = 1;
pub const EVENT_PAIR_INCREMENT: u32 = 1;
pub const LPC_RELEASE_WAIT_INCREMENT: u32 = 1;
pub const IO_NO_INCREMENT: u32 = 0;
pub const IO_CD_ROM_INCREMENT: u32 = 1;
pub const IO_DISK_INCREMENT: u32 = 1;
pub const IO_PARALLEL_INCREMENT: u32 = 1;
pub const IO_VIDEO_INCREMENT: u32 = 1;
pub const IO_MAILSLOT_INCREMENT: u32 = 2;
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2;
pub const IO_NETWORK_INCREMENT: u32 = 2;
pub const IO_SERIAL_INCREMENT: u32 = 2;
pub const IO_MOUSE_INCREMENT: u32 = 6;
pub const IO_KEYBOARD_INCREMENT: u32 = 6;
pub const IO_SOUND_INCREMENT: u32 = 8;
pub const MUTANT_INCREMENT: u32 = 1;
pub const SEMAPHORE_INCREMENT: u32 = 1;
pub const TIMER_APC_INCREMENT: u32 = 0;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_VIDEO: u32 = 0;
pub const PAGE_OLD_VIDEO: u32 = 2048;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_NOZERO: u32 = 8388608;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const XC_TIMEZONE_BIAS: u32 = 0;
pub const XC_TZ_STD_NAME: u32 = 1;
pub const XC_TZ_STD_DATE: u32 = 2;
pub const XC_TZ_STD_BIAS: u32 = 3;
pub const XC_TZ_DLT_NAME: u32 = 4;
pub const XC_TZ_DLT_DATE: u32 = 5;
pub const XC_TZ_DLT_BIAS: u32 = 6;
pub const XC_LANGUAGE: u32 = 7;
pub const XC_VIDEO: u32 = 8;
pub const XC_AUDIO: u32 = 9;
pub const XC_P_CONTROL_GAMES: u32 = 10;
pub const XC_P_CONTROL_PASSWORD: u32 = 11;
pub const XC_P_CONTROL_MOVIES: u32 = 12;
pub const XC_ONLINE_IP_ADDRESS: u32 = 13;
pub const XC_ONLINE_DNS_ADDRESS: u32 = 14;
pub const XC_ONLINE_DEFAULT_GATEWAY_ADDRESS: u32 = 15;
pub const XC_ONLINE_SUBNET_ADDRESS: u32 = 16;
pub const XC_MISC: u32 = 17;
pub const XC_DVD_REGION: u32 = 18;
pub const XC_MAX_OS: u32 = 255;
pub const XC_FACTORY_START_INDEX: u32 = 256;
pub const XC_FACTORY_SERIAL_NUMBER: u32 = 256;
pub const XC_FACTORY_ETHERNET_ADDR: u32 = 257;
pub const XC_FACTORY_ONLINE_KEY: u32 = 258;
pub const XC_FACTORY_AV_REGION: u32 = 259;
pub const XC_FACTORY_GAME_REGION: u32 = 260;
pub const XC_MAX_FACTORY: u32 = 511;
pub const XC_ENCRYPTED_SECTION: u32 = 65534;
pub const XC_MAX_ALL: u32 = 65535;
pub const XC_MISC_FLAG_DISABLE_DST: u32 = 2;
pub type LPCVOID = *const libc::c_void;
pub type VOID = libc::c_void;
pub type PVOID = *mut libc::c_void;
pub type LPVOID = *mut libc::c_void;
pub type HANDLE = PVOID;
pub type PHANDLE = *mut PVOID;
pub type BOOLEAN = libc::c_uchar;
pub type PBOOLEAN = *mut libc::c_uchar;
pub type SCHAR = libc::c_schar;
pub type PSCHAR = *mut libc::c_schar;
pub type CHAR = libc::c_char;
pub type PCHAR = *mut libc::c_char;
pub type CCHAR = libc::c_char;
pub type LPCH = *mut libc::c_char;
pub type PCH = *mut libc::c_char;
pub type OCHAR = libc::c_char;
pub type POCHAR = *mut libc::c_char;
pub type SHORT = libc::c_short;
pub type PSHORT = *mut libc::c_short;
pub type INT = libc::c_int;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type LONG = libc::c_long;
pub type PLONG = *mut libc::c_long;
pub type LPLONG = *mut libc::c_long;
pub type LONGLONG = libc::c_longlong;
pub type PLONGLONG = *mut libc::c_longlong;
pub type BYTE = libc::c_uchar;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut libc::c_ushort;
pub type CSHORT = libc::c_ushort;
pub type WORD = libc::c_ushort;
pub type WCHAR = libc::c_ushort;
pub type PWSTR = *mut libc::c_ushort;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
pub type LPUINT = *mut libc::c_uint;
pub type DWORD = libc::c_ulong;
pub type PDWORD = *mut libc::c_ulong;
pub type LPDWORD = *mut libc::c_ulong;
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut libc::c_ulong;
pub type ULONGLONG = libc::c_ulonglong;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SIZE_T = libc::c_uint;
pub type PSIZE_T = *mut libc::c_uint;
pub type BOOL = libc::c_int;
pub type PBOOL = *mut libc::c_int;
pub type PCSZ = *const libc::c_char;
pub type PCSTR = *const libc::c_char;
pub type LPCSTR = *const libc::c_char;
pub type QUAD = ULONGLONG;
pub type ULONG_PTR = ULONG;
pub type LONG_PTR = LONG;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: WORD,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub MXCsr: DWORD,
    pub Reserved2: DWORD,
    pub RegisterArea: [BYTE; 128usize],
    pub XmmRegisterArea: [BYTE; 128usize],
    pub Reserved4: [BYTE; 224usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__FLOATING_SAVE_AREA() {
    const UNINIT: ::core::mem::MaybeUninit<_FLOATING_SAVE_AREA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLOATING_SAVE_AREA>(),
        516usize,
        concat!("Size of: ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::core::mem::align_of::<_FLOATING_SAVE_AREA>(),
        1usize,
        concat!("Alignment of ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MXCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(MXCsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegisterArea) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XmmRegisterArea) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(XmmRegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut _FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    pub ContextFlags: DWORD,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CONTEXT>(),
        568usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edi) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esi) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebx) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edx) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ecx) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eax) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eip) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esp) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_RECORD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_RECORD>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_RECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut _EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = *mut STRING;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "< A signed 64-bit integer."]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type PLARGE_INTEGER = *mut _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "< An unsigned 64-bit integer."]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits. */ /**< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type PULARGE_INTEGER = *mut _ULARGE_INTEGER;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "< Points to the next entry of the list or the header if there is no next entry"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "< Points to the previous entry of the list or the header if there is no previous entry"]
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type LIST_ENTRY = _LIST_ENTRY;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub Synchronization: _RTL_CRITICAL_SECTION__bindgen_ty_1,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_CRITICAL_SECTION__bindgen_ty_1 {
    pub Event: _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1,
    pub RawEvent: [ULONG; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaitListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(Event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RawEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(RawEvent)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        28usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Synchronization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(Synchronization)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_SECTION_HEADER {
    pub Flags: DWORD,
    pub VirtualAddress: DWORD,
    pub VirtualSize: DWORD,
    pub FileAddress: DWORD,
    pub FileSize: DWORD,
    pub SectionName: PCSZ,
    pub SectionReferenceCount: LONG,
    pub HeadReferenceCount: *mut WORD,
    pub TailReferenceCount: *mut WORD,
    pub CheckSum: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__XBE_SECTION_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_SECTION_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_SECTION_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionReferenceCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadReferenceCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(HeadReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TailReferenceCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(TailReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
}
pub type XBE_SECTION_HEADER = _XBE_SECTION_HEADER;
pub type PXBE_SECTION_HEADER = *mut _XBE_SECTION_HEADER;
pub type PHYSICAL_ADDRESS = ULONG;
pub type PPHYSICAL_ADDRESS = *mut ULONG;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut UCHAR;
pub type PFN_COUNT = ULONG;
pub type PFN_NUMBER = ULONG;
pub type PPFN_NUMBER = *mut ULONG;
pub type KPRIORITY = LONG;
pub type DEVICE_TYPE = ULONG;
pub type LOGICAL = ULONG;
pub type PSZ = *mut libc::c_char;
pub type PSTR = *mut libc::c_char;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ULONG;
pub type KPROCESSOR_MODE = CCHAR;
pub const _MODE_KernelMode: _MODE = 0;
pub const _MODE_UserMode: _MODE = 1;
pub const _MODE_MaximumMode: _MODE = 2;
pub type _MODE = libc::c_int;
pub use self::_MODE as MODE;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type OBJECT_STRING = STRING;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type POBJECT_STRING = *mut STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    #[doc = "< Length in bytes of the string stored in the buffer"]
    pub Length: USHORT,
    #[doc = "< Length in bytes of the buffer"]
    pub MaximumLength: USHORT,
    #[doc = "< Pointer to the buffer used for the character-string"]
    pub Buffer: PWSTR,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_UNICODE_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_UNICODE_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type UNICODE_STRING = _UNICODE_STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type PUNICODE_STRING = *mut _UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[doc = " Time information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_FIELDS {
    #[doc = "< Specifies a value from 1601 on"]
    pub Year: SHORT,
    #[doc = "< Specifies a value from 1 to 12"]
    pub Month: SHORT,
    #[doc = "< Specifies a value from 1 to 31"]
    pub Day: SHORT,
    #[doc = "< Specifies a value from 0 to 23"]
    pub Hour: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Minute: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Second: SHORT,
    #[doc = "< Specifies a value from 0 to 999"]
    pub Millisecond: SHORT,
    #[doc = "< Specifies a value from 0 to 6 (Sunday to Saturday)"]
    pub Weekday: SHORT,
}
#[test]
fn bindgen_test_layout__TIME_FIELDS() {
    const UNINIT: ::core::mem::MaybeUninit<_TIME_FIELDS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIME_FIELDS>(),
        16usize,
        concat!("Size of: ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIME_FIELDS>(),
        2usize,
        concat!("Alignment of ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Day) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hour) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Second) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Millisecond) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Millisecond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Weekday) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Weekday)
        )
    );
}
#[doc = " Time information"]
pub type TIME_FIELDS = _TIME_FIELDS;
#[doc = " Time information"]
pub type PTIME_FIELDS = *mut _TIME_FIELDS;
pub const _WAIT_TYPE_WaitAll: _WAIT_TYPE = 0;
pub const _WAIT_TYPE_WaitAny: _WAIT_TYPE = 1;
pub type _WAIT_TYPE = libc::c_int;
pub use self::_WAIT_TYPE as WAIT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 9;
pub type _FSINFOCLASS = libc::c_int;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_LABEL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_LABEL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_LABEL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_LABEL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_VOLUME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_VOLUME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_VOLUME_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_VOLUME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SupportsObjects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(SupportsObjects)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_SIZE_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailableAllocationUnits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(AvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_FULL_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_FULL_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CallerAvailableAllocationUnits) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(CallerAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ActualAvailableAllocationUnits) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(ActualAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: DEVICE_TYPE,
    pub Characteristics: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_DEVICE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_DEVICE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_DEVICE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_DEVICE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: ULONG,
    pub MaximumComponentNameLength: LONG,
    pub FileSystemNameLength: ULONG,
    pub FileSystemName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_ATTRIBUTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_ATTRIBUTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumComponentNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(MaximumComponentNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemName)
        )
    );
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
        28usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    const UNINIT: ::core::mem::MaybeUninit<_SID_IDENTIFIER_AUTHORITY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    #[doc = "< Actually has size 'SubAuthorityCount'"]
    pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    const UNINIT: ::core::mem::MaybeUninit<_SID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthorityCount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdentifierAuthority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthority)
        )
    );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 37;
pub type _FILE_INFORMATION_CLASS = libc::c_int;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DIRECTORY_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DIRECTORY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_DIR_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_BOTH_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BOTH_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BOTH_DIR_INFORMATION>(),
        96usize,
        concat!("Size of: ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BOTH_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortNameLength) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STANDARD_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Directory) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory)
        )
    );
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
    pub IndexNumber: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_INTERNAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_INTERNAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_INTERNAL_INFORMATION),
            "::",
            stringify!(IndexNumber)
        )
    );
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
    pub EaSize: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_EA_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
    pub AccessFlags: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__FILE_ACCESS_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ACCESS_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ACCESS_INFORMATION),
            "::",
            stringify!(AccessFlags)
        )
    );
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAME_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileName: OBJECT_STRING,
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_RENAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_RENAME_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_RENAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_LINK_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_LINK_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_LINK_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_LINK_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAMES_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAMES_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAMES_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAMES_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DISPOSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DISPOSITION_INFORMATION),
            "::",
            stringify!(DeleteFile)
        )
    );
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_POSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_POSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_POSITION_INFORMATION),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
        )
    );
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
    pub Mode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_MODE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MODE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MODE_INFORMATION),
            "::",
            stringify!(Mode)
        )
    );
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALIGNMENT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALIGNMENT_INFORMATION),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
#[test]
fn bindgen_test_layout__FILE_ALL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALL_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasicInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(BasicInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardInformation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(StandardInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InternalInformation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(InternalInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaInformation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(EaInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessInformation) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AccessInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PositionInformation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(PositionInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ModeInformation) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(ModeInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentInformation) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AlignmentInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NameInformation) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(NameInformation)
        )
    );
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_ALLOCATION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALLOCATION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALLOCATION_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_END_OF_FILE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_END_OF_FILE_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub StreamNameLength: ULONG,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_STREAM_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STREAM_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STREAM_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STREAM_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamName)
        )
    );
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(ReadMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(CompletionMode)
        )
    );
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: ULONG,
    pub NamedPipeConfiguration: ULONG,
    pub MaximumInstances: ULONG,
    pub CurrentInstances: ULONG,
    pub InboundQuota: ULONG,
    pub ReadDataAvailable: ULONG,
    pub OutboundQuota: ULONG,
    pub WriteQuotaAvailable: ULONG,
    pub NamedPipeState: ULONG,
    pub NamedPipeEnd: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_LOCAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_LOCAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeConfiguration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeConfiguration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumInstances) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(MaximumInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentInstances) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(CurrentInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InboundQuota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(InboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadDataAvailable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(ReadDataAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutboundQuota) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(OutboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriteQuotaAvailable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(WriteQuotaAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeEnd) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeEnd)
        )
    );
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
    pub CollectDataTime: LARGE_INTEGER,
    pub MaximumCollectionCount: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_REMOTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_REMOTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CollectDataTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(CollectDataTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCollectionCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(MaximumCollectionCount)
        )
    );
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: ULONG,
    pub MailslotQuota: ULONG,
    pub NextMessageSize: ULONG,
    pub MessagesAvailable: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_QUERY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_QUERY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_QUERY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumMessageSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MaximumMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MailslotQuota) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MailslotQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextMessageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(NextMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MessagesAvailable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MessagesAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: PLARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_SET_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_SET_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_SET_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: USHORT,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
#[test]
fn bindgen_test_layout__FILE_COMPRESSION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPRESSION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPRESSION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPRESSION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressedFileSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressedFileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionUnitShift) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionUnitShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChunkShift) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ChunkShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ClusterShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
    pub FileReference: LONGLONG,
    pub ObjectId: [UCHAR; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [UCHAR; 16usize],
    pub BirthObjectId: [UCHAR; 16usize],
    pub DomainId: [UCHAR; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthVolumeId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthVolumeId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthObjectId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DomainId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DomainId)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
    pub Port: HANDLE,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_COMPLETION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPLETION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPLETION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPLETION_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Key)
        )
    );
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
    pub ClusterCount: ULONG,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_MOVE_CLUSTER_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MOVE_CLUSTER_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(ClusterCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub ChangeTime: LARGE_INTEGER,
    pub QuotaUsed: LARGE_INTEGER,
    pub QuotaThreshold: LARGE_INTEGER,
    pub QuotaLimit: LARGE_INTEGER,
    pub Sid: SID,
}
#[test]
fn bindgen_test_layout__FILE_QUOTA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_QUOTA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_QUOTA_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_QUOTA_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaUsed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaUsed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
    pub FileReference: LONGLONG,
    pub Tag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_REPARSE_POINT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_REPARSE_POINT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(Tag)
        )
    );
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NETWORK_OPEN_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ATTRIBUTE_TAG_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(ReparseTag)
        )
    );
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
    pub DestinationFile: HANDLE,
    pub ObjectInformationLength: ULONG,
    pub ObjectInformation: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_TRACKING_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_TRACKING_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_TRACKING_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_TRACKING_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DestinationFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(DestinationFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformationLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformationLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformation)
        )
    );
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[doc = " Object Attributes Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    #[doc = "< Optional handle to the root object directory for the path name specified by the ObjectName member. If RootDirectory is NULL, ObjectName must point to a fully qualified object name that includes the full path to the target object. If RootDirectory is non-NULL, ObjectName specifies an object name relative to the RootDirectory directory."]
    pub RootDirectory: HANDLE,
    #[doc = "< Pointer to an ANSI string that contains the name of the object for which a handle is to be opened. This must either be a fully qualified object name, or a relative path name to the directory specified by the RootDirectory member."]
    pub ObjectName: PANSI_STRING,
    #[doc = "< Bitmask of flags that specify object handle attributes."]
    pub Attributes: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_ATTRIBUTES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(ObjectName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
#[doc = " Object Attributes Structure"]
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
#[doc = " Object Attributes Structure"]
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
pub const _EVENT_TYPE_NotificationEvent: _EVENT_TYPE = 0;
pub const _EVENT_TYPE_SynchronizationEvent: _EVENT_TYPE = 1;
pub type _EVENT_TYPE = libc::c_int;
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[doc = " Memory manager statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_STATISTICS {
    #[doc = "< Length of MM_STATISTICS in bytes"]
    pub Length: ULONG,
    pub TotalPhysicalPages: ULONG,
    pub AvailablePages: ULONG,
    pub VirtualMemoryBytesCommitted: ULONG,
    pub VirtualMemoryBytesReserved: ULONG,
    pub CachePagesCommitted: ULONG,
    pub PoolPagesCommitted: ULONG,
    pub StackPagesCommitted: ULONG,
    pub ImagePagesCommitted: ULONG,
}
#[test]
fn bindgen_test_layout__MM_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_MM_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MM_STATISTICS>(),
        36usize,
        concat!("Size of: ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_MM_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalPhysicalPages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(TotalPhysicalPages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesCommitted) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesReserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesReserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CachePagesCommitted) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(CachePagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolPagesCommitted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(PoolPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackPagesCommitted) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(StackPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ImagePagesCommitted) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(ImagePagesCommitted)
        )
    );
}
#[doc = " Memory manager statistics"]
pub type MM_STATISTICS = _MM_STATISTICS;
#[doc = " Memory manager statistics"]
pub type PMM_STATISTICS = *mut _MM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_HEADER {
    pub dwLaunchDataType: DWORD,
    pub dwTitleId: DWORD,
    pub szLaunchPath: [CHAR; 520usize],
    pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_HEADER>(),
        532usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwLaunchDataType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwLaunchDataType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwTitleId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwTitleId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).szLaunchPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(szLaunchPath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwFlags)
        )
    );
}
pub type LAUNCH_DATA_HEADER = _LAUNCH_DATA_HEADER;
pub type PLAUNCH_DATA_HEADER = *mut _LAUNCH_DATA_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_PAGE {
    pub Header: LAUNCH_DATA_HEADER,
    pub Pad: [UCHAR; 492usize],
    pub LaunchData: [UCHAR; 3072usize],
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_PAGE() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_PAGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_PAGE>(),
        4096usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_PAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pad) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LaunchData) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(LaunchData)
        )
    );
}
pub type LAUNCH_DATA_PAGE = _LAUNCH_DATA_PAGE;
pub type PLAUNCH_DATA_PAGE = *mut _LAUNCH_DATA_PAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_DISPATCHER_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(WaitListHead)
        )
    );
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC {
    pub Type: CSHORT,
    pub Inserted: BOOLEAN,
    pub Padding: UCHAR,
    pub DpcListEntry: LIST_ENTRY,
    pub DeferredRoutine: PVOID,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KDPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC>(),
        28usize,
        concat!("Size of: ", stringify!(_KDPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcListEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DpcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: PKDPC,
    pub Period: LONG,
}
#[test]
fn bindgen_test_layout__KTIMER() {
    const UNINIT: ::core::mem::MaybeUninit<_KTIMER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTIMER>(),
        40usize,
        concat!("Size of: ", stringify!(_KTIMER))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTIMER>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTIMER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(DueTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerListEntry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(TimerListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dpc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Dpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Period) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Period)
        )
    );
}
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type KTIMER = _KTIMER;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type PKTIMER = *mut _KTIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    pub ReadListHead: LIST_ENTRY,
    pub ThreadListHead: LIST_ENTRY,
    pub StackCount: ULONG,
    pub ThreadQuantum: LONG,
    pub BasePriority: SCHAR,
    pub DisableBoost: UCHAR,
    pub DisableQuantum: UCHAR,
}
#[test]
fn bindgen_test_layout__KPROCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_KPROCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KPROCESS>(),
        28usize,
        concat!("Size of: ", stringify!(_KPROCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_KPROCESS>(),
        4usize,
        concat!("Alignment of ", stringify!(_KPROCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ReadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadQuantum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadQuantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableQuantum) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableQuantum)
        )
    );
}
pub type KPROCESS = _KPROCESS;
pub type PKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: PKPROCESS,
    pub KernelApcInProgress: UCHAR,
    pub KernelApcPending: UCHAR,
    pub UserApcPending: UCHAR,
    pub ApcQueueable: UCHAR,
}
#[test]
fn bindgen_test_layout__KAPC_STATE() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC_STATE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE>(),
        24usize,
        concat!("Size of: ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(Process)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcInProgress) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcInProgress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcPending) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcPending) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(UserApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcQueueable) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcQueueable)
        )
    );
}
pub type KAPC_STATE = _KAPC_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KQUEUE {
    pub Header: DISPATCHER_HEADER,
    pub EntryListHead: LIST_ENTRY,
    pub CurrentCount: ULONG,
    pub MaximumCount: ULONG,
    pub ThreadListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KQUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KQUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KQUEUE>(),
        40usize,
        concat!("Size of: ", stringify!(_KQUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KQUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KQUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EntryListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(EntryListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(MaximumCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(ThreadListHead)
        )
    );
}
pub type KQUEUE = _KQUEUE;
pub type PKQUEUE = *mut _KQUEUE;
pub type PRKQUEUE = *mut _KQUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub Thread: *mut _KTHREAD,
    pub Object: PVOID,
    pub NextWaitBlock: *mut _KWAIT_BLOCK,
    pub WaitKey: SHORT,
    pub WaitType: SHORT,
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_KWAIT_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KWAIT_BLOCK>(),
        24usize,
        concat!("Size of: ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_KWAIT_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Object) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextWaitBlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(NextWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitKey) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitType) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitType)
        )
    );
}
pub type KWAIT_BLOCK = _KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: SHORT,
    pub ApcMode: CHAR,
    pub Inserted: UCHAR,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub KernelRoutine: PVOID,
    pub RundownRoutine: PVOID,
    pub NormalRoutine: PVOID,
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KAPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC>(),
        40usize,
        concat!("Size of: ", stringify!(_KAPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcMode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(KernelRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RundownRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(RundownRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalRoutine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalContext) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KAPC = _KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
#[test]
fn bindgen_test_layout__KSEMAPHORE() {
    const UNINIT: ::core::mem::MaybeUninit<_KSEMAPHORE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSEMAPHORE>(),
        20usize,
        concat!("Size of: ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSEMAPHORE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Limit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Limit)
        )
    );
}
pub type KSEMAPHORE = _KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD {
    pub Header: DISPATCHER_HEADER,
    pub MutantListHead: LIST_ENTRY,
    pub KernelTime: ULONG,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub KernelStack: PVOID,
    pub TlsData: PVOID,
    pub State: UCHAR,
    pub Alerted: [UCHAR; 2usize],
    pub Alertable: UCHAR,
    pub NpxState: UCHAR,
    pub Saturation: CHAR,
    pub Priority: SCHAR,
    pub Padding: UCHAR,
    pub ApcState: KAPC_STATE,
    pub ContextSwitches: ULONG,
    pub WaitStatus: LONG,
    pub WaitIrql: UCHAR,
    pub WaitMode: CHAR,
    pub WaitNext: UCHAR,
    pub WaitReason: UCHAR,
    pub WaitBlockList: PKWAIT_BLOCK,
    pub WaitListEntry: LIST_ENTRY,
    pub WaitTime: ULONG,
    pub KernelApcDisable: ULONG,
    pub Quantum: LONG,
    pub BasePriority: SCHAR,
    pub DecrementCount: UCHAR,
    pub PriorityDecrement: SCHAR,
    pub DisableBoost: UCHAR,
    pub NpxIrql: UCHAR,
    pub SuspendCount: CHAR,
    pub Preempted: UCHAR,
    pub HasTerminated: UCHAR,
    pub Queue: PKQUEUE,
    pub QueueListEntry: LIST_ENTRY,
    pub Timer: KTIMER,
    pub TimerWaitBlock: KWAIT_BLOCK,
    pub SuspendApc: KAPC,
    pub SuspendSemaphore: KSEMAPHORE,
    pub ThreadListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KTHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_KTHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTHREAD>(),
        272usize,
        concat!("Size of: ", stringify!(_KTHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(MutantListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelStack) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TlsData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TlsData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alerted) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alerted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alertable) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alertable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxState) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Saturation) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Saturation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcState) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ApcState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextSwitches) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ContextSwitches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitStatus) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitIrql) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitMode) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitNext) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitNext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitReason) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitReason)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitBlockList) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitBlockList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitTime) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcDisable) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelApcDisable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Quantum) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Quantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DecrementCount) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DecrementCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PriorityDecrement) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(PriorityDecrement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxIrql) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendCount) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Preempted) as usize - ptr as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Preempted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HasTerminated) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(HasTerminated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Queue) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueListEntry) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(QueueListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerWaitBlock) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TimerWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendApc) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendApc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendSemaphore) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendSemaphore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ThreadListEntry)
        )
    );
}
pub type KTHREAD = _KTHREAD;
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
pub const _TIMER_TYPE_NotificationTimer: _TIMER_TYPE = 0;
pub const _TIMER_TYPE_SynchronizationTimer: _TIMER_TYPE = 1;
pub type _TIMER_TYPE = libc::c_int;
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    pub ServiceRoutine: PVOID,
    pub ServiceContext: PVOID,
    pub BusInterruptLevel: ULONG,
    pub Irql: ULONG,
    pub Connected: UCHAR,
    pub ShareVector: UCHAR,
    pub Mode: UCHAR,
    pub Padding7: UCHAR,
    pub ServiceCount: ULONG,
    pub DispatchCode: [ULONG; 22usize],
}
#[test]
fn bindgen_test_layout__KINTERRUPT() {
    const UNINIT: ::core::mem::MaybeUninit<_KINTERRUPT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KINTERRUPT>(),
        112usize,
        concat!("Size of: ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KINTERRUPT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusInterruptLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(BusInterruptLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irql) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Irql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Connected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareVector) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ShareVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding7) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Padding7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DispatchCode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(DispatchCode)
        )
    );
}
pub type KINTERRUPT = _KINTERRUPT;
pub type PKINTERRUPT = *mut _KINTERRUPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
#[test]
fn bindgen_test_layout__KSYSTEM_TIME() {
    const UNINIT: ::core::mem::MaybeUninit<_KSYSTEM_TIME> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSYSTEM_TIME>(),
        12usize,
        concat!("Size of: ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSYSTEM_TIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High1Time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High1Time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High2Time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High2Time)
        )
    );
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub const _FIRMWARE_REENTRY_HalHaltRoutine: _FIRMWARE_REENTRY = 0;
pub const _FIRMWARE_REENTRY_HalRebootRoutine: _FIRMWARE_REENTRY = 1;
pub const _FIRMWARE_REENTRY_HalQuickRebootRoutine: _FIRMWARE_REENTRY = 2;
pub const _FIRMWARE_REENTRY_HalKdRebootRoutine: _FIRMWARE_REENTRY = 3;
pub const _FIRMWARE_REENTRY_HalFatalErrorRebootRoutine: _FIRMWARE_REENTRY = 4;
pub const _FIRMWARE_REENTRY_HalMaximumRoutine: _FIRMWARE_REENTRY = 5;
pub type _FIRMWARE_REENTRY = libc::c_int;
pub use self::_FIRMWARE_REENTRY as FIRMWARE_REENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE {
    pub AllocateProcedure: PVOID,
    pub FreeProcedure: PVOID,
    pub CloseProcedure: PVOID,
    pub DeleteProcedure: PVOID,
    pub ParseProcedure: PVOID,
    pub DefaultObject: PVOID,
    pub PoolTag: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_TYPE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_TYPE>(),
        28usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_TYPE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocateProcedure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(AllocateProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeProcedure) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(FreeProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CloseProcedure) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(CloseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteProcedure) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DeleteProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ParseProcedure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(ParseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DefaultObject) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DefaultObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(PoolTag)
        )
    );
}
pub type OBJECT_TYPE = _OBJECT_TYPE;
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER {
    pub PointerCount: LONG,
    pub HandleCount: LONG,
    pub Type: POBJECT_TYPE,
    pub Flags: ULONG,
    pub Body: QUAD,
}
#[test]
fn bindgen_test_layout__OBJECT_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(PointerCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Body) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Body)
        )
    );
}
pub type OBJECT_HEADER = _OBJECT_HEADER;
pub type POBJECT_HEADER = *mut _OBJECT_HEADER;
pub type PKDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Dpc: PKDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: SHORT,
    pub Size: UCHAR,
    pub Busy: UCHAR,
    pub DeviceListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE>(),
        12usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Busy) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Busy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListHead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(DeviceListHead)
        )
    );
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PKSTART_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(StartContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: PVOID,
    pub Alignment: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_SEGMENT_ELEMENT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEMAPHORE_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub MaximumCount: LONG,
}
#[test]
fn bindgen_test_layout__SEMAPHORE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_SEMAPHORE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(MaximumCount)
        )
    );
}
pub type SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
pub type PSEMAPHORE_BASIC_INFORMATION = *mut _SEMAPHORE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUTANT_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub OwnedByCaller: UCHAR,
    pub AbandonedState: UCHAR,
}
#[test]
fn bindgen_test_layout__MUTANT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MUTANT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MUTANT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MUTANT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnedByCaller) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(OwnedByCaller)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AbandonedState) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(AbandonedState)
        )
    );
}
pub type MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
pub type PMUTANT_BASIC_INFORMATION = *mut _MUTANT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_BASIC_INFORMATION {
    pub Depth: LONG,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION),
            "::",
            stringify!(Depth)
        )
    );
}
pub type IO_COMPLETION_BASIC_INFORMATION = _IO_COMPLETION_BASIC_INFORMATION;
pub type PIO_COMPLETION_BASIC_INFORMATION = *mut _IO_COMPLETION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_BASIC_INFORMATION {
    pub EventType: EVENT_TYPE,
    pub EventState: LONG,
}
#[test]
fn bindgen_test_layout__EVENT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_EVENT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EVENT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_EVENT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventState)
        )
    );
}
pub type EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
pub type PEVENT_BASIC_INFORMATION = *mut _EVENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_STATISTICS {
    pub Length: ULONG,
    pub ThreadCount: ULONG,
    pub HandleCount: ULONG,
}
#[test]
fn bindgen_test_layout__PS_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_PS_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PS_STATISTICS>(),
        12usize,
        concat!("Size of: ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_PS_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(ThreadCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(HandleCount)
        )
    );
}
pub type PS_STATISTICS = _PS_STATISTICS;
pub type PPS_STATISTICS = *mut _PS_STATISTICS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETHREAD {
    pub Tcb: KTHREAD,
    pub CreateTime: LARGE_INTEGER,
    pub ExitTime: LARGE_INTEGER,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_1,
    pub __bindgen_anon_2: _ETHREAD__bindgen_ty_2,
    pub UniqueThread: HANDLE,
    pub StartAddress: PVOID,
    pub IrpList: LIST_ENTRY,
    pub DebugData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_1 {
    pub ExitStatus: NTSTATUS,
    pub OfsChain: PVOID,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(ExitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OfsChain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(OfsChain)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_2 {
    pub ReaperListEntry: LIST_ENTRY,
    pub ActiveTimerListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaperListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ReaperListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ActiveTimerListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ActiveTimerListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__ETHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD>(),
        320usize,
        concat!("Size of: ", stringify!(_ETHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_ETHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(Tcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitTime) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(ExitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UniqueThread) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(UniqueThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartAddress) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(StartAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpList) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(IrpList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DebugData) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(DebugData)
        )
    );
}
pub type ETHREAD = _ETHREAD;
pub type PETHREAD = *mut _ETHREAD;
pub type PCREATE_THREAD_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Thread: PETHREAD, ThreadId: HANDLE, Create: BOOLEAN),
>;
#[doc = "< Interrupt is level-triggered. Used for traditional PCI line-based interrupts."]
pub const _KINTERRUPT_MODE_LevelSensitive: _KINTERRUPT_MODE = 0;
#[doc = "< Interrupt is edge-triggered. Used for PCI message-signaled interrupts"]
pub const _KINTERRUPT_MODE_Latched: _KINTERRUPT_MODE = 1;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub type _KINTERRUPT_MODE = libc::c_int;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub type PKSERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Interrupt: PKINTERRUPT, ServiceContext: PVOID) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_BASIC_INFORMATION {
    pub RemainingTime: LARGE_INTEGER,
    pub TimerState: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TIMER_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_TIMER_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIMER_BASIC_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIMER_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemainingTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(RemainingTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(TimerState)
        )
    );
}
pub type TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
pub type PTIMER_BASIC_INFORMATION = *mut _TIMER_BASIC_INFORMATION;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_KRNL_VERSION {
    pub Major: USHORT,
    pub Minor: USHORT,
    pub Build: USHORT,
    pub Qfe: USHORT,
}
#[test]
fn bindgen_test_layout__XBOX_KRNL_VERSION() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_KRNL_VERSION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_KRNL_VERSION>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_KRNL_VERSION>(),
        2usize,
        concat!("Alignment of ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Build) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Build)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Qfe) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Qfe)
        )
    );
}
pub type XBOX_KRNL_VERSION = _XBOX_KRNL_VERSION;
pub type PXBOX_KRNL_VERSION = *mut _XBOX_KRNL_VERSION;
#[doc = " Information about the XBOX-hardware"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_HARDWARE_INFO {
    pub Flags: ULONG,
    pub GpuRevision: UCHAR,
    pub McpRevision: UCHAR,
    pub reserved: [UCHAR; 2usize],
}
#[test]
fn bindgen_test_layout__XBOX_HARDWARE_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_HARDWARE_INFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_HARDWARE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_HARDWARE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GpuRevision) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(GpuRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).McpRevision) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(McpRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Information about the XBOX-hardware"]
pub type XBOX_HARDWARE_INFO = _XBOX_HARDWARE_INFO;
pub type XBOX_KEY_DATA = [UCHAR; 16usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    const UNINIT: ::core::mem::MaybeUninit<_GENERIC_MAPPING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::core::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut _GENERIC_MAPPING;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    #[doc = "< Pointer to the next (or first, if this is a header) entry in the singly linked list (NULL if there is none)"]
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_SINGLE_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Next: SINGLE_LIST_ENTRY,
    pub Depth: USHORT,
    pub Sequence: USHORT,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sequence) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Sequence)
        )
    );
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(Alignment)
        )
    );
}
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type SLIST_HEADER = _SLIST_HEADER;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    const UNINIT: ::core::mem::MaybeUninit<_KEVENT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KEVENT>(),
        16usize,
        concat!("Size of: ", stringify!(_KEVENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KEVENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEVENT),
            "::",
            stringify!(Header)
        )
    );
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE_ENTRY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(DeviceListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SortKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(SortKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(Inserted)
        )
    );
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_CONTEXT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_CONTEXT>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Key)
        )
    );
}
pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Flags: UCHAR,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub FinalStatus: NTSTATUS,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub LockCount: LONG,
    pub Lock: KEVENT,
    pub Event: KEVENT,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECT>(),
        80usize,
        concat!("Size of: ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinalStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FinalStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RelatedFileObject) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(RelatedFileObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionContext) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CompletionContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Event)
        )
    );
}
impl _FILE_OBJECT {
    #[inline]
    pub fn DeletePending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeletePending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeleteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedRead(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedRead(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedWrite(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedWrite(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedDelete(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedDelete(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeletePending: BOOLEAN,
        ReadAccess: BOOLEAN,
        WriteAccess: BOOLEAN,
        DeleteAccess: BOOLEAN,
        SharedRead: BOOLEAN,
        SharedWrite: BOOLEAN,
        SharedDelete: BOOLEAN,
        Reserved: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeletePending: u8 = unsafe { ::core::mem::transmute(DeletePending) };
            DeletePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadAccess: u8 = unsafe { ::core::mem::transmute(ReadAccess) };
            ReadAccess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WriteAccess: u8 = unsafe { ::core::mem::transmute(WriteAccess) };
            WriteAccess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeleteAccess: u8 = unsafe { ::core::mem::transmute(DeleteAccess) };
            DeleteAccess as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SharedRead: u8 = unsafe { ::core::mem::transmute(SharedRead) };
            SharedRead as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SharedWrite: u8 = unsafe { ::core::mem::transmute(SharedWrite) };
            SharedWrite as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SharedDelete: u8 = unsafe { ::core::mem::transmute(SharedDelete) };
            SharedDelete as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FILE_OBJECT = _FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[doc = " This struct represents an I/O request packet"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    #[doc = "< Flags for the packet"]
    pub Flags: ULONG,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub PendingReturned: BOOLEAN,
    #[doc = "< Has the packet been canceled?"]
    pub Cancel: BOOLEAN,
    pub UserIosb: PIO_STATUS_BLOCK,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_1,
    pub UserBuffer: PVOID,
    pub SegmentArray: PFILE_SEGMENT_ELEMENT,
    pub LockedBufferLength: ULONG,
    pub Tail: _IRP__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub AsynchronousParameters: _IRP__bindgen_ty_1__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub UserApcContext: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchronousParameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AsynchronousParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub Overlay: _IRP__bindgen_ty_2__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub __bindgen_anon_2: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 5usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DriverContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueueEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DeviceQueueEntry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STATUS_LOCATION,
    pub PacketType: ULONG,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentStackLocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(CurrentStackLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PacketType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PacketType)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OriginalFileObject) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(OriginalFileObject)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Apc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Apc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(CompletionKey)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP>(),
        104usize,
        concat!("Size of: ", stringify!(_IRP))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(ThreadListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(IoStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentLocation) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(CurrentLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PendingReturned) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(PendingReturned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cancel) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Cancel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserIosb) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserIosb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserEvent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserBuffer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegmentArray) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(SegmentArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockedBufferLength) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(LockedBufferLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tail) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Tail)
        )
    );
}
#[doc = " This struct represents an I/O request packet"]
pub type IRP = _IRP;
#[doc = " This struct represents an I/O request packet"]
pub type PIRP = *mut _IRP;
pub type PDRIVER_STARTIO = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP),
>;
pub type PDRIVER_DELETEDEVICE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT)>;
pub type PDRIVER_DISMOUNTVOLUME = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverDeleteDevice: PDRIVER_DELETEDEVICE,
    pub DriverDismountVolume: PDRIVER_DISMOUNTVOLUME,
    pub MajorFunction: [PDRIVER_DISPATCH; 14usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DRIVER_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_OBJECT>(),
        68usize,
        concat!("Size of: ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverStartIo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStartIo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDeleteDevice) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDeleteDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDismountVolume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDismountVolume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(MajorFunction)
        )
    );
}
pub type DRIVER_OBJECT = _DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: PDRIVER_OBJECT,
    pub MountedOrSelfDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: PIRP,
    pub Flags: ULONG,
    pub DeviceExtension: PVOID,
    pub DeviceType: UCHAR,
    pub StartIoFlags: UCHAR,
    pub StackSize: CCHAR,
    pub DeletePending: BOOLEAN,
    pub SectorSize: ULONG,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub DeviceLock: KEVENT,
    pub StartIoKey: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT>(),
        72usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReferenceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DriverObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MountedOrSelfDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(MountedOrSelfDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceExtension) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceExtension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoFlags) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackSize) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StackSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceLock) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoKey) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoKey)
        )
    );
}
pub type DEVICE_OBJECT = _DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DIRECTORY_INFORMATION {
    pub Name: OBJECT_STRING,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
pub type POBJECT_DIRECTORY_INFORMATION = *mut _OBJECT_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERWLOCK {
    pub LockCount: LONG,
    pub WritersWaitingCount: ULONG,
    pub ReadersWaitingCount: ULONG,
    pub ReadersEntryCount: ULONG,
    pub WriterEvent: KEVENT,
    pub ReaderSemaphore: KSEMAPHORE,
}
#[test]
fn bindgen_test_layout__ERWLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_ERWLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERWLOCK>(),
        52usize,
        concat!("Size of: ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERWLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WritersWaitingCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WritersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersWaitingCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersEntryCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersEntryCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriterEvent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WriterEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaderSemaphore) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReaderSemaphore)
        )
    );
}
pub type ERWLOCK = _ERWLOCK;
pub type PERWLOCK = *mut _ERWLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XBOX_REFURB_INFO {
    pub Signature: ULONG,
    pub PowerCycleCount: ULONG,
    pub FirstSetTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__XBOX_REFURB_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_REFURB_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_REFURB_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_REFURB_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerCycleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(PowerCycleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstSetTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(FirstSetTime)
        )
    );
}
pub type XBOX_REFURB_INFO = _XBOX_REFURB_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KFLOATING_SAVE {
    pub ControlWord: ULONG,
    pub StatusWord: ULONG,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: ULONG,
    pub DataOffset: ULONG,
    pub DataSelector: ULONG,
    pub Cr0NpxState: ULONG,
    pub Spare1: ULONG,
}
#[test]
fn bindgen_test_layout__KFLOATING_SAVE() {
    const UNINIT: ::core::mem::MaybeUninit<_KFLOATING_SAVE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KFLOATING_SAVE>(),
        32usize,
        concat!("Size of: ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KFLOATING_SAVE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Cr0NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Spare1)
        )
    );
}
pub type KFLOATING_SAVE = _KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_PTE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__HARDWARE_PTE() {
    assert_eq!(
        ::core::mem::size_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Size of: ", stringify!(_HARDWARE_PTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_HARDWARE_PTE))
    );
}
impl _HARDWARE_PTE {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuardOrEndOfAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuardOrEndOfAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        Write: ULONG,
        Owner: ULONG,
        WriteThrough: ULONG,
        CacheDisable: ULONG,
        Accessed: ULONG,
        Dirty: ULONG,
        LargePage: ULONG,
        Global: ULONG,
        GuardOrEndOfAllocation: ULONG,
        PersistAllocation: ULONG,
        reserved: ULONG,
        PageFrameNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u32 = unsafe { ::core::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u32 = unsafe { ::core::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u32 = unsafe { ::core::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u32 = unsafe { ::core::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u32 = unsafe { ::core::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u32 = unsafe { ::core::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u32 = unsafe { ::core::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u32 = unsafe { ::core::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GuardOrEndOfAllocation: u32 =
                unsafe { ::core::mem::transmute(GuardOrEndOfAllocation) };
            GuardOrEndOfAllocation as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PersistAllocation: u32 = unsafe { ::core::mem::transmute(PersistAllocation) };
            PersistAllocation as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let PageFrameNumber: u32 = unsafe { ::core::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HARDWARE_PTE = _HARDWARE_PTE;
pub type PHARDWARE_PTE = *mut _HARDWARE_PTE;
pub type PPS_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcArgument1: PVOID, ApcArgument2: PVOID, ApcArgument3: PVOID),
>;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrEventPair: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_WrFsCacheIn: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_WrFsCacheOut: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_Spare4: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_Spare5: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_Spare6: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 27;
pub type _KWAIT_REASON = libc::c_int;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: PRKTHREAD,
    pub Abandoned: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KMUTANT() {
    const UNINIT: ::core::mem::MaybeUninit<_KMUTANT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KMUTANT>(),
        32usize,
        concat!("Size of: ", stringify!(_KMUTANT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KMUTANT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KMUTANT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListEntry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(MutantListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(OwnerThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Abandoned) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Abandoned)
        )
    );
}
pub type KMUTANT = _KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARE_ACCESS {
    pub OpenCount: UCHAR,
    pub Readers: UCHAR,
    pub Writers: UCHAR,
    pub Deleters: UCHAR,
    pub SharedRead: UCHAR,
    pub SharedWrite: UCHAR,
    pub SharedDelete: UCHAR,
}
#[test]
fn bindgen_test_layout__SHARE_ACCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_SHARE_ACCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SHARE_ACCESS>(),
        7usize,
        concat!("Size of: ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_SHARE_ACCESS>(),
        1usize,
        concat!("Alignment of ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OpenCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(OpenCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Readers) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Writers) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Deleters) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Deleters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedRead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedWrite) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedDelete) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedDelete)
        )
    );
}
pub type SHARE_ACCESS = _SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
pub type PKSYNCHRONIZE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(SynchronizeContext: PVOID) -> BOOLEAN>;
pub type PKRUNDOWN_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(Apc: PKAPC)>;
pub type PKNORMAL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        NormalContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKKERNEL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Apc: PKAPC,
        NormalRoutine: *mut PKNORMAL_ROUTINE,
        NormalContext: *mut PVOID,
        SystemArgument1: *mut PVOID,
        SystemArgument2: *mut PVOID,
    ),
>;
pub type PHAL_SHUTDOWN_NOTIFICATION = ::core::option::Option<
    unsafe extern "stdcall" fn(ShutdownRegistration: *mut _HAL_SHUTDOWN_REGISTRATION),
>;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HAL_SHUTDOWN_REGISTRATION {
    #[doc = "< Function pointer which will be called on shutdown"]
    pub NotificationRoutine: PHAL_SHUTDOWN_NOTIFICATION,
    #[doc = "< Priority of the notification.The higher the priority, the earliert the callback function is called"]
    pub Priority: LONG,
    #[doc = "< Used to put the notifications into a linked list"]
    pub ListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__HAL_SHUTDOWN_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_HAL_SHUTDOWN_REGISTRATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        16usize,
        concat!("Size of: ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NotificationRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(NotificationRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type HAL_SHUTDOWN_REGISTRATION = _HAL_SHUTDOWN_REGISTRATION;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type PHAL_SHUTDOWN_REGISTRATION = *mut _HAL_SHUTDOWN_REGISTRATION;
pub type pfXcSHAInit = ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR)>;
pub type pfXcSHAUpdate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG),
>;
pub type pfXcSHAFinal =
    ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbDigest: PUCHAR)>;
pub type pfXcRC4Key = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR),
>;
pub type pfXcRC4Crypt = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR),
>;
pub type pfXcHMAC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    ),
>;
pub type pfXcPKEncPublic = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKDecPrivate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKGetKeyLen =
    ::core::option::Option<unsafe extern "stdcall" fn(pbPubKey: PUCHAR) -> ULONG>;
pub type pfXcVerifyPKCS1Signature = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN,
>;
pub type pfXcModExp = ::core::option::Option<
    unsafe extern "stdcall" fn(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG,
>;
pub type pfXcDESKeyParity =
    ::core::option::Option<unsafe extern "stdcall" fn(pbKey: PUCHAR, dwKeyLength: ULONG)>;
pub type pfXcKeyTable = ::core::option::Option<
    unsafe extern "stdcall" fn(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR),
>;
pub type pfXcBlockCrypt = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    ),
>;
pub type pfXcBlockCryptCBC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    ),
>;
pub type pfXcCryptService =
    ::core::option::Option<unsafe extern "stdcall" fn(dwOp: ULONG, pArgs: PVOID) -> ULONG>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYPTO_VECTOR {
    pub pXcSHAInit: pfXcSHAInit,
    pub pXcSHAUpdate: pfXcSHAUpdate,
    pub pXcSHAFinal: pfXcSHAFinal,
    pub pXcRC4Key: pfXcRC4Key,
    pub pXcRC4Crypt: pfXcRC4Crypt,
    pub pXcHMAC: pfXcHMAC,
    pub pXcPKEncPublic: pfXcPKEncPublic,
    pub pXcPKDecPrivate: pfXcPKDecPrivate,
    pub pXcPKGetKeyLen: pfXcPKGetKeyLen,
    pub pXcVerifyPKCS1Signature: pfXcVerifyPKCS1Signature,
    pub pXcModExp: pfXcModExp,
    pub pXcDESKeyParity: pfXcDESKeyParity,
    pub pXcKeyTable: pfXcKeyTable,
    pub pXcBlockCrypt: pfXcBlockCrypt,
    pub pXcBlockCryptCBC: pfXcBlockCryptCBC,
    pub pXcCryptService: pfXcCryptService,
}
#[test]
fn bindgen_test_layout_CRYPTO_VECTOR() {
    const UNINIT: ::core::mem::MaybeUninit<CRYPTO_VECTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CRYPTO_VECTOR>(),
        64usize,
        concat!("Size of: ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYPTO_VECTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAInit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAUpdate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAFinal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAFinal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Key) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Crypt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Crypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcHMAC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcHMAC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKEncPublic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKEncPublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKDecPrivate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKDecPrivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKGetKeyLen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKGetKeyLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcVerifyPKCS1Signature) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcVerifyPKCS1Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcModExp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcModExp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcDESKeyParity) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcDESKeyParity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcKeyTable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcKeyTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCrypt) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCryptCBC) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCryptCBC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcCryptService) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcCryptService)
        )
    );
}
pub type PCRYPTO_VECTOR = *mut CRYPTO_VECTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_TABLE {
    pub HandleCount: LONG,
    pub FirstFreeTableEntry: LONG_PTR,
    pub NextHandleNeedingPool: HANDLE,
    pub RootTable: *mut *mut PVOID,
    pub BuiltinRootTable: [*mut PVOID; 8usize],
}
#[test]
fn bindgen_test_layout__OBJECT_HANDLE_TABLE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HANDLE_TABLE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HANDLE_TABLE>(),
        48usize,
        concat!("Size of: ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HANDLE_TABLE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstFreeTableEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(FirstFreeTableEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextHandleNeedingPool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(NextHandleNeedingPool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootTable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(RootTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BuiltinRootTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(BuiltinRootTable)
        )
    );
}
pub type OBJECT_HANDLE_TABLE = _OBJECT_HANDLE_TABLE;
pub type POBJECT_HANDLE_TABLE = *mut _OBJECT_HANDLE_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNFREE {
    pub PackedPfnFlink: USHORT,
    pub PackedPfnBlink: USHORT,
}
#[test]
fn bindgen_test_layout__MMPFNFREE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNFREE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNFREE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNFREE>(),
        2usize,
        concat!("Alignment of ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnFlink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnFlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnBlink) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnBlink)
        )
    );
}
pub type MMPFNFREE = _MMPFNFREE;
pub type PMMPFNFREE = *mut _MMPFNFREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNREGION {
    pub FreePagesByColor: [MMPFNFREE; 32usize],
    pub AvailablePages: PFN_COUNT,
}
#[test]
fn bindgen_test_layout__MMPFNREGION() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNREGION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNREGION>(),
        132usize,
        concat!("Size of: ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNREGION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreePagesByColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(FreePagesByColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(AvailablePages)
        )
    );
}
pub type MMPFNREGION = _MMPFNREGION;
pub type PMMPFNREGION = *mut _MMPFNREGION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTE {
    pub __bindgen_anon_1: _MMPTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE__bindgen_ty_1 {
    pub Long: ULONG,
    pub Hard: HARDWARE_PTE,
    pub List: _MMPTE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OneEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        OneEntry: ULONG,
        NextEntry: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OneEntry: u32 = unsafe { ::core::mem::transmute(OneEntry) };
            OneEntry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let NextEntry: u32 = unsafe { ::core::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTE__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Long)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Hard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).List) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(List)
        )
    );
}
#[test]
fn bindgen_test_layout__MMPTE() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE))
    );
}
pub type MMPTE = _MMPTE;
pub type PMMPTE = *mut _MMPTE;
pub const _MMPFN_BUSY_TYPE_MmUnknownUsage: _MMPFN_BUSY_TYPE = 0;
pub const _MMPFN_BUSY_TYPE_MmStackUsage: _MMPFN_BUSY_TYPE = 1;
pub const _MMPFN_BUSY_TYPE_MmVirtualPageTableUsage: _MMPFN_BUSY_TYPE = 2;
pub const _MMPFN_BUSY_TYPE_MmSystemPageTableUsage: _MMPFN_BUSY_TYPE = 3;
pub const _MMPFN_BUSY_TYPE_MmPoolUsage: _MMPFN_BUSY_TYPE = 4;
pub const _MMPFN_BUSY_TYPE_MmVirtualMemoryUsage: _MMPFN_BUSY_TYPE = 5;
pub const _MMPFN_BUSY_TYPE_MmSystemMemoryUsage: _MMPFN_BUSY_TYPE = 6;
pub const _MMPFN_BUSY_TYPE_MmImageUsage: _MMPFN_BUSY_TYPE = 7;
pub const _MMPFN_BUSY_TYPE_MmFsCacheUsage: _MMPFN_BUSY_TYPE = 8;
pub const _MMPFN_BUSY_TYPE_MmContiguousUsage: _MMPFN_BUSY_TYPE = 9;
pub const _MMPFN_BUSY_TYPE_MmDebuggerUsage: _MMPFN_BUSY_TYPE = 10;
pub const _MMPFN_BUSY_TYPE_MmMaximumUsage: _MMPFN_BUSY_TYPE = 11;
pub type _MMPFN_BUSY_TYPE = libc::c_int;
pub use self::_MMPFN_BUSY_TYPE as MMPFN_BUSY_TYPE;
pub type PMMREMOVE_PAGE_ROUTINE = ::core::option::Option<
    unsafe extern "fastcall" fn(BusyType: MMPFN_BUSY_TYPE, TargetPte: PMMPTE) -> PFN_NUMBER,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTERANGE {
    pub HeadPte: MMPTE,
    pub FirstCommittedPte: PMMPTE,
    pub LastCommittedPte: PMMPTE,
    pub LastReservedPte: PMMPTE,
    pub AvailablePages: *mut PFN_COUNT,
    pub RemovePageRoutine: PMMREMOVE_PAGE_ROUTINE,
}
#[test]
fn bindgen_test_layout__MMPTERANGE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTERANGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTERANGE>(),
        24usize,
        concat!("Size of: ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTERANGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadPte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(HeadPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstCommittedPte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(FirstCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastCommittedPte) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastReservedPte) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastReservedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemovePageRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(RemovePageRoutine)
        )
    );
}
pub type MMPTERANGE = _MMPTERANGE;
pub type PMMPTERANGE = *mut _MMPTERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMADDRESS_NODE {
    pub StartingVpn: ULONG_PTR,
    pub EndingVpn: ULONG_PTR,
    pub Parent: *mut _MMADDRESS_NODE,
    pub LeftChild: *mut _MMADDRESS_NODE,
    pub RightChild: *mut _MMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMADDRESS_NODE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMADDRESS_NODE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMADDRESS_NODE>(),
        20usize,
        concat!("Size of: ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMADDRESS_NODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingVpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(StartingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndingVpn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(EndingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LeftChild) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(LeftChild)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RightChild) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(RightChild)
        )
    );
}
pub type MMADDRESS_NODE = _MMADDRESS_NODE;
pub type PMMADDRESS_NODE = *mut _MMADDRESS_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMGLOBALDATA {
    pub RetailPfnRegion: PMMPFNREGION,
    pub SystemPteRange: PMMPTERANGE,
    pub AvailablePages: PULONG,
    pub AllocatedPagesByUsage: *mut PFN_COUNT,
    pub AddressSpaceLock: PRTL_CRITICAL_SECTION,
    pub VadRoot: *mut PMMADDRESS_NODE,
    pub VadHint: *mut PMMADDRESS_NODE,
    pub VadFreeHint: *mut PMMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMGLOBALDATA() {
    const UNINIT: ::core::mem::MaybeUninit<_MMGLOBALDATA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMGLOBALDATA>(),
        32usize,
        concat!("Size of: ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMGLOBALDATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RetailPfnRegion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(RetailPfnRegion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemPteRange) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(SystemPteRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocatedPagesByUsage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AllocatedPagesByUsage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressSpaceLock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AddressSpaceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadRoot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadRoot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadHint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadHint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadFreeHint) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadFreeHint)
        )
    );
}
pub type MMGLOBALDATA = _MMGLOBALDATA;
pub type PMMGLOBALDATA = *mut _MMGLOBALDATA;
pub type PIDE_INTERRUPT_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_FINISHIO_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_POLL_RESET_COMPLETE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn() -> BOOLEAN>;
pub type PIDE_TIMEOUT_EXPIRED_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_START_PACKET_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP)>;
pub type PIDE_START_NEXT_PACKET_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IDE_CHANNEL_OBJECT {
    pub InterruptRoutine: PIDE_INTERRUPT_ROUTINE,
    pub FinishIoRoutine: PIDE_FINISHIO_ROUTINE,
    pub PollResetCompleteRoutine: PIDE_POLL_RESET_COMPLETE_ROUTINE,
    pub TimeoutExpiredRoutine: PIDE_TIMEOUT_EXPIRED_ROUTINE,
    pub StartPacketRoutine: PIDE_START_PACKET_ROUTINE,
    pub StartNextPacketRoutine: PIDE_START_NEXT_PACKET_ROUTINE,
    pub InterruptIrql: KIRQL,
    pub ExpectingBusMasterInterrupt: BOOLEAN,
    pub StartPacketBusy: BOOLEAN,
    pub StartPacketRequested: BOOLEAN,
    pub Timeout: UCHAR,
    pub IoRetries: UCHAR,
    pub MaximumIoRetries: UCHAR,
    pub CurrentIrp: PIRP,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub PhysicalRegionDescriptorTablePhysical: ULONG,
    pub TimerDpc: KDPC,
    pub FinishDpc: KDPC,
    pub Timer: KTIMER,
    pub InterruptObject: KINTERRUPT,
}
#[test]
fn bindgen_test_layout__IDE_CHANNEL_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_IDE_CHANNEL_OBJECT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IDE_CHANNEL_OBJECT>(),
        264usize,
        concat!("Size of: ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IDE_CHANNEL_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishIoRoutine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishIoRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PollResetCompleteRoutine) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PollResetCompleteRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeoutExpiredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimeoutExpiredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartNextPacketRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartNextPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptIrql) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptIrql)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ExpectingBusMasterInterrupt) as usize - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(ExpectingBusMasterInterrupt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketBusy) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketBusy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRequested) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRequested)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timeout) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoRetries) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(IoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumIoRetries) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(MaximumIoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PhysicalRegionDescriptorTablePhysical) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PhysicalRegionDescriptorTablePhysical)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerDpc) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimerDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishDpc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptObject) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptObject)
        )
    );
}
pub type IDE_CHANNEL_OBJECT = _IDE_CHANNEL_OBJECT;
pub type PIDE_CHANNEL_OBJECT = *mut _IDE_CHANNEL_OBJECT;
pub type PKSYSTEM_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(StartRoutine: PKSTART_ROUTINE, StartContext: PVOID),
>;
extern "stdcall" {
    #[doc = " Decrements the reference count of the section and unloads it if the reference count reaches zero.\n @param Section The section to be unloaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeUnloadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XePublicKeyData: [UCHAR; 284usize];
}
extern "stdcall" {
    #[doc = " Loads the supplied section into memory or increases its reference count if it's already loaded.\n @param Section The section to be loaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeLoadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XeImageFileName: [ANSI_STRING; 1usize];
}
extern "stdcall" {
    pub fn XcVerifyPKCS1Signature(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN;
}
extern "stdcall" {
    pub fn XcUpdateCrypto(pNewVector: PCRYPTO_VECTOR, pROMVector: PCRYPTO_VECTOR);
}
extern "stdcall" {
    #[doc = " Updates the internal state of the SHA-1 algorithm by hashing some input data.\n @param pbSHAContext A pointer to the buffer holding the internal state of the algorithm\n @param pbInput A pointer to the bytes which are to get hashed\n @oaram dwInputLength The number of bytes in the buffer given in the pbInput parameter"]
    pub fn XcSHAUpdate(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG);
}
extern "stdcall" {
    #[doc = " Initializes a buffer which will get used to generate a SHA-1 hash.\n @param pbSHAContext A pointer to a 116-byte buffer to be used as storage for the internal state of the algorithm"]
    pub fn XcSHAInit(pbSHAContext: PUCHAR);
}
extern "stdcall" {
    #[doc = " Extracts the final SHA-1 hash from the buffer used to calculate the hash.\n @param pbSHAContext A pointer to the buffer used to hold the internal state of the algorithm\n @param pbDigest A pointer to a 20-byte buffer in which the hash will be stored"]
    pub fn XcSHAFinal(pbSHAContext: PUCHAR, pbDigest: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Key(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Crypt(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR);
}
extern "stdcall" {
    pub fn XcPKGetKeyLen(pbPubKey: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKEncPublic(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKDecPrivate(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcModExp(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG;
}
extern "stdcall" {
    pub fn XcKeyTable(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcHMAC(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcDESKeyParity(pbKey: PUCHAR, dwKeyLength: ULONG);
}
extern "stdcall" {
    pub fn XcCryptService(dwOp: ULONG, pArgs: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn XcBlockCryptCBC(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcBlockCrypt(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    );
}
extern "C" {
    pub static mut XboxSignatureKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxLANKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxKrnlVersion: XBOX_KRNL_VERSION;
}
extern "C" {
    pub static mut XboxHardwareInfo: XBOX_HARDWARE_INFO;
}
extern "C" {
    pub static mut XboxHDKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxEEPROMKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxAlternateSignatureKeys: [XBOX_KEY_DATA; 0usize];
}
extern "stdcall" {
    #[doc = " Writes a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with zeroes\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled"]
    pub fn RtlZeroMemory(Destination: *mut VOID, Length: SIZE_T);
}
extern "stdcall" {
    pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlVsprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlVsnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlUpperString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Returns the uppercased equivalent of a single character\n @param Character The character which will be converted\n @return The uppercased character"]
    pub fn RtlUpperChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    #[doc = " Initiates an unwind of procedure call frames\n THIS FUNCTION IS NOT SAFE TO CALL FROM C CODE! It does not follow the stdcall convention and trashes registers that are supposed to be callee-saved.\n @param TargetFrame A pointer to the call frame that is the target of the unwind. If this parameter is NULL, the function performs an exit unwind.\n @param TargetIp The continuation address of the unwind. If NULL, the function will return normally. This parameter is ignored if TargetFrame is NULL.\n @param ExceptionRecord A pointer to an EXCEPTION_RECORD structure.\n @param ReturnValue A value to be placed in the integer function return register before continuing execution."]
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteSize(
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToInteger(
        String: PUNICODE_STRING,
        Base: ULONG,
        Value: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified Unicode source string into an ANSI string.\n @param DestinationString A pointer to an ANSI_STRING structure to hold the converted ANSI string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the UNICODE_STRING structure that contains the source string to be converted to ANSI.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeAnsiString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PSTRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.\n @param CriticalSection A pointer to the critical section object.\n @return If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero. If another thread already owns the critical section, the return value is zero."]
    pub fn RtlTryEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " The RtlTimeToTimeFields routine converts system time into a TIME_FIELDS structure\n @param Time Pointer to a buffer containing the absolute system time as a large integer, accurate to 100-nanosecond resolution\n @param TimeFields Pointer to a caller-allocated buffer, which must be at least sizeof(TIME_FIELDS), to contain the returned information"]
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
}
extern "stdcall" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
}
extern "C" {
    pub fn RtlSprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlSnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlRip(ApiName: PVOID, Expression: PVOID, Message: PVOID);
}
extern "stdcall" {
    pub fn RtlRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeSize(
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeN(
        UnicodeString: PWSTR,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMoveMemory(Destination: PVOID, Source: *const PVOID, Length: ULONG);
}
extern "stdcall" {
    pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: PGENERIC_MAPPING);
}
extern "stdcall" {
    #[doc = " Returns the lowercase equivalent of a single character\n @param Character The character which will be converted\n @return The lowercased character"]
    pub fn RtlLowerChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlLeaveCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Releases ownership of the specified critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlLeaveCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlIntegerToUnicodeString(
        Value: ULONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlIntegerToChar(Value: ULONG, Base: ULONG, OutputLength: LONG, String: PSZ)
        -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initializes a critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlInitializeCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of Unicode characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the UNICODE_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of ANSI characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the ANSI_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
extern "stdcall" {
    pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlAnsiStringToUnicodeString.\n @param UnicodeString A pointer to a Unicode string whose buffer was previously allocated by RtlAnsiStringToUnicodeString."]
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlUnicodeStringToAnsiString.\n @param AnsiString A pointer to an ANSI string whose buffer was previously allocated by RtlUnicodeStringToAnsiString."]
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with repetitions of a ULONG value\n @param Destination A pointer to the (ULONG-aligned) memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Pattern The ULONG-value with which the memory block will be filled"]
    pub fn RtlFillMemoryUlong(Destination: PVOID, Length: SIZE_T, Pattern: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with a specified value\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Fill The byte-value with which the memory block will be filled"]
    pub fn RtlFillMemory(Destination: PVOID, Length: ULONG, Fill: UCHAR);
}
extern "stdcall" {
    pub fn RtlExtendedMagicDivide(
        Dividend: LARGE_INTEGER,
        MagicDivisor: LARGE_INTEGER,
        ShiftCount: CCHAR,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedLargeIntegerDivide(
        Dividend: LARGE_INTEGER,
        Divisor: ULONG,
        Remainder: PULONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedIntegerMultiply(
        Multiplicand: LARGE_INTEGER,
        Multiplier: LONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first unicode string\n @param String2 Pointer to the second unicode string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlEnterCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    pub fn RtlCreateUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCWSTR,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PUNICODE_STRING);
}
extern "stdcall" {
    pub fn RtlCopyString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> LONG;
}
extern "stdcall" {
    #[doc = " Returns how many bytes in a block of memory match a specified pattern.\n @param Source Pointer to a block of memory. Must be aligned on a ULONG boundary.\n @param Length Number of bytes over which the comparison should be done. Must be a multiple of sizeof(ULONG).\n @param Pattern Pattern to be compared byte by byte, repeatedly, through the specified memory range.\n @return The number of bytes that were compared and found to be equal. If all bytes compare as equal, the \"Length\"-value is returned. If \"Source\" is not ULONG-aligned or if \"Length\" is not a multiple of sizeof(ULONG), zero is returned."]
    pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Compares two blocks of memory and returns the number of bytes that match.\n @param Source1 A pointer to the first block of memory.\n @param Source2 A pointer to the second block of memory.\n @param Length The number of bytes to compare.\n @return The number of bytes in the two blocks that match. If all bytes match, the \"Length\"-value is returned."]
    pub fn RtlCompareMemory(Source1: *const VOID, Source2: *const VOID, Length: SIZE_T) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Converts a single-byte character string (C-style string, NOT an ANSI_STRING object!) to an integer value\n @param String Pointer to a null-terminated single-byte string\n @param Base Specifies the base (decimal, binary, octal, hexadecimal). If not given, the routine looks for prefixes in the given string (0x, 0o, 0b), default is decimal.\n @param Value Pointer to a ULONG variable where the converted value will be stored\n @return STATUS_SUCCESS if the string was successfully converted, STATUS_INVALID_PARAMETER otherwise"]
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: ULONG,
        FramesToCapture: ULONG,
        BackTrace: *mut PVOID,
        BackTraceHash: PULONG,
    ) -> USHORT;
}
extern "stdcall" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "stdcall" {
    #[doc = " Reports a failed assertion to an attached debugger.\n @param FailedAssertion A string containing the expression that made the assertion fail\n @param FileName A string containing the name of the file containing the assertion\n @param LineNumber The linenumber containing the assertion\n @param Message An optional message (will also be shown by the debugger)"]
    pub fn RtlAssert(FailedAssertion: PVOID, FileName: PVOID, LineNumber: ULONG, Message: PCHAR);
}
extern "stdcall" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendUnicodeStringToString(
        Destination: PUNICODE_STRING,
        Source: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendStringToString(Destination: PSTRING, Source: PSTRING) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified ANSI source string into a Unicode string.\n @param DestinationString A pointer to a UNICODE_STRING structure to hold the converted Unicode string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the ANSI_STRING structure that contains the source string to be converted to Unicode.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeUnicodeString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PSTRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Reads a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub static mut PsThreadObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> !;
}
extern "stdcall" {
    pub fn PsSetCreateThreadNotifyRoutine(NotifyRoutine: PCREATE_THREAD_NOTIFY_ROUTINE)
        -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsQueryStatistics(ProcessStatistics: PPS_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThreadEx(
        ThreadHandle: PHANDLE,
        ThreadExtensionSize: SIZE_T,
        KernelStackSize: SIZE_T,
        TlsDataSize: SIZE_T,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        CreateSuspended: BOOLEAN,
        DebuggerThread: BOOLEAN,
        SystemRoutine: PKSYSTEM_ROUTINE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThread(
        ThreadHandle: PHANDLE,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        DebuggerThread: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initialize the ethernet PHY\n @param forceReset Whether to force a reset\n @param param Optional parameters (seemingly unused)\n @return Status code (zero on success)"]
    pub fn PhyInitialize(forceReset: BOOLEAN, param: PVOID) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Returns link status information either from NIC registers or from the last value cached by the kernel\n @param update If FALSE, the kernel returns the cached value, otherwise the hardware is polled and the cached value updated\n @return Flags describing the status of the NIC. See XNET_ETHERNET_LINK bit masks."]
    pub fn PhyGetLinkState(update: BOOLEAN) -> DWORD;
}
extern "C" {
    pub static mut ObpObjectHandleTable: OBJECT_HANDLE_TABLE;
}
extern "C" {
    pub static mut ObSymbolicLinkObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObReferenceObjectByPointer(Object: PVOID, ObjectType: POBJECT_TYPE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByName(
        ObjectName: POBJECT_STRING,
        Attributes: ULONG,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByHandle(
        Handle: HANDLE,
        ObjectType: POBJECT_TYPE,
        ReturnedObject: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByPointer(
        Object: PVOID,
        ObjectType: POBJECT_TYPE,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObMakeTemporaryObject(Object: PVOID);
}
extern "stdcall" {
    pub fn ObInsertObject(
        Object: PVOID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectPointerBias: ULONG,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ObDirectoryObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObCreateObject(
        ObjectType: POBJECT_TYPE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectBodySize: ULONG,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " yields execution of the current thread for one timeslice"]
    pub fn NtYieldExecution() -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtWriteFileGather(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". Also see NtWaitForSingleObject.\n @param Handle The handle to the wait object.\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObjectEx(
        Handle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". When used with a semaphore, the semaphore gets decremented and the threaad continues, or the thread waits until the semaphore-count becomes non-zero and then decrements the seamphore count and continues.\n @param Handle The handle to the wait object.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObject(
        Handle: HANDLE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified objects attain a state of \"signaled\". The wait can be specified to either wait until all objects are signaled or until one of the objects is signaled. Also see NtWaitForSingleObject.\n @param Count Specifies the number of objects that are to be waited on.\n @param Handles An array of handles to wait objects.\n @param WaitType Specifies the type of wait to perform (WaitAll or WaitAny)\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. The index of the object in the array that satisfied the wait is returned. Can also be STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForMultipleObjectsEx(
        Count: ULONG,
        Handles: *const HANDLE,
        WaitType: WAIT_TYPE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtUserIoApcDispatcher(
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Reserved: ULONG,
    );
}
extern "stdcall" {
    #[doc = " Suspends the target thread and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to suspend.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSignalAndWaitForSingleObjectEx(
        SignalHandle: HANDLE,
        WaitHandle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetTimerEx(
        TimerHandle: HANDLE,
        DueTime: PLARGE_INTEGER,
        TimerApcRoutine: PTIMER_APC_ROUTINE,
        ApcMode: KPROCESSOR_MODE,
        TimerContext: PVOID,
        ResumeTimer: BOOLEAN,
        Period: LONG,
        PreviousState: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets the current system time and optionally returns the old system time.\n @param SystemTime A pointer to the new value for the system time.\n @param PreviousTime An optional pointer to a variable that receives the previous system time.\n @return The status of the operation. STATUS_SUCCESS when successfull, STATUS_ACCESS_VIOLATION if the input parameter cannot be read or the output cannot be written, STATUS_INVALID_PARAMETER if the input time is negative."]
    pub fn NtSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state.\n @param EventHandle A HANDLE to the event object to be set.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resumes the target thread (see NtSuspendThread) and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to resume.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtRemoveIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: *mut PVOID,
        ApcContext: *mut PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a semaphore object. When the semaphore is released, the current count of the semaphore is incremented by \"ReleaseCount\". Any threads that are waiting for the semaphore are examined to see if the current semaphore value is sufficient to satisfy their wait. If the value specified by \"ReleaseCount\" would cause the maximum count for the semaphore to be exceeded, then the count for the semaphore is not affected and an error status is returned.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param ReleaseCount The release count for the semaphore. The count must be greater than zero and less than the maximum value specified for the semaphore.\n @param PreviousCount An optional pointer to a variable that receives the previous count for the semaphore.\n @return The status of the release operation, STATUS_SUCCESS on success."]
    pub fn NtReleaseSemaphore(
        SemaphoreHandle: HANDLE,
        ReleaseCount: LONG,
        PreviousCount: PLONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a mutant object (mutex).\n @param MutantHandle The handle to the mutant object.\n @param PreviousCount An optional pointer to a variable that receives the previous mutant count.\n @return The status of the operation."]
    pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFileScatter(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueueApcThread(
        ThreadHandle: HANDLE,
        ApcRoutine: PPS_APC_ROUTINE,
        ApcArgument1: PVOID,
        ApcArgument2: PVOID,
        ApcArgument3: PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVirtualMemory(
        BaseAddress: PVOID,
        MemoryInformation: PMEMORY_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryTimer(
        TimerHandle: HANDLE,
        TimerInformation: PTIMER_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQuerySymbolicLinkObject(
        LinkHandle: HANDLE,
        LinkTarget: POBJECT_STRING,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a semaphore object.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param SemaphoreInformation A pointer to a buffer (SEMAPHORE_BASIC_INFORMATION-structure) that receives the queried information.\n @return The status code of the query operation, STATUS_SUCCESS on success."]
    pub fn NtQuerySemaphore(
        SemaphoreHandle: HANDLE,
        SemaphoreInformation: PSEMAPHORE_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a mutant object.\n @param MutantHandle A handle to a mutant object.\n @param MutantInformation A pointer to a MUTANT_BASIC_INFORMATION-structure that receives the requested information.\n @return The status of the operation."]
    pub fn NtQueryMutant(
        MutantHandle: HANDLE,
        MutantInformation: PMUTANT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryIoCompletion(
        IoCompletionHandle: HANDLE,
        IoCompletionInformation: PIO_COMPLETION_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryFullAttributesFile(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryEvent(
        EventHandle: HANDLE,
        EventInformation: PEVENT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryObject(
        DirectoryHandle: HANDLE,
        Buffer: PVOID,
        Length: ULONG,
        RestartScan: BOOLEAN,
        Context: PULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        FileName: POBJECT_STRING,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state, and immediately resets it to the non-signaled state after waking all waiting threads.\n @param EventHandle A HANDLE to the event object to be pulsed.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtProtectVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        NewProtect: ULONG,
        OldProtect: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenSymbolicLinkObject(
        LinkHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFreeVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDuplicateObject(
        SourceHandle: HANDLE,
        TargetHandle: PHANDLE,
        Options: ULONG,
    ) -> NTSTATUS;
}
pub const _MEDIA_TYPE_Unknown: _MEDIA_TYPE = 0;
pub const _MEDIA_TYPE_F5_1Pt2_512: _MEDIA_TYPE = 1;
pub const _MEDIA_TYPE_F3_1Pt44_512: _MEDIA_TYPE = 2;
pub const _MEDIA_TYPE_F3_2Pt88_512: _MEDIA_TYPE = 3;
pub const _MEDIA_TYPE_F3_20Pt8_512: _MEDIA_TYPE = 4;
pub const _MEDIA_TYPE_F3_720_512: _MEDIA_TYPE = 5;
pub const _MEDIA_TYPE_F5_360_512: _MEDIA_TYPE = 6;
pub const _MEDIA_TYPE_F5_320_512: _MEDIA_TYPE = 7;
pub const _MEDIA_TYPE_F5_320_1024: _MEDIA_TYPE = 8;
pub const _MEDIA_TYPE_F5_180_512: _MEDIA_TYPE = 9;
pub const _MEDIA_TYPE_F5_160_512: _MEDIA_TYPE = 10;
pub const _MEDIA_TYPE_RemovableMedia: _MEDIA_TYPE = 11;
pub const _MEDIA_TYPE_FixedMedia: _MEDIA_TYPE = 12;
pub const _MEDIA_TYPE_F3_120M_512: _MEDIA_TYPE = 13;
pub const _MEDIA_TYPE_F3_640_512: _MEDIA_TYPE = 14;
pub const _MEDIA_TYPE_F5_640_512: _MEDIA_TYPE = 15;
pub const _MEDIA_TYPE_F5_720_512: _MEDIA_TYPE = 16;
pub const _MEDIA_TYPE_F3_1Pt2_512: _MEDIA_TYPE = 17;
pub const _MEDIA_TYPE_F3_1Pt23_1024: _MEDIA_TYPE = 18;
pub const _MEDIA_TYPE_F5_1Pt23_1024: _MEDIA_TYPE = 19;
pub const _MEDIA_TYPE_F3_128Mb_512: _MEDIA_TYPE = 20;
pub const _MEDIA_TYPE_F3_230Mb_512: _MEDIA_TYPE = 21;
pub const _MEDIA_TYPE_F8_256_128: _MEDIA_TYPE = 22;
pub const _MEDIA_TYPE_F3_200Mb_512: _MEDIA_TYPE = 23;
pub const _MEDIA_TYPE_F3_240M_512: _MEDIA_TYPE = 24;
pub const _MEDIA_TYPE_F3_32M_512: _MEDIA_TYPE = 25;
pub type _MEDIA_TYPE = libc::c_int;
pub use self::_MEDIA_TYPE as MEDIA_TYPE;
pub type PMEDIA_TYPE = *mut _MEDIA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GEOMETRY {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
}
#[test]
fn bindgen_test_layout__DISK_GEOMETRY() {
    const UNINIT: ::core::mem::MaybeUninit<_DISK_GEOMETRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISK_GEOMETRY>(),
        24usize,
        concat!("Size of: ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISK_GEOMETRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cylinders) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(Cylinders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MediaType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(MediaType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TracksPerCylinder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(TracksPerCylinder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerTrack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(SectorsPerTrack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type DISK_GEOMETRY = _DISK_GEOMETRY;
pub type PDISK_GEOMETRY = *mut _DISK_GEOMETRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION {
    pub StartingOffset: LARGE_INTEGER,
    pub PartitionLength: LARGE_INTEGER,
    pub HiddenSectors: DWORD,
    pub PartitionNumber: DWORD,
    pub PartitionType: BYTE,
    pub BootIndicator: BOOLEAN,
    pub RecognizedPartition: BOOLEAN,
    pub RewritePartition: BOOLEAN,
}
#[test]
fn bindgen_test_layout__PARTITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_PARTITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PARTITION_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_PARTITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(StartingOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HiddenSectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(HiddenSectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionNumber) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BootIndicator) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(BootIndicator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecognizedPartition) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RecognizedPartition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RewritePartition) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RewritePartition)
        )
    );
}
pub type PARTITION_INFORMATION = _PARTITION_INFORMATION;
pub type PPARTITION_INFORMATION = *mut _PARTITION_INFORMATION;
extern "stdcall" {
    pub fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtCreateTimer(
        TimerHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TimerType: TIMER_TYPE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Create a semaphore object with the specified initial and maximum count.\n @param SemaphoreHandle A pointer to a variable that receives the value of the semaphore object handle.\n @param ObjectAttributes An optional pointer to a structure that specifies the object's attributes.\n @param InitialCount The initial count for the semaphore, this value must be positive and less than or equal to the maximum count.\n @param MaximumCount The maximum count for the semaphore, this value must be greater than zero.\n @return STATUS_SUCCESS on success or error code."]
    pub fn NtCreateSemaphore(
        SemaphoreHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialCount: LONG,
        MaximumCount: LONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates a mutant object (mutex), sets its initial count to one (which means \"signaled\"), and opens a handle to the object.\n @param MutantHandle A pointer to a variable that receives the mutant object handle.\n @param ObjectAttributes A pointer to a OBJECT_ATTRIBUTES-structure that specifies object attributes.\n @pararm InitialOwner A boolean value that specifies whether the creator of the mutant object wants immediate ownership.\n @return The status of the operation."]
    pub fn NtCreateMutant(
        MutantHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialOwner: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateIoCompletion(
        IoCompletionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Count: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates an event object, sets the initial state of the event to the specified value, and opens a handle to the object.\n @param EventHandle A pointer to a variable that will receive the event object handle.\n @param ObjectAttributes A pointer to the object attributes structure supplied by the caller to be used for the specified object.\n @param EventType The type of the event, which can be SynchronizationEvent or a NotificationEvent.\n @param InitialState The initial state of the event object. Set to TRUE to initialize the event object to the Signaled state. Set to FALSE to initialize the event object to the not-Signaled state.\n @return STATUS_SUCCESS when the call is successfull, otherwise an NTSTATUS error code. STATUS_OBJECT_NAME_EXISTS if an event object of the same name already exists and was opened instead of creating a new one."]
    pub fn NtCreateEvent(
        EventHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EventType: EVENT_TYPE,
        InitialState: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Closes an object handle.\n @param Handle Handle to an object\n @return STATE_SUCCESS on success, error code (e.g. STATUS_INVALID_HANDLE, STATUS_HANDLE_NOT_CLOSABLE) otherwise"]
    pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resets an even object to the non-signaled state.\n @param EventHandle A HANDLE to the event object that is to be reset.\n @return STATE_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtAllocateVirtualMemory(
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        Protect: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn MmSetAddressProtect(BaseAddress: PVOID, NumberOfBytes: ULONG, NewProtect: ULONG);
}
extern "stdcall" {
    pub fn MmQueryStatistics(MemoryStatistics: PMM_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmQueryAllocationSize(BaseAddress: PVOID) -> SIZE_T;
}
extern "stdcall" {
    pub fn MmQueryAddressProtect(VirtualAddress: PVOID) -> ULONG;
}
extern "stdcall" {
    #[doc = " Marks a contiguous area of memory to be preserved across a quick reboot.\n @param BaseAddress The virtual address of the memory area.\n @param NumberOfBytes The number of bytes to be preserved.\n @param Persist TRUE if the memory should be persistent, else FALSE."]
    pub fn MmPersistContiguousMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T, Persist: BOOLEAN);
}
extern "stdcall" {
    pub fn MmMapIoSpace(PhysicalAddress: ULONG_PTR, NumberOfBytes: SIZE_T, Protect: ULONG)
        -> PVOID;
}
extern "stdcall" {
    pub fn MmLockUnlockPhysicalPage(PhysicalAddress: ULONG_PTR, UnlockPage: BOOLEAN);
}
extern "stdcall" {
    pub fn MmLockUnlockBufferPages(BaseAddress: PVOID, NumberOfBytes: SIZE_T, UnlockPages: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Checks whether a page fault would occur for a read operation on a specified address.\n @param VirtualAddress The virtual address to be checked.\n @return TRUE if a page fault would occur, FALSE if not."]
    pub fn MmIsAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
extern "C" {
    pub static mut MmGlobalData: MMGLOBALDATA;
}
extern "stdcall" {
    #[doc = " Returns the physical address for a virtual address.\n @param BaseAddress A valid virtual address for which the physical address is to be returned.\n @return The corresponding physical address."]
    pub fn MmGetPhysicalAddress(BaseAddress: PVOID) -> ULONG_PTR;
}
extern "stdcall" {
    pub fn MmFreeSystemMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
extern "stdcall" {
    pub fn MmDeleteKernelStack(KernelStackBase: PVOID, KernelStackLimit: PVOID);
}
extern "stdcall" {
    pub fn MmDbgWriteCheck(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE) -> PVOID;
}
extern "stdcall" {
    pub fn MmDbgReleaseAddress(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE);
}
extern "stdcall" {
    pub fn MmDbgQueryAvailablePages() -> PFN_COUNT;
}
extern "stdcall" {
    pub fn MmDbgFreeMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmDbgAllocateMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmCreateKernelStack(NumberOfBytes: SIZE_T, DebuggerThread: BOOLEAN) -> PVOID;
}
extern "stdcall" {
    pub fn MmClaimGpuInstanceMemory(
        NumberOfBytes: SIZE_T,
        NumberOfPaddingBytes: *mut SIZE_T,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateSystemMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemoryEx(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: ULONG_PTR,
        HighestAcceptableAddress: ULONG_PTR,
        Alignment: ULONG_PTR,
        Protect: ULONG,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemory(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "C" {
    pub static mut LaunchDataPage: PLAUNCH_DATA_PAGE;
}
extern "C" {
    pub static mut KiBugCheckData: [ULONG; 0usize];
}
extern "stdcall" {
    pub fn KeWaitForSingleObject(
        Object: PVOID,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeWaitForMultipleObjects(
        Count: ULONG,
        Object: *mut PVOID,
        WaitType: WAIT_TYPE,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
    ) -> NTSTATUS;
}
extern "C" {
    pub static KeTimeIncrement: ULONG;
}
extern "C" {
    #[doc = " Contains the number of milliseconds elapsed since the system was started."]
    pub static mut KeTickCount: DWORD;
}
extern "stdcall" {
    pub fn KeTestAlertThread(ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "C" {
    pub static mut KeSystemTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeSynchronizeExecution(
        Interrupt: PKINTERRUPT,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSuspendThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    #[doc = " Stalls the caller on the current processor for a specified time Interval.\n @param MicroSeconds Specifies the number of microseconds to stall."]
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
extern "stdcall" {
    pub fn KeSetTimerEx(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: LONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Sets the run-time priority of a thread.\n @param Thread Pointer to the thread.\n @param Priority Specifies the priority of the thread, usually to the real-time priority value, LOW_REALTIME_PRIORITY. The value LOW_PRIORITY is reserved for system use.\n @return Returns the old priority of the thread."]
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetPriorityProcess(Process: PKPROCESS, BasePriority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetEventBoostPriority(Event: PRKEVENT, Thread: *mut PRKTHREAD);
}
extern "stdcall" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeSetDisableBoostThread(Thread: PKTHREAD, Disable: LOGICAL) -> LOGICAL;
}
extern "stdcall" {
    pub fn KeSetBasePriorityThread(Thread: PKTHREAD, Increment: LONG) -> LONG;
}
extern "stdcall" {
    pub fn KeSaveFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeRundownQueue(Queue: PRKQUEUE) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    pub fn KeRestoreFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
extern "stdcall" {
    #[doc = " Removes a DPC object from the deferred procedure call queue\n @param Dpc A pointer to the DPC object"]
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveQueue(
        Queue: PRKQUEUE,
        WaitMode: KPROCESSOR_MODE,
        Timeout: PLARGE_INTEGER,
    ) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveEntryDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeReleaseSemaphore(
        Semaphore: PRKSEMAPHORE,
        Increment: KPRIORITY,
        Adjustment: LONG,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeReleaseMutant(
        Mutant: PRKMUTANT,
        Increment: KPRIORITY,
        Abandoned: BOOLEAN,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToSynchLevel() -> KIRQL;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToDpcLevel() -> KIRQL;
}
extern "stdcall" {
    #[doc = " Obtains the current system time.\n @param CurrentTime The system time in 100-nanosecond intervals since January 1, 1601, in GMT."]
    pub fn KeQuerySystemTime(CurrentTime: PLARGE_INTEGER);
}
extern "stdcall" {
    pub fn KeQueryPerformanceFrequency() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryPerformanceCounter() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryInterruptTime() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryBasePriorityThread(Thread: PKTHREAD) -> LONG;
}
extern "stdcall" {
    pub fn KePulseEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeLeaveCriticalRegion();
}
extern "stdcall" {
    #[doc = " Checks whether the code is executed in a DPC context\n @return TRUE if the code is running in a DPC context, FALSE otherwise"]
    pub fn KeIsExecutingDpc() -> BOOLEAN;
}
extern "C" {
    pub static mut KeInterruptTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID, SystemArgument2: PVOID)
        -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueueApc(
        Apc: PRKAPC,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
        Increment: KPRIORITY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertHeadQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
        SortKey: ULONG,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
extern "stdcall" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG, Limit: LONG);
}
extern "stdcall" {
    pub fn KeInitializeQueue(Queue: PRKQUEUE, Count: ULONG);
}
extern "stdcall" {
    pub fn KeInitializeMutant(Mutant: PRKMUTANT, InitialOwner: BOOLEAN);
}
extern "stdcall" {
    pub fn KeInitializeInterrupt(
        Interrupt: PKINTERRUPT,
        ServiceRoutine: PKSERVICE_ROUTINE,
        ServiceContext: PVOID,
        Vector: ULONG,
        Irql: KIRQL,
        InterruptMode: KINTERRUPT_MODE,
        ShareVector: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE, State: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Initializes a DPC object describing the parameters for a deferred procedure\n call\n @param Dpc Pointer to a DPC struct that gets initialized\n @param DeferredRoutine Pointer to the function that gets called by the DPC\n @param DeferredContext An arbitrary user-defined pointer that gets passed to the procedure when called"]
    pub fn KeInitializeDpc(
        Dpc: *mut KDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
extern "stdcall" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
extern "stdcall" {
    pub fn KeInitializeApc(
        Apc: PRKAPC,
        Thread: PRKTHREAD,
        KernelRoutine: PKKERNEL_ROUTINE,
        RundownRoutine: PKRUNDOWN_ROUTINE,
        NormalRoutine: PKNORMAL_ROUTINE,
        ProcessorMode: KPROCESSOR_MODE,
        NormalContext: PVOID,
    );
}
extern "stdcall" {
    #[doc = " Returns a pointer to the thread object belonging to the current thread.\n @return A pointer to an opaque thread object."]
    pub fn KeGetCurrentThread() -> PKTHREAD;
}
extern "stdcall" {
    pub fn KeGetCurrentIrql() -> KIRQL;
}
extern "stdcall" {
    pub fn KeEnterCriticalRegion();
}
extern "stdcall" {
    pub fn KeDisconnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Puts the current thread into an alertable or nonalertable wait state for a specified interval\n @param WaitMode Specifies the processor mode in which the caller is waiting, which can be either KernelMode or UserMode.\n @param Alertable TRUE if the wait is alertable.\n @param Interval Specifies the absolute or relative time, in units of 100 nanoseconds, for which the wait is to occur. A negative value indicates relative time. Absolute expiration times track any changes in system time, relative expiration times are not affected by system time changes.\n @return STATUS_SUCCESS (the delay completed because the specified interval elapsed), STATUS_ALERTED (the delay completed because the thread was alerted) or STATUS_USER_APC (a user-mode APC was delivered before the specified interval expired)."]
    pub fn KeDelayExecutionThread(
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Interval: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Connects an interrupt object, allowing it to receive interrupts\n @return FALSE if the interrupt is already connected or cannot be connected, TRUE if it was conected successfully"]
    pub fn KeConnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeCancelTimer(Timer: PKTIMER) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeBugCheckEx(
        BugCheckCode: ULONG,
        BugCheckParameter1: ULONG_PTR,
        BugCheckParameter2: ULONG_PTR,
        BugCheckParameter3: ULONG_PTR,
        BugCheckParameter4: ULONG_PTR,
    ) -> !;
}
extern "stdcall" {
    pub fn KeBugCheck(BugCheckCode: ULONG) -> !;
}
extern "stdcall" {
    pub fn KeBoostPriorityThread(Thread: PKTHREAD, Increment: KPRIORITY);
}
extern "stdcall" {
    pub fn KeAlertThread(Thread: PKTHREAD, ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeAlertResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "C" {
    pub static mut KdDebuggerNotPresent: BOOLEAN;
}
extern "C" {
    pub static mut KdDebuggerEnabled: BOOLEAN;
}
extern "stdcall" {
    pub fn IoSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoSynchronousDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        ReturnedOutputBufferLength: PULONG,
        InternalDeviceIoControl: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoStartPacket(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Key: PULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT, Key: ULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoSetShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
    );
}
extern "stdcall" {
    pub fn IoSetIoCompletion(
        IoCompletion: PVOID,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
extern "stdcall" {
    pub fn IoQueueThreadIrp(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoQueryVolumeInformation(
        FileObject: PFILE_OBJECT,
        FsInformationClass: FS_INFORMATION_CLASS,
        Length: ULONG,
        FsInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoQueryFileInformation(
        FileObject: PFILE_OBJECT,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        FileInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoMarkIrpMustComplete(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoInvalidDeviceRequest(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
extern "stdcall" {
    pub fn IoFreeIrp(Irp: PIRP);
}
extern "C" {
    pub static mut IoFileObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDismountVolumeByName(DeviceName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDismountVolume(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub static mut IoDeviceObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoCreateSymbolicLink(
        SymbolicLinkName: POBJECT_STRING,
        DeviceName: POBJECT_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        Options: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateDevice(
        DriverObject: PDRIVER_OBJECT,
        DeviceExtensionSize: ULONG,
        DeviceName: POBJECT_STRING,
        DeviceType: DEVICE_TYPE,
        Exclusive: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut IoCompletionObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoCheckShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoBuildSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        InternalDeviceIoControl: BOOLEAN,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildAsynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoAllocateIrp(StackSize: CCHAR) -> PIRP;
}
extern "C" {
    pub static mut IdexChannelObject: IDE_CHANNEL_OBJECT;
}
extern "stdcall" {
    pub fn HalWriteSMCScratchRegister(ScratchRegister: ULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalWriteSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        WriteWordValue: BOOLEAN,
        DataValue: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReturnToFirmware(Routine: FIRMWARE_REENTRY) -> !;
}
extern "stdcall" {
    #[doc = " Registers or unregisters a shutdown notification which contains a function\n pointer that will be called on shutdown\n @param ShutdownRegistration Pointer to a HAL_SHUTDOWN_REGISTRATION describing the notification settings\n @param Register TRUE to register the notification, FALSE to unregister"]
    pub fn HalRegisterShutdownNotification(
        ShutdownRegistration: PHAL_SHUTDOWN_REGISTRATION,
        Register: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadWritePCISpace(
        BusNumber: ULONG,
        SlotNumber: ULONG,
        RegisterNumber: ULONG,
        Buffer: PVOID,
        Length: ULONG,
        WritePCISpace: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadSMCTrayState(TrayState: PULONG, TrayStateChangeCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReadSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        ReadWordValue: BOOLEAN,
        DataValue: *mut ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Checks whether the console is in the middle of a reset or shutdown sequence.\n @return TRUE if the console is in the middle of a reset or shutdown sequence, else FALSE."]
    pub fn HalIsResetOrShutdownPending() -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Initiates a shutdown. May return if the SMBus-lock is already owned, the shutdown will start as soon as the lock is available."]
    pub fn HalInitiateShutdown();
}
extern "stdcall" {
    pub fn HalGetInterruptVector(BusInterruptLevel: ULONG, Irql: PKIRQL) -> ULONG;
}
extern "stdcall" {
    pub fn HalEnableSystemInterrupt(BusInterruptLevel: ULONG, InterruptMode: KINTERRUPT_MODE);
}
extern "stdcall" {
    #[doc = " Switches the console to secure mode, where a tray eject or tray open interrupt causes the console to reboot. After the console is switched into secure mode, it cannot switch back."]
    pub fn HalEnableSecureTrayEject();
}
extern "C" {
    pub static mut HalDiskSerialNumber: STRING;
}
extern "C" {
    pub static mut HalDiskModelNumber: STRING;
}
extern "C" {
    pub static mut HalDiskCachePartitionCount: ULONG;
}
extern "stdcall" {
    pub fn HalDisableSystemInterrupt(BusInterruptLevel: ULONG);
}
extern "C" {
    pub static mut HalBootSMCVideoMode: DWORD;
}
extern "stdcall" {
    pub fn FscSetCacheSize(NumberOfCachePages: PFN_COUNT) -> NTSTATUS;
}
extern "stdcall" {
    pub fn FscInvalidateIdleBlocks();
}
extern "stdcall" {
    pub fn FscGetCacheSize() -> PFN_COUNT;
}
extern "C" {
    pub static mut ExTimerObjectType: OBJECT_TYPE;
}
extern "C" {
    pub static mut ExSemaphoreObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExSaveNonVolatileSetting(
        ValueIndex: ULONG,
        Type: ULONG,
        Value: PVOID,
        ValueLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExReleaseReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExReadWriteRefurbInfo(
        RefurbInfo: *mut XBOX_REFURB_INFO,
        ValueLength: ULONG,
        DoWrite: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn ExRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    #[doc = " Returns the size of the pool block.\n @param PoolBlock The address of the pool block.\n @return The size of the pool block."]
    pub fn ExQueryPoolBlockSize(PoolBlock: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn ExQueryNonVolatileSetting(
        ValueIndex: ULONG,
        Type: PULONG,
        Value: PVOID,
        ValueLength: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ExMutantObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExInterlockedAddLargeInteger(
        Addend: PLARGE_INTEGER,
        Increment: LARGE_INTEGER,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn ExInitializeReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    #[doc = " Deallocates a block of pool memory.\n @param P Specifies the address of the block of pool memory being deallocated."]
    pub fn ExFreePool(P: PVOID);
}
extern "C" {
    pub static mut ExEventObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @param Tag The pool tag to use for the allocated memory. Specify the pool tag as a character literal of up to four characters delimited by single quotation marks (for example, 'Tag1'). The string is usually specified in reverse order (for example, '1gaT'). Each ASCII character in the tag must be a value in the range 0x20 (space) to 0x126 (tilde). Each allocation code path should use a unique pool tag to help debuggers and verifiers identify the code path.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePoolWithTag(NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePool(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockShared(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockExclusive(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn DbgUnLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    #[doc = " WARNING: This function crashes my XBox, so probably don't use.\n Displays a prompt-string on the debugging console, then reads a line of text from the debugging console.\n @param Prompt The string that gets output on the debugging console.\n @param Response Specifies where to store the response string read from the debugging console.\n @param MaximumResponseLength Maximum number of characters that fit into the response-buffer.\n @return Number of characters stored into the response buffer, including newline."]
    pub fn DbgPrompt(Prompt: PCH, Response: PCH, MaximumResponseLength: ULONG) -> ULONG;
}
extern "C" {
    #[doc = " \"printf\"-style output function for the kernel debugger.\n @param Format \"printf\"-style format string\n @param ... Arguments matching the format string.\n @return A status-code."]
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
extern "stdcall" {
    pub fn DbgLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
extern "stdcall" {
    pub fn DbgBreakPoint();
}
extern "stdcall" {
    pub fn AvSetSavedDataAddress(Address: PVOID);
}
extern "stdcall" {
    pub fn AvSetDisplayMode(
        RegisterBase: PVOID,
        Step: ULONG,
        DisplayMode: ULONG,
        SourceColorFormat: ULONG,
        Pitch: ULONG,
        FrameBuffer: ULONG,
    ) -> ULONG;
}
extern "stdcall" {
    pub fn AvSendTVEncoderOption(RegisterBase: PVOID, Option: ULONG, Param: ULONG, Result: PULONG);
}
extern "stdcall" {
    pub fn AvGetSavedDataAddress() -> PVOID;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a USHORT\n @param Source The USHORT-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUshortByteSwap(Source: USHORT) -> USHORT;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a ULONG\n @param Source The ULONG-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUlongByteSwap(Source: ULONG) -> ULONG;
}
extern "fastcall" {
    pub fn ObfReferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn ObfDereferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn KiUnlockDispatcherDatabase(OldIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Raises the hardware priority to the specified IRQL value, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n @param NewIrql Specifies the new IRQL to which the hardware priority is to be raised.\n @return The original IRQL value to be used in a subsequent call to KfLowerIrql."]
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
extern "fastcall" {
    #[doc = " Restores the IRQL on the current processor to its original value.\n @param NewIrql Specifies the IRQL that was returned from KfRaiseIrql."]
    pub fn KfLowerIrql(NewIrql: KIRQL);
}
extern "fastcall" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
extern "fastcall" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "fastcall" {
    pub fn InterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSINGLE_LIST_ENTRY,
    ) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically increments a LONG-value\n @param Addend Pointer to the LONG-variable which is to be incremented\n @return The resulting incremented value (also stored at 'Addend')"]
    pub fn InterlockedIncrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedExchangeAdd(Addend: *mut LONG, Increment: LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedExchange(Target: *mut LONG, Value: LONG) -> LONG;
}
extern "fastcall" {
    #[doc = " Atomically decrements a LONG-value\n @param Addend Pointer to the LONG-variable which is to be decremented\n @return The resulting decremented value (also stored at 'Addend')"]
    pub fn InterlockedDecrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedCompareExchange(
        Destination: *mut LONG,
        ExChange: LONG,
        Comparand: LONG,
    ) -> LONG;
}
extern "fastcall" {
    #[doc = " Requests a software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalRequestSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Clears a possible pending software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalClearSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Atomically removes an entry from the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @return A pointer to the LIST_ENTRY which was removed from the list (NULL if the list was empty)."]
    pub fn ExfInterlockedRemoveHeadList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the end of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the last list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertTailList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the first list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertHeadList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Compares one integer variable to another and, if they're equal, sets the first variable to a caller-supplied value.\n @param Destination A pointer to an integer that will be compared and possibly replaced.\n @param Exchange A pointer to an integer that will replace the one at Destination if the comparison results in equality.\n @param Comparand A pointer to an integer with which the value at Destination will be compared.\n @return The inital value of the variable at Destination when the call occured."]
    pub fn ExInterlockedCompareExchange64(
        Destination: *mut LONGLONG,
        Exchange: PLONGLONG,
        Comparand: PLONGLONG,
    ) -> LONGLONG;
}
extern "fastcall" {
    #[doc = " Performs an interlocked addition of a ULONG increment value to a LARGE_INTEGER variable.\n @param Addend A pointer to the LARGE_INTEGER variable that is incremented by the value of Increment.\n @param Increment Specifies a ULONG value that is added to the variable that Addend points to."]
    pub fn ExInterlockedAddLargeStatistic(Addend: PLARGE_INTEGER, Increment: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STATUS_LOCATION {
    pub _address: u8,
}
