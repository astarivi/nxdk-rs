/* automatically generated by rust-bindgen 0.64.0 */

pub const MAXDWORD: u32 = 4294967295;
pub const CONTEXT_X86: u32 = 65536;
pub const CONTEXT_i386: u32 = 65536;
pub const CONTEXT_CONTROL: u32 = 65537;
pub const CONTEXT_INTEGER: u32 = 65538;
pub const CONTEXT_SEGMENTS: u32 = 65540;
pub const CONTEXT_FLOATING_POINT: u32 = 65544;
pub const CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const INVALID_FILE_ATTRIBUTES: u32 = 4294967295;
pub type LPCVOID = *const libc::c_void;
pub type VOID = libc::c_void;
pub type PVOID = *mut libc::c_void;
pub type LPVOID = *mut libc::c_void;
pub type HANDLE = PVOID;
pub type PHANDLE = *mut PVOID;
pub type BOOLEAN = libc::c_uchar;
pub type PBOOLEAN = *mut libc::c_uchar;
pub type SCHAR = libc::c_schar;
pub type PSCHAR = *mut libc::c_schar;
pub type CHAR = libc::c_char;
pub type PCHAR = *mut libc::c_char;
pub type CCHAR = libc::c_char;
pub type LPCH = *mut libc::c_char;
pub type PCH = *mut libc::c_char;
pub type OCHAR = libc::c_char;
pub type POCHAR = *mut libc::c_char;
pub type SHORT = libc::c_short;
pub type PSHORT = *mut libc::c_short;
pub type INT = libc::c_int;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type LONG = libc::c_long;
pub type PLONG = *mut libc::c_long;
pub type LPLONG = *mut libc::c_long;
pub type LONGLONG = libc::c_longlong;
pub type PLONGLONG = *mut libc::c_longlong;
pub type BYTE = libc::c_uchar;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut libc::c_ushort;
pub type CSHORT = libc::c_ushort;
pub type WORD = libc::c_ushort;
pub type WCHAR = libc::c_ushort;
pub type PWSTR = *mut libc::c_ushort;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
pub type LPUINT = *mut libc::c_uint;
pub type DWORD = libc::c_ulong;
pub type PDWORD = *mut libc::c_ulong;
pub type LPDWORD = *mut libc::c_ulong;
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut libc::c_ulong;
pub type ULONGLONG = libc::c_ulonglong;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SIZE_T = libc::c_uint;
pub type PSIZE_T = *mut libc::c_uint;
pub type BOOL = libc::c_int;
pub type PBOOL = *mut libc::c_int;
pub type PCSZ = *const libc::c_char;
pub type PCSTR = *const libc::c_char;
pub type LPCSTR = *const libc::c_char;
pub type QUAD = ULONGLONG;
pub type ULONG_PTR = ULONG;
pub type LONG_PTR = LONG;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: WORD,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub MXCsr: DWORD,
    pub Reserved2: DWORD,
    pub RegisterArea: [BYTE; 128usize],
    pub XmmRegisterArea: [BYTE; 128usize],
    pub Reserved4: [BYTE; 224usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__FLOATING_SAVE_AREA() {
    const UNINIT: ::core::mem::MaybeUninit<_FLOATING_SAVE_AREA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLOATING_SAVE_AREA>(),
        516usize,
        concat!("Size of: ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::core::mem::align_of::<_FLOATING_SAVE_AREA>(),
        1usize,
        concat!("Alignment of ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MXCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(MXCsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegisterArea) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XmmRegisterArea) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(XmmRegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut _FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    pub ContextFlags: DWORD,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CONTEXT>(),
        568usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edi) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esi) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebx) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edx) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ecx) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eax) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eip) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esp) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_RECORD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_RECORD>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_RECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut _EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = *mut STRING;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "< A signed 64-bit integer."]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type PLARGE_INTEGER = *mut _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "< An unsigned 64-bit integer."]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits. */ /**< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type PULARGE_INTEGER = *mut _ULARGE_INTEGER;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "< Points to the next entry of the list or the header if there is no next entry"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "< Points to the previous entry of the list or the header if there is no previous entry"]
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type LIST_ENTRY = _LIST_ENTRY;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub Synchronization: _RTL_CRITICAL_SECTION__bindgen_ty_1,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_CRITICAL_SECTION__bindgen_ty_1 {
    pub Event: _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1,
    pub RawEvent: [ULONG; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaitListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(Event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RawEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(RawEvent)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        28usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Synchronization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(Synchronization)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_SECTION_HEADER {
    pub Flags: DWORD,
    pub VirtualAddress: DWORD,
    pub VirtualSize: DWORD,
    pub FileAddress: DWORD,
    pub FileSize: DWORD,
    pub SectionName: PCSZ,
    pub SectionReferenceCount: LONG,
    pub HeadReferenceCount: *mut WORD,
    pub TailReferenceCount: *mut WORD,
    pub CheckSum: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__XBE_SECTION_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_SECTION_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_SECTION_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionReferenceCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadReferenceCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(HeadReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TailReferenceCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(TailReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
}
pub type XBE_SECTION_HEADER = _XBE_SECTION_HEADER;
pub type PXBE_SECTION_HEADER = *mut _XBE_SECTION_HEADER;
extern "C" {
    pub fn nxXbeGetSectionByName(name: *const libc::c_char) -> PXBE_SECTION_HEADER;
}
