/* automatically generated by rust-bindgen 0.69.5 */

pub const MAXDWORD: u32 = 4294967295;
pub const CONTEXT_X86: u32 = 65536;
pub const CONTEXT_i386: u32 = 65536;
pub const CONTEXT_CONTROL: u32 = 65537;
pub const CONTEXT_INTEGER: u32 = 65538;
pub const CONTEXT_SEGMENTS: u32 = 65540;
pub const CONTEXT_FLOATING_POINT: u32 = 65544;
pub const CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const INVALID_FILE_ATTRIBUTES: u32 = 4294967295;
pub type LPCVOID = *const libc::c_void;
pub type VOID = libc::c_void;
pub type PVOID = *mut libc::c_void;
pub type LPVOID = *mut libc::c_void;
pub type HANDLE = PVOID;
pub type PHANDLE = *mut PVOID;
pub type BOOLEAN = libc::c_uchar;
pub type PBOOLEAN = *mut libc::c_uchar;
pub type SCHAR = libc::c_schar;
pub type PSCHAR = *mut libc::c_schar;
pub type CHAR = libc::c_char;
pub type PCHAR = *mut libc::c_char;
pub type CCHAR = libc::c_char;
pub type LPCH = *mut libc::c_char;
pub type PCH = *mut libc::c_char;
pub type OCHAR = libc::c_char;
pub type POCHAR = *mut libc::c_char;
pub type SHORT = libc::c_short;
pub type PSHORT = *mut libc::c_short;
pub type INT = libc::c_int;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type LONG = libc::c_long;
pub type PLONG = *mut libc::c_long;
pub type LPLONG = *mut libc::c_long;
pub type LONGLONG = libc::c_longlong;
pub type PLONGLONG = *mut libc::c_longlong;
pub type BYTE = libc::c_uchar;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut libc::c_ushort;
pub type CSHORT = libc::c_ushort;
pub type WORD = libc::c_ushort;
pub type WCHAR = libc::c_ushort;
pub type PWSTR = *mut libc::c_ushort;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
pub type LPUINT = *mut libc::c_uint;
pub type DWORD = libc::c_ulong;
pub type PDWORD = *mut libc::c_ulong;
pub type LPDWORD = *mut libc::c_ulong;
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut libc::c_ulong;
pub type ULONGLONG = libc::c_ulonglong;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SIZE_T = libc::c_uint;
pub type PSIZE_T = *mut libc::c_uint;
pub type BOOL = libc::c_int;
pub type PBOOL = *mut libc::c_int;
pub type PCSZ = *const libc::c_char;
pub type PCSTR = *const libc::c_char;
pub type LPCSTR = *const libc::c_char;
pub type QUAD = ULONGLONG;
pub type ULONG_PTR = ULONG;
pub type LONG_PTR = LONG;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: WORD,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub MXCsr: DWORD,
    pub Reserved2: DWORD,
    pub RegisterArea: [BYTE; 128usize],
    pub XmmRegisterArea: [BYTE; 128usize],
    pub Reserved4: [BYTE; 224usize],
    pub Cr0NpxState: DWORD,
}
pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut _FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    pub ContextFlags: DWORD,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut _EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = *mut STRING;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "< A signed 64-bit integer."]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type PLARGE_INTEGER = *mut _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "< An unsigned 64-bit integer."]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits. */ /**< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type PULARGE_INTEGER = *mut _ULARGE_INTEGER;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "< Points to the next entry of the list or the header if there is no next entry"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "< Points to the previous entry of the list or the header if there is no previous entry"]
    pub Blink: *mut _LIST_ENTRY,
}
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type LIST_ENTRY = _LIST_ENTRY;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub Synchronization: _RTL_CRITICAL_SECTION__bindgen_ty_1,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_CRITICAL_SECTION__bindgen_ty_1 {
    pub Event: _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1,
    pub RawEvent: [ULONG; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_SECTION_HEADER {
    pub Flags: DWORD,
    pub VirtualAddress: DWORD,
    pub VirtualSize: DWORD,
    pub FileAddress: DWORD,
    pub FileSize: DWORD,
    pub SectionName: PCSZ,
    pub SectionReferenceCount: LONG,
    pub HeadReferenceCount: *mut WORD,
    pub TailReferenceCount: *mut WORD,
    pub CheckSum: [BYTE; 20usize],
}
pub type XBE_SECTION_HEADER = _XBE_SECTION_HEADER;
pub type PXBE_SECTION_HEADER = *mut _XBE_SECTION_HEADER;
extern "C" {
    pub fn nxXbeGetSectionByName(name: *const libc::c_char) -> PXBE_SECTION_HEADER;
}
