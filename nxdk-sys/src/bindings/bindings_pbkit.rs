/* automatically generated by rust-bindgen 0.69.5 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const MAXDWORD: u32 = 4294967295;
pub const CONTEXT_X86: u32 = 65536;
pub const CONTEXT_i386: u32 = 65536;
pub const CONTEXT_CONTROL: u32 = 65537;
pub const CONTEXT_INTEGER: u32 = 65538;
pub const CONTEXT_SEGMENTS: u32 = 65540;
pub const CONTEXT_FLOATING_POINT: u32 = 65544;
pub const CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const INVALID_FILE_ATTRIBUTES: u32 = 4294967295;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const AV_PACK_NONE: u32 = 0;
pub const AV_PACK_STANDARD: u32 = 1;
pub const AV_PACK_RFU: u32 = 2;
pub const AV_PACK_SCART: u32 = 3;
pub const AV_PACK_HDTV: u32 = 4;
pub const AV_PACK_VGA: u32 = 5;
pub const AV_PACK_SVIDEO: u32 = 6;
pub const PAGE_SIZE: u32 = 4096;
pub const OBJ_INHERIT: u32 = 2;
pub const OBJ_PERMANENT: u32 = 16;
pub const OBJ_EXCLUSIVE: u32 = 32;
pub const OBJ_CASE_INSENSITIVE: u32 = 64;
pub const OBJ_OPENIF: u32 = 128;
pub const OBJ_OPENLINK: u32 = 256;
pub const OBJ_VALID_ATTRIBUTES: u32 = 498;
pub const LDT_TITLE: u32 = 0;
pub const LDT_LAUNCH_DASHBOARD: u32 = 1;
pub const LDT_FROM_DASHBOARD: u32 = 2;
pub const LDT_NONE: u32 = 4294967295;
pub const XBOX_HW_FLAG_INTERNAL_USB_HUB: u32 = 1;
pub const XBOX_HW_FLAG_DEVKIT_KERNEL: u32 = 2;
pub const XBOX_480P_MACROVISION_ENABLED: u32 = 4;
pub const XBOX_HW_FLAG_ARCADE: u32 = 8;
pub const XBOX_KEY_LENGTH: u32 = 16;
pub const IRP_NOCACHE: u32 = 1;
pub const IRP_MOUNT_COMPLETION: u32 = 2;
pub const IRP_SYNCHRONOUS_API: u32 = 4;
pub const IRP_CREATE_OPERATION: u32 = 8;
pub const IRP_READ_OPERATION: u32 = 16;
pub const IRP_WRITE_OPERATION: u32 = 32;
pub const IRP_CLOSE_OPERATION: u32 = 64;
pub const IRP_DEFER_IO_COMPLETION: u32 = 128;
pub const IRP_OB_QUERY_NAME: u32 = 256;
pub const IRP_UNLOCK_USER_BUFFER: u32 = 512;
pub const IRP_SCATTER_GATHER_OPERATION: u32 = 1024;
pub const IRP_UNMAP_SEGMENT_ARRAY: u32 = 2048;
pub const IRP_NO_CANCELIO: u32 = 4096;
pub const LOW_PRIORITY: u32 = 0;
pub const LOW_REALTIME_PRIORITY: u32 = 16;
pub const HIGH_PRIORITY: u32 = 31;
pub const MAXIMUM_PRIORITY: u32 = 32;
pub const XNET_ETHERNET_LINK_ACTIVE: u32 = 1;
pub const XNET_ETHERNET_LINK_100MBPS: u32 = 2;
pub const XNET_ETHERNET_LINK_10MBPS: u32 = 4;
pub const XNET_ETHERNET_LINK_FULL_DUPLEX: u32 = 8;
pub const XNET_ETHERNET_LINK_HALF_DUPLEX: u32 = 16;
pub const METHOD_BUFFERED: u32 = 0;
pub const METHOD_IN_DIRECT: u32 = 1;
pub const METHOD_OUT_DIRECT: u32 = 2;
pub const METHOD_NEITHER: u32 = 3;
pub const FILE_ANY_ACCESS: u32 = 0;
pub const FILE_READ_ACCESS: u32 = 1;
pub const FILE_WRITE_ACCESS: u32 = 2;
pub const FILE_DEVICE_FILE_SYSTEM: u32 = 9;
pub const IOCTL_DISK_BASE: u32 = 7;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_DIRECTORY_FILE: u32 = 1;
pub const FILE_WRITE_THROUGH: u32 = 2;
pub const FILE_SEQUENTIAL_ONLY: u32 = 4;
pub const FILE_NO_INTERMEDIATE_BUFFERING: u32 = 8;
pub const FILE_SYNCHRONOUS_IO_ALERT: u32 = 16;
pub const FILE_SYNCHRONOUS_IO_NONALERT: u32 = 32;
pub const FILE_NON_DIRECTORY_FILE: u32 = 64;
pub const FILE_CREATE_TREE_CONNECTION: u32 = 128;
pub const FILE_COMPLETE_IF_OPLOCKED: u32 = 256;
pub const FILE_NO_EA_KNOWLEDGE: u32 = 512;
pub const FILE_OPEN_FOR_RECOVERY: u32 = 1024;
pub const FILE_RANDOM_ACCESS: u32 = 2048;
pub const FILE_DELETE_ON_CLOSE: u32 = 4096;
pub const FILE_OPEN_BY_FILE_ID: u32 = 8192;
pub const FILE_OPEN_FOR_BACKUP_INTENT: u32 = 16384;
pub const FILE_NO_COMPRESSION: u32 = 32768;
pub const FILE_RESERVE_OPFILTER: u32 = 1048576;
pub const FILE_OPEN_REPARSE_POINT: u32 = 2097152;
pub const FILE_OPEN_NO_RECALL: u32 = 4194304;
pub const FILE_OPEN_FOR_FREE_SPACE_QUERY: u32 = 8388608;
pub const FILE_COPY_STRUCTURED_STORAGE: u32 = 65;
pub const FILE_STRUCTURED_STORAGE: u32 = 1089;
pub const FILE_VALID_OPTION_FLAGS: u32 = 16777215;
pub const FILE_VALID_PIPE_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_MAILSLOT_OPTION_FLAGS: u32 = 50;
pub const FILE_VALID_SET_FLAGS: u32 = 54;
pub const FILE_SUPERSEDE: u32 = 0;
pub const FILE_OPEN: u32 = 1;
pub const FILE_CREATE: u32 = 2;
pub const FILE_OPEN_IF: u32 = 3;
pub const FILE_OVERWRITE: u32 = 4;
pub const FILE_OVERWRITE_IF: u32 = 5;
pub const FILE_MAXIMUM_DISPOSITION: u32 = 5;
pub const FILE_SUPERSEDED: u32 = 0;
pub const FILE_OPENED: u32 = 1;
pub const FILE_CREATED: u32 = 2;
pub const FILE_OVERWRITTEN: u32 = 3;
pub const FILE_EXISTS: u32 = 4;
pub const FILE_DOES_NOT_EXIST: u32 = 5;
pub const ERESOURCE_INCREMENT: u32 = 4;
pub const EVENT_INCREMENT: u32 = 1;
pub const EVENT_PAIR_INCREMENT: u32 = 1;
pub const LPC_RELEASE_WAIT_INCREMENT: u32 = 1;
pub const IO_NO_INCREMENT: u32 = 0;
pub const IO_CD_ROM_INCREMENT: u32 = 1;
pub const IO_DISK_INCREMENT: u32 = 1;
pub const IO_PARALLEL_INCREMENT: u32 = 1;
pub const IO_VIDEO_INCREMENT: u32 = 1;
pub const IO_MAILSLOT_INCREMENT: u32 = 2;
pub const IO_NAMED_PIPE_INCREMENT: u32 = 2;
pub const IO_NETWORK_INCREMENT: u32 = 2;
pub const IO_SERIAL_INCREMENT: u32 = 2;
pub const IO_MOUSE_INCREMENT: u32 = 6;
pub const IO_KEYBOARD_INCREMENT: u32 = 6;
pub const IO_SOUND_INCREMENT: u32 = 8;
pub const MUTANT_INCREMENT: u32 = 1;
pub const SEMAPHORE_INCREMENT: u32 = 1;
pub const TIMER_APC_INCREMENT: u32 = 0;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_VIDEO: u32 = 0;
pub const PAGE_OLD_VIDEO: u32 = 2048;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_NOZERO: u32 = 8388608;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const XC_TIMEZONE_BIAS: u32 = 0;
pub const XC_TZ_STD_NAME: u32 = 1;
pub const XC_TZ_STD_DATE: u32 = 2;
pub const XC_TZ_STD_BIAS: u32 = 3;
pub const XC_TZ_DLT_NAME: u32 = 4;
pub const XC_TZ_DLT_DATE: u32 = 5;
pub const XC_TZ_DLT_BIAS: u32 = 6;
pub const XC_LANGUAGE: u32 = 7;
pub const XC_VIDEO: u32 = 8;
pub const XC_AUDIO: u32 = 9;
pub const XC_P_CONTROL_GAMES: u32 = 10;
pub const XC_P_CONTROL_PASSWORD: u32 = 11;
pub const XC_P_CONTROL_MOVIES: u32 = 12;
pub const XC_ONLINE_IP_ADDRESS: u32 = 13;
pub const XC_ONLINE_DNS_ADDRESS: u32 = 14;
pub const XC_ONLINE_DEFAULT_GATEWAY_ADDRESS: u32 = 15;
pub const XC_ONLINE_SUBNET_ADDRESS: u32 = 16;
pub const XC_MISC: u32 = 17;
pub const XC_DVD_REGION: u32 = 18;
pub const XC_MAX_OS: u32 = 255;
pub const XC_FACTORY_START_INDEX: u32 = 256;
pub const XC_FACTORY_SERIAL_NUMBER: u32 = 256;
pub const XC_FACTORY_ETHERNET_ADDR: u32 = 257;
pub const XC_FACTORY_ONLINE_KEY: u32 = 258;
pub const XC_FACTORY_AV_REGION: u32 = 259;
pub const XC_FACTORY_GAME_REGION: u32 = 260;
pub const XC_MAX_FACTORY: u32 = 511;
pub const XC_ENCRYPTED_SECTION: u32 = 65534;
pub const XC_MAX_ALL: u32 = 65535;
pub const XC_MISC_FLAG_DISABLE_DST: u32 = 2;
pub const __STDC_WANT_LIB_EXT1_PREVIOUS__: i32 = -1;
pub const _PDCLIB_endl: &[u8; 2] = b"\n\0";
pub const _PDCLIB_SUCCESS: u32 = 0;
pub const _PDCLIB_FAILURE: i32 = -1;
pub const _PDCLIB_CHAR_SIGNED: u32 = 1;
pub const _PDCLIB_SHRT_BYTES: u32 = 2;
pub const _PDCLIB_INT_BYTES: u32 = 4;
pub const _PDCLIB_LONG_BYTES: u32 = 4;
pub const _PDCLIB_LLONG_BYTES: u32 = 8;
pub const _PDCLIB_CLOCKS_PER_SEC: u32 = 1000;
pub const _PDCLIB_TIME_UTC: u32 = 1;
pub const _PDCLIB_FLT_ROUNDS: i32 = -1;
pub const _PDCLIB_FLT_EVAL_METHOD: i32 = -1;
pub const _PDCLIB_DECIMAL_DIG: u32 = 17;
pub const _PDCLIB_PAGESIZE: u32 = 4096;
pub const _PDCLIB_MINALLOC: u32 = 8;
pub const _PDCLIB_BUFSIZ: u32 = 1024;
pub const _PDCLIB_FOPEN_MAX: u32 = 8;
pub const _PDCLIB_FILENAME_MAX: u32 = 128;
pub const _PDCLIB_L_tmpnam: u32 = 46;
pub const _PDCLIB_TMP_MAX: u32 = 50;
pub const _PDCLIB_SEEK_SET: u32 = 0;
pub const _PDCLIB_SEEK_CUR: u32 = 1;
pub const _PDCLIB_SEEK_END: u32 = 2;
pub const _PDCLIB_UNGETCBUFSIZE: u32 = 1;
pub const _PDCLIB_ATEXIT_SLOTS: u32 = 40;
pub const _PDCLIB_E2BIG: u32 = 7;
pub const _PDCLIB_EACCES: u32 = 13;
pub const _PDCLIB_EADDRINUSE: u32 = 100;
pub const _PDCLIB_EADDRNOTAVAIL: u32 = 101;
pub const _PDCLIB_EAFNOSUPPORT: u32 = 102;
pub const _PDCLIB_EAGAIN: u32 = 11;
pub const _PDCLIB_EALREADY: u32 = 103;
pub const _PDCLIB_EBADF: u32 = 9;
pub const _PDCLIB_EBADMSG: u32 = 104;
pub const _PDCLIB_EBUSY: u32 = 16;
pub const _PDCLIB_ECANCELED: u32 = 105;
pub const _PDCLIB_ECHILD: u32 = 10;
pub const _PDCLIB_ECONNABORTED: u32 = 106;
pub const _PDCLIB_ECONNREFUSED: u32 = 107;
pub const _PDCLIB_ECONNRESET: u32 = 108;
pub const _PDCLIB_EDEADLK: u32 = 36;
pub const _PDCLIB_EDESTADDRREQ: u32 = 109;
pub const _PDCLIB_EDOM: u32 = 33;
pub const _PDCLIB_EEXIST: u32 = 17;
pub const _PDCLIB_EFAULT: u32 = 14;
pub const _PDCLIB_EFBIG: u32 = 27;
pub const _PDCLIB_EHOSTUNREACH: u32 = 110;
pub const _PDCLIB_EIDRM: u32 = 111;
pub const _PDCLIB_EILSEQ: u32 = 42;
pub const _PDCLIB_EINPROGRESS: u32 = 112;
pub const _PDCLIB_EINTR: u32 = 4;
pub const _PDCLIB_EINVAL: u32 = 22;
pub const _PDCLIB_EIO: u32 = 5;
pub const _PDCLIB_EISCONN: u32 = 113;
pub const _PDCLIB_EISDIR: u32 = 21;
pub const _PDCLIB_ELOOP: u32 = 114;
pub const _PDCLIB_EMFILE: u32 = 24;
pub const _PDCLIB_EMLINK: u32 = 31;
pub const _PDCLIB_EMSGSIZE: u32 = 115;
pub const _PDCLIB_ENAMETOOLONG: u32 = 38;
pub const _PDCLIB_ENETDOWN: u32 = 116;
pub const _PDCLIB_ENETRESET: u32 = 117;
pub const _PDCLIB_ENETUNREACH: u32 = 118;
pub const _PDCLIB_ENFILE: u32 = 23;
pub const _PDCLIB_ENOBUFS: u32 = 119;
pub const _PDCLIB_ENODATA: u32 = 120;
pub const _PDCLIB_ENODEV: u32 = 19;
pub const _PDCLIB_ENOENT: u32 = 2;
pub const _PDCLIB_ENOEXEC: u32 = 8;
pub const _PDCLIB_ENOLCK: u32 = 39;
pub const _PDCLIB_ENOLINK: u32 = 121;
pub const _PDCLIB_ENOMEM: u32 = 12;
pub const _PDCLIB_ENOMSG: u32 = 122;
pub const _PDCLIB_ENOPROTOOPT: u32 = 123;
pub const _PDCLIB_ENOSPC: u32 = 28;
pub const _PDCLIB_ENOSR: u32 = 124;
pub const _PDCLIB_ENOSTR: u32 = 125;
pub const _PDCLIB_ENOSYS: u32 = 40;
pub const _PDCLIB_ENOTCONN: u32 = 126;
pub const _PDCLIB_ENOTDIR: u32 = 20;
pub const _PDCLIB_ENOTEMPTY: u32 = 41;
pub const _PDCLIB_ENOTRECOVERABLE: u32 = 127;
pub const _PDCLIB_ENOTSOCK: u32 = 128;
pub const _PDCLIB_ENOTSUP: u32 = 129;
pub const _PDCLIB_ENOTTY: u32 = 25;
pub const _PDCLIB_ENXIO: u32 = 6;
pub const _PDCLIB_EOPNOTSUPP: u32 = 130;
pub const _PDCLIB_EOVERFLOW: u32 = 132;
pub const _PDCLIB_EOWNERDEAD: u32 = 133;
pub const _PDCLIB_EPERM: u32 = 1;
pub const _PDCLIB_EPIPE: u32 = 32;
pub const _PDCLIB_EPROTO: u32 = 134;
pub const _PDCLIB_EPROTONOSUPPORT: u32 = 135;
pub const _PDCLIB_EPROTOTYPE: u32 = 136;
pub const _PDCLIB_ERANGE: u32 = 34;
pub const _PDCLIB_EROFS: u32 = 30;
pub const _PDCLIB_ESPIPE: u32 = 29;
pub const _PDCLIB_ESRCH: u32 = 3;
pub const _PDCLIB_ETIME: u32 = 137;
pub const _PDCLIB_ETIMEDOUT: u32 = 138;
pub const _PDCLIB_ETXTBSY: u32 = 139;
pub const _PDCLIB_EWOULDBLOCK: u32 = 140;
pub const _PDCLIB_EXDEV: u32 = 18;
pub const _PDCLIB_ERRNO_MAX: u32 = 141;
pub const _PDCLIB_LOCALE_PATH: &[u8; 23] = b"/usr/share/pdclib/i18n\0";
pub const _PDCLIB_ONCE_FLAG_INIT: u32 = 0;
pub const _PDCLIB_TSS_DTOR_ITERATIONS: u32 = 4;
pub const _PDCLIB_HOSTED: u32 = 1;
pub const _PDCLIB_NULL: u32 = 0;
pub const _PDCLIB_CHAR_BIT: u32 = 8;
pub const _PDCLIB_UCHAR_MIN: u32 = 0;
pub const _PDCLIB_UCHAR_MAX: u32 = 255;
pub const _PDCLIB_SCHAR_MIN: i32 = -128;
pub const _PDCLIB_SCHAR_MAX: u32 = 127;
pub const _PDCLIB_CHAR_MIN: i32 = -128;
pub const _PDCLIB_CHAR_MAX: u32 = 127;
pub const _PDCLIB_SHRT_MAX: u32 = 32767;
pub const _PDCLIB_SHRT_MIN: i32 = -32768;
pub const _PDCLIB_USHRT_MAX: u32 = 65535;
pub const _PDCLIB_USHRT_MIN: u32 = 0;
pub const _PDCLIB_INT_MAX: u32 = 2147483647;
pub const _PDCLIB_INT_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT_MAX: u32 = 4294967295;
pub const _PDCLIB_UINT_MIN: u32 = 0;
pub const _PDCLIB_LONG_MAX: u32 = 2147483647;
pub const _PDCLIB_LONG_MIN: i32 = -2147483648;
pub const _PDCLIB_ULONG_MAX: u32 = 4294967295;
pub const _PDCLIB_ULONG_MIN: u32 = 0;
pub const _PDCLIB_LLONG_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_LLONG_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_ULLONG_MAX: i32 = -1;
pub const _PDCLIB_ULLONG_MIN: u32 = 0;
pub const _PDCLIB_INT8_MAX: u32 = 127;
pub const _PDCLIB_INT8_MIN: i32 = -128;
pub const _PDCLIB_UINT8_MAX: u32 = 255;
pub const _PDCLIB_INT16_MAX: u32 = 32767;
pub const _PDCLIB_INT16_MIN: i32 = -32768;
pub const _PDCLIB_UINT16_MAX: u32 = 65535;
pub const _PDCLIB_INT32_MAX: u32 = 2147483647;
pub const _PDCLIB_INT32_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT32_MAX: u32 = 4294967295;
pub const _PDCLIB_INT64_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_INT64_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_UINT64_MAX: i32 = -1;
pub const _PDCLIB_FREAD: u32 = 8;
pub const _PDCLIB_FWRITE: u32 = 16;
pub const _PDCLIB_FAPPEND: u32 = 32;
pub const _PDCLIB_FRW: u32 = 64;
pub const _PDCLIB_FBIN: u32 = 128;
pub const _PDCLIB_FREEBUFFER: u32 = 256;
pub const _PDCLIB_ERRORFLAG: u32 = 512;
pub const _PDCLIB_EOFFLAG: u32 = 1024;
pub const _PDCLIB_WIDESTREAM: u32 = 2048;
pub const _PDCLIB_BYTESTREAM: u32 = 4096;
pub const _PDCLIB_DELONCLOSE: u32 = 8192;
pub const _PDCLIB_STATIC: u32 = 16384;
pub const _PDCLIB_FREENAME: u32 = 32768;
pub const _PDCLIB_LC_ALL: u32 = 0;
pub const _PDCLIB_LC_COLLATE: u32 = 1;
pub const _PDCLIB_LC_CTYPE: u32 = 2;
pub const _PDCLIB_LC_MONETARY: u32 = 3;
pub const _PDCLIB_LC_NUMERIC: u32 = 4;
pub const _PDCLIB_LC_TIME: u32 = 5;
pub const _PDCLIB_LC_MESSAGES: u32 = 6;
pub const _PDCLIB_LC_COUNT: u32 = 7;
pub const _PDCLIB_CTYPE_ALPHA: u32 = 1;
pub const _PDCLIB_CTYPE_BLANK: u32 = 2;
pub const _PDCLIB_CTYPE_CNTRL: u32 = 4;
pub const _PDCLIB_CTYPE_GRAPH: u32 = 8;
pub const _PDCLIB_CTYPE_PUNCT: u32 = 16;
pub const _PDCLIB_CTYPE_SPACE: u32 = 32;
pub const _PDCLIB_CTYPE_LOWER: u32 = 64;
pub const _PDCLIB_CTYPE_UPPER: u32 = 128;
pub const _PDCLIB_CHARSET_SIZE: u32 = 256;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const VIDEO_BASE: u32 = 4244635648;
pub const PCIO_CRTC_STATUS: u32 = 6296538;
pub const PCRTC_START: u32 = 6293504;
pub const PCRTC_INTR: u32 = 6291712;
pub const PCRTC_INTR_VBLANK_RESET: u32 = 1;
pub const PCRTC_INTR_EN: u32 = 6291776;
pub const PCRTC_INTR_EN_VBLANK_DISABLED: u32 = 0;
pub const PCRTC_INTR_EN_VBLANK_ENABLED: u32 = 1;
pub const NV_PMC_INTR_EN_0: u32 = 320;
pub const NV_PMC_INTR_EN_0_INTA_DISABLED: u32 = 0;
pub const NV_PMC_INTR_EN_0_INTA_HARDWARE: u32 = 1;
pub const NV_PMC_INTR_EN_0_INTA_SOFTWARE: u32 = 2;
pub const NV_PBUS_ROM_VERSION: u32 = 4632;
pub const NV_PBUS_ROM_VERSION_MASK: u32 = 256;
pub const NV_PFB_WC_CACHE: u32 = 1049616;
pub const NV_PFB_WC_CACHE_FLUSH_TRIGGER: u32 = 65536;
pub const NV_PFB_WC_CACHE_FLUSH_IN_PROGRESS: u32 = 65536;
pub const NV_PGRAPH_UNKNOWN_400098: u32 = 4194456;
pub const NV_PGRAPH_UNKNOWN_40009C: u32 = 4194460;
pub const NV_PGRAPH_CHANNEL_CTX_POINTER: u32 = 4196228;
pub const NV_PGRAPH_CHANNEL_CTX_POINTER_INST: u32 = 65535;
pub const NV_PGRAPH_CHANNEL_CTX_STATUS: u32 = 4196232;
pub const NV_PGRAPH_CHANNEL_CTX_STATUS_LOADED: u32 = 1;
pub const NV_PGRAPH_CHANNEL_CTX_STATUS_UNLOADED: u32 = 2;
pub const NV_PGRAPH_DEBUG_7: u32 = 4196480;
pub const NV_PGRAPH_DEBUG_7_UNKNOWN_OPTIONS: u32 = 577535;
pub const NV_PGRAPH_TILE_XBOX: u32 = 4196608;
pub const NV_PGRAPH_TLIMIT_XBOX: u32 = 4196612;
pub const NV_PGRAPH_TSIZE_XBOX: u32 = 4196616;
pub const NV_PGRAPH_ZCOMP_XBOX: u32 = 4196736;
pub const NV_PGRAPH_ZCOMP_OFFSET_XBOX: u32 = 4196768;
pub const NV_PGRAPH_CFG0_XBOX: u32 = 4196772;
pub const NV_PGRAPH_CFG1_XBOX: u32 = 4196776;
pub const NV_PGRAPH_UNKNOWN_400B80: u32 = 4197248;
pub const NV_PGRAPH_UNKNOWN_400B84: u32 = 4197252;
pub const NV_PGRAPH_UNKNOWN_400B88: u32 = 4197256;
pub const NV_PGRAPH_PARAMETER_A: u32 = 4201096;
pub const NV_PGRAPH_PARAMETER_B: u32 = 4200556;
pub const NV_PMC_INTR_0: u32 = 256;
pub const NV_PMC_INTR_0_NOT_PENDING: u32 = 0;
pub const NV_PMC_INTR_0_MD_PENDING: u32 = 1;
pub const NV_PMC_INTR_0_PMEDIA_PENDING: u32 = 16;
pub const NV_PMC_INTR_0_PFIFO_PENDING: u32 = 256;
pub const NV_PMC_INTR_0_PGRAPH_PENDING: u32 = 4096;
pub const NV_PMC_INTR_0_PVIDEO_PENDING: u32 = 65536;
pub const NV_PMC_INTR_0_PTIMER_PENDING: u32 = 1048576;
pub const NV_PMC_INTR_0_PCRTC_PENDING: u32 = 16777216;
pub const NV_PMC_ENABLE: u32 = 512;
pub const NV_PMC_ENABLE_ALL_ENABLE: u32 = 4294967295;
pub const NV_PMC_ENABLE_ALL_DISABLE: u32 = 0;
pub const NV_PMC_ENABLE_PGRAPH_DISABLED: u32 = 4294963199;
pub const NV_PMC_ENABLE_PGRAPH_ENABLED: u32 = 4096;
pub const NV_PBUS_PCI_NV_0: u32 = 6144;
pub const NV_CONFIG_PCI_NV_0_DEVICE_ID: u32 = 4294705152;
pub const NV_PBUS_PCI_NV_1: u32 = 6148;
pub const NV_PBUS_PCI_NV_1_BUS_MASTER_ENABLED: u32 = 4;
pub const NV_PBUS_PCI_NV_2: u32 = 6152;
pub const NV_PBUS_PCI_NV_2_REVISION_ID: u32 = 255;
pub const NV_PBUS_PCI_NV_3: u32 = 6156;
pub const NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS: u32 = 63488;
pub const NV_PBUS_PCI_NV_12: u32 = 6192;
pub const NV_PBUS_PCI_NV_12_ROM_DECODE_DISABLED: u32 = 0;
pub const NV_PBUS_PCI_NV_19: u32 = 6220;
pub const NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_OFF: u32 = 4294966783;
pub const NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF: u32 = 4294967039;
pub const NV_PFIFO_DELAY_0: u32 = 8256;
pub const NV_PFIFO_DELAY_0_WAIT_RETRY: u32 = 1023;
pub const NV_PFIFO_DMA_TIMESLICE: u32 = 8260;
pub const NV_PFIFO_DMA_TIMESLICE_SELECT_128K: u32 = 131071;
pub const NV_PFIFO_DMA_TIMESLICE_TIMEOUT_ENABLED: u32 = 16777216;
pub const NV_PFIFO_DMA_TIMESLICE_ALL_DISABLE: u32 = 0;
pub const NV_PFIFO_TIMESLICE: u32 = 8268;
pub const NV_PFIFO_TIMESLICE_TIMER_EXPIRED: u32 = 2097151;
pub const NV_PFIFO_DEBUG_0: u32 = 8320;
pub const NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING: u32 = 1;
pub const NV_PFIFO_INTR_0: u32 = 8448;
pub const NV_PFIFO_INTR_0_NOT_PENDING: u32 = 0;
pub const NV_PFIFO_INTR_0_CACHE_ERROR_PENDING: u32 = 1;
pub const NV_PFIFO_INTR_0_CACHE_ERROR_RESET: u32 = 1;
pub const NV_PFIFO_INTR_0_RUNOUT_PENDING: u32 = 16;
pub const NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING: u32 = 256;
pub const NV_PFIFO_INTR_0_DMA_PUSHER_PENDING: u32 = 4096;
pub const NV_PFIFO_INTR_0_DMA_PUSHER_RESET: u32 = 4096;
pub const NV_PFIFO_INTR_0_DMA_PT_PENDING: u32 = 65536;
pub const NV_PFIFO_INTR_0_DMA_PT_RESET: u32 = 65536;
pub const NV_PFIFO_INTR_0_SEMAPHORE_PENDING: u32 = 1048576;
pub const NV_PFIFO_INTR_0_SEMAPHORE_RESET: u32 = 1048576;
pub const NV_PFIFO_INTR_0_ACQUIRE_TIMEOUT_PENDING: u32 = 16777216;
pub const NV_PFIFO_INTR_0_ACQUIRE_TIMEOUT_RESET: u32 = 16777216;
pub const NV_PFIFO_INTR_0_ALL_RESET: u32 = 4294967295;
pub const NV_PFIFO_INTR_EN_0: u32 = 8512;
pub const NV_PFIFO_INTR_EN_0_ALL_DISABLE: u32 = 0;
pub const NV_PFIFO_INTR_EN_0_ALL_ENABLE: u32 = 17895697;
pub const NV_PFIFO_RAMHT: u32 = 8720;
pub const NV_PFIFO_RAMHT_BASE_ADDRESS: u32 = 496;
pub const NV_PFIFO_RAMHT_BASE_ADDRESS_10000: u32 = 256;
pub const NV_PFIFO_RAMHT_SEARCH_128: u32 = 50331648;
pub const NV_PFIFO_RAMFC: u32 = 8724;
pub const NV_PFIFO_RAMFC_BASE_ADDRESS: u32 = 508;
pub const NV_PFIFO_RAMFC_BASE_ADDRESS_11000: u32 = 272;
pub const NV_PFIFO_RUNOUT_STATUS: u32 = 9216;
pub const NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY: u32 = 16;
pub const NV_PFIFO_RUNOUT_PUT: u32 = 9232;
pub const NV_PFIFO_RUNOUT_PUT_ADDRESS: u32 = 8184;
pub const NV_PFIFO_RUNOUT_GET: u32 = 9248;
pub const NV_PFIFO_RUNOUT_GET_ADDRESS: u32 = 16376;
pub const NV_PFIFO_CACHES: u32 = 9472;
pub const NV_PFIFO_CACHES_ALL_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHES_REASSIGN_ENABLED: u32 = 1;
pub const NV_PFIFO_CACHES_DMA_SUSPEND_BUSY: u32 = 16;
pub const NV_PFIFO_MODE: u32 = 9476;
pub const NV_PFIFO_MODE_ALL_PIO: u32 = 0;
pub const NV_PFIFO_DMA: u32 = 9480;
pub const NV_PFIFO_DMA_NOT_PENDING: u32 = 0;
pub const NV_PFIFO_SIZE: u32 = 9484;
pub const NV_PFIFO_CACHE0_PUSH0: u32 = 12288;
pub const NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE0_PULL0: u32 = 12368;
pub const NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE0_HASH: u32 = 12376;
pub const NV_PFIFO_CACHE0_HASH_INSTANCE: u32 = 65535;
pub const NV_PFIFO_CACHE0_HASH_VALID: u32 = 65536;
pub const NV_PFIFO_CACHE1_PUSH0: u32 = 12800;
pub const NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLE: u32 = 1;
pub const NV_PFIFO_CACHE1_PUSH1: u32 = 12804;
pub const NV_PFIFO_CACHE1_PUSH1_CHID: u32 = 31;
pub const NV_PFIFO_CACHE1_PUSH1_MODE_DMA: u32 = 256;
pub const NV_PFIFO_CACHE1_PUT: u32 = 12816;
pub const NV_PFIFO_CACHE1_PUT_ADDRESS: u32 = 1020;
pub const NV_PFIFO_CACHE1_STATUS: u32 = 12820;
pub const NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY: u32 = 16;
pub const NV_PFIFO_CACHE1_DMA_PUSH: u32 = 12832;
pub const NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_ENABLE: u32 = 1;
pub const NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY: u32 = 16;
pub const NV_PFIFO_CACHE1_DMA_PUSH_STATUS_RUNNING: u32 = 4294963199;
pub const NV_PFIFO_CACHE1_DMA_FETCH: u32 = 12836;
pub const NV_PFIFO_CACHE1_DMA_FETCH_TRIG: u32 = 248;
pub const NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES: u32 = 120;
pub const NV_PFIFO_CACHE1_DMA_FETCH_SIZE: u32 = 57344;
pub const NV_PFIFO_CACHE1_DMA_FETCH_SIZE_32_BYTES: u32 = 0;
pub const NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS: u32 = 2031616;
pub const NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_15: u32 = 983040;
pub const NV_PFIFO_CACHE1_DMA_STATE: u32 = 12840;
pub const NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT_0: u32 = 0;
pub const NV_PFIFO_CACHE1_DMA_INSTANCE: u32 = 12844;
pub const NV_PFIFO_CACHE1_DMA_INSTANCE_ADDRESS: u32 = 65535;
pub const NV_PFIFO_CACHE1_DMA_CTL: u32 = 12848;
pub const NV_PFIFO_CACHE1_DMA_CTL_ALL_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE1_DMA_PUT: u32 = 12864;
pub const NV_PFIFO_CACHE1_DMA_PUT_OFFSET: u32 = 536870908;
pub const NV_PFIFO_CACHE1_DMA_GET: u32 = 12868;
pub const NV_PFIFO_CACHE1_DMA_GET_OFFSET: u32 = 536870908;
pub const NV_PFIFO_CACHE1_REF: u32 = 12872;
pub const NV_PFIFO_CACHE1_REF_CNT: u32 = 4294967295;
pub const NV_PFIFO_CACHE1_DMA_SUBROUTINE: u32 = 12876;
pub const NV_PFIFO_CACHE1_DMA_SUBROUTINE_STATE_ACTIVE: u32 = 1;
pub const NV_PFIFO_CACHE1_DMA_SUBROUTINE_RETURN_OFFSET: u32 = 268435452;
pub const NV_PFIFO_CACHE1_PULL0: u32 = 12880;
pub const NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLE: u32 = 0;
pub const NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLE: u32 = 1;
pub const NV_PFIFO_CACHE1_PULL0_HASH_FAILED: u32 = 16;
pub const NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE: u32 = 256;
pub const NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY: u32 = 4096;
pub const NV_PFIFO_CACHE1_PULL1: u32 = 12884;
pub const NV_PFIFO_CACHE1_HASH: u32 = 12888;
pub const NV_PFIFO_CACHE1_HASH_INSTANCE: u32 = 65535;
pub const NV_PFIFO_CACHE1_HASH_VALID: u32 = 65536;
pub const NV_PFIFO_CACHE1_ACQUIRE_0: u32 = 12896;
pub const NV_PFIFO_CACHE1_ACQUIRE_0_TIMEOUT: u32 = 4294967295;
pub const NV_PFIFO_CACHE1_ACQUIRE_1: u32 = 12900;
pub const NV_PFIFO_CACHE1_ACQUIRE_1_TIMESTAMP: u32 = 4294967295;
pub const NV_PFIFO_CACHE1_ACQUIRE_2: u32 = 12904;
pub const NV_PFIFO_CACHE1_ACQUIRE_2_VALUE: u32 = 2147483647;
pub const NV_PFIFO_CACHE1_SEMAPHORE: u32 = 12908;
pub const NV_PFIFO_CACHE1_SEMAPHORE_CTXDMA_VALID: u32 = 1;
pub const NV_PFIFO_CACHE1_SEMAPHORE_OFFSET: u32 = 4092;
pub const NV_PFIFO_CACHE1_SEMAPHORE_PAGE_ADDRESS: u32 = 4294963200;
pub const NV_PFIFO_CACHE1_GET: u32 = 12912;
pub const NV_PFIFO_CACHE1_GET_ADDRESS: u32 = 1020;
pub const NV_PFIFO_CACHE1_ENGINE: u32 = 12928;
pub const NV_PFIFO_CACHE1_ENGINE_ALL_SW: u32 = 0;
pub const NV_PVIDEO_DEBUG_2: u32 = 32904;
pub const NV_PVIDEO_DEBUG_2_BURST1_CLEAR: u32 = 4294964287;
pub const NV_PVIDEO_DEBUG_2_BURST1_INIT: u32 = 1024;
pub const NV_PVIDEO_DEBUG_2_BURST2_CLEAR: u32 = 4097835007;
pub const NV_PVIDEO_DEBUG_2_BURST2_INIT: u32 = 67108864;
pub const NV_PVIDEO_DEBUG_3: u32 = 32908;
pub const NV_PVIDEO_DEBUG_3_WATER_MARK1_CLEAR: u32 = 4294964239;
pub const NV_PVIDEO_DEBUG_3_WATER_MARK1_INIT: u32 = 1024;
pub const NV_PVIDEO_DEBUG_3_WATER_MARK2_CLEAR: u32 = 4094689279;
pub const NV_PVIDEO_DEBUG_3_WATER_MARK2_INIT: u32 = 67108864;
pub const NV_PVIDEO_INTR: u32 = 33024;
pub const NV_PVIDEO_INTR_BUFFER_0_PENDING: u32 = 1;
pub const NV_PVIDEO_INTR_BUFFER_0_RESET: u32 = 1;
pub const NV_PVIDEO_LUMINANCE_0: u32 = 35088;
pub const NV_PVIDEO_LUMINANCE_1: u32 = 35092;
pub const NV_PVIDEO_LUMINANCE_CONTRAST_UNITY: u32 = 4096;
pub const NV_PVIDEO_LUMINANCE_BRIGHTNESS_UNITY: u32 = 0;
pub const NV_PVIDEO_CHROMINANCE_0: u32 = 35096;
pub const NV_PVIDEO_CHROMINANCE_1: u32 = 35100;
pub const NV_PVIDEO_CHROMINANCE_SAT_COS_UNITY: u32 = 4096;
pub const NV_PVIDEO_CHROMINANCE_SAT_SIN_UNITY: u32 = 0;
pub const NV_PVIDEO_OFFSET_0: u32 = 35104;
pub const NV_PVIDEO_OFFSET_1: u32 = 35108;
pub const NV_PVIDEO_OFFSET_VALUE_ZERO: u32 = 0;
pub const NV_PVIDEO_SIZE_IN_0: u32 = 35112;
pub const NV_PVIDEO_SIZE_IN_1: u32 = 35116;
pub const NV_PVIDEO_SIZE_IN_UNKNOWN_WIDTH: u32 = 65535;
pub const NV_PVIDEO_SIZE_IN_UNKNOWN_HEIGHT: u32 = 4294901760;
pub const NV_PVIDEO_POINT_IN_0: u32 = 35120;
pub const NV_PVIDEO_POINT_IN_1: u32 = 35124;
pub const NV_PVIDEO_POINT_IN_S_ORIGIN: u32 = 0;
pub const NV_PVIDEO_POINT_IN_T_ORIGIN: u32 = 0;
pub const NV_PVIDEO_DS_DX_0: u32 = 35128;
pub const NV_PVIDEO_DS_DX_1: u32 = 35132;
pub const NV_PVIDEO_DS_DX_RATIO_UNITY: u32 = 1048576;
pub const NV_PVIDEO_DT_DY_0: u32 = 35136;
pub const NV_PVIDEO_DT_DY_1: u32 = 35140;
pub const NV_PVIDEO_DT_DY_RATIO_UNITY: u32 = 1048576;
pub const NV_PTIMER_INTR_0: u32 = 37120;
pub const NV_PTIMER_INTR_0_ALARM_NOT_PENDING: u32 = 0;
pub const NV_PTIMER_INTR_0_ALARM_RESET: u32 = 1;
pub const NV_PTIMER_INTR_EN_0: u32 = 37184;
pub const NV_PTIMER_INTR_EN_0_ALARM_DISABLED: u32 = 0;
pub const NV_PTIMER_NUMERATOR: u32 = 37376;
pub const NV_PTIMER_DENOMINATOR: u32 = 37392;
pub const NV_PTIMER_TIME_0: u32 = 37888;
pub const NV_PTIMER_TIME_1: u32 = 37904;
pub const NV_PTIMER_ALARM_0: u32 = 37920;
pub const NV_PFB_CFG0: u32 = 1049088;
pub const NV_PFB_CFG0_PART_3: u32 = 3;
pub const NV_PFB_CFG1: u32 = 1049092;
pub const NV_PFB_FIFO_DATA: u32 = 1049100;
pub const NV_PFB_NVM: u32 = 1049108;
pub const NV_PFB_NVM_MODE_DISABLE: u32 = 4294967294;
pub const NV_PFB_NVM_MODE_ENABLE: u32 = 1;
pub const NV_PFB_TILE: u32 = 1049152;
pub const NV_PFB_TLIMIT: u32 = 1049156;
pub const NV_PFB_TSIZE: u32 = 1049160;
pub const NV_PFB_ZCOMP: u32 = 1049344;
pub const NV_PFB_ZCOMP_OFFSET: u32 = 1049380;
pub const NV_PGRAPH_DEBUG_0: u32 = 4194432;
pub const NV_PGRAPH_DEBUG_0_NO_RESET: u32 = 0;
pub const NV_PGRAPH_DEBUG_0_IDX_STATE_RESET: u32 = 65536;
pub const NV_PGRAPH_DEBUG_0_VTX_STATE_RESET: u32 = 131072;
pub const NV_PGRAPH_DEBUG_0_CAS_STATE_RESET: u32 = 262144;
pub const NV_PGRAPH_DEBUG_1: u32 = 4194436;
pub const NV_PGRAPH_DEBUG_1_VTX_PTE_ENABLED: u32 = 256;
pub const NV_PGRAPH_DEBUG_1_VTX_CACHE_ENABLED: u32 = 512;
pub const NV_PGRAPH_DEBUG_1_VTX_FILE_ENABLED: u32 = 1024;
pub const NV_PGRAPH_DEBUG_1_DRAWDIR_Y_INCR: u32 = 32768;
pub const NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED: u32 = 65536;
pub const NV_PGRAPH_DEBUG_1_CTX_ENABLED: u32 = 1048576;
pub const NV_PGRAPH_DEBUG_1_CACHE_INVALIDATE: u32 = 16777216;
pub const NV_PGRAPH_DEBUG_3: u32 = 4194444;
pub const NV_PGRAPH_DEBUG_3_FLUSHING_ENABLED: u32 = 1;
pub const NV_PGRAPH_DEBUG_3_SYNC_TO_CRTC_ENABLED: u32 = 8;
pub const NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED: u32 = 16;
pub const NV_PGRAPH_DEBUG_3_FAST_3D_SHADOW_DATA_ENABLED: u32 = 32;
pub const NV_PGRAPH_DEBUG_3_FAST_DMA_READ_ENABLED: u32 = 64;
pub const NV_PGRAPH_DEBUG_3_IDLE_FILTER_ENABLED: u32 = 1024;
pub const NV_PGRAPH_DEBUG_3_SINGLE_CYCLE_LOAD_ENABLED: u32 = 131072;
pub const NV_PGRAPH_DEBUG_3_BILINEAR_3D_ENABLED: u32 = 262144;
pub const NV_PGRAPH_DEBUG_3_VOLATILE_RESET_ENABLED: u32 = 524288;
pub const NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED: u32 = 1048576;
pub const NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED: u32 = 4194304;
pub const NV_PGRAPH_DEBUG_3_DMA_CHECK_ENABLED: u32 = 8388608;
pub const NV_PGRAPH_DEBUG_3_STATE_CHECK_ENABLED: u32 = 16777216;
pub const NV_PGRAPH_DEBUG_3_IMAGE_64BIT_ENABLED: u32 = 33554432;
pub const NV_PGRAPH_DEBUG_3_XFMODE_COALESCE_ENABLED: u32 = 268435456;
pub const NV_PGRAPH_DEBUG_3_CTX_METHODS_ENABLED: u32 = 536870912;
pub const NV_PGRAPH_DEBUG_3_OP_METHODS_ENABLED: u32 = 1073741824;
pub const NV_PGRAPH_DEBUG_3_IGNORE_PATCHVALID_ENABLED: u32 = 2147483648;
pub const NV_PGRAPH_DEBUG_4: u32 = 4194448;
pub const NV_PGRAPH_DEBUG_4_ALL_DISABLE: u32 = 0;
pub const NV_PGRAPH_DEBUG_5: u32 = 4194452;
pub const NV_PGRAPH_DEBUG_5_ZCULL_SPARE2_ENABLED: u32 = 4;
pub const NV_PGRAPH_INTR: u32 = 4194560;
pub const NV_PGRAPH_INTR_NOT_PENDING: u32 = 0;
pub const NV_PGRAPH_INTR_NOTIFY_PENDING: u32 = 1;
pub const NV_PGRAPH_INTR_NOTIFY_RESET: u32 = 1;
pub const NV_PGRAPH_INTR_MISSING_HW_PENDING: u32 = 16;
pub const NV_PGRAPH_INTR_MISSING_HW_RESET: u32 = 16;
pub const NV_PGRAPH_INTR_TLB_PRESENT_A_PENDING: u32 = 256;
pub const NV_PGRAPH_INTR_TLB_PRESENT_B_PENDING: u32 = 512;
pub const NV_PGRAPH_INTR_CONTEXT_SWITCH_PENDING: u32 = 4096;
pub const NV_PGRAPH_INTR_CONTEXT_SWITCH_RESET: u32 = 4096;
pub const NV_PGRAPH_INTR_BUFFER_NOTIFY_PENDING: u32 = 65536;
pub const NV_PGRAPH_INTR_ERROR_PENDING: u32 = 1048576;
pub const NV_PGRAPH_INTR_ERROR_RESET: u32 = 1048576;
pub const NV_PGRAPH_INTR_SINGLE_STEP_PENDING: u32 = 16777216;
pub const NV_PGRAPH_INTR_SINGLE_STEP_RESET: u32 = 16777216;
pub const NV_PGRAPH_INTR_MORE_RESET: u32 = 4293918720;
pub const NV_PGRAPH_INTR_ALL_ENABLE: u32 = 4294967295;
pub const NV_PGRAPH_NSOURCE: u32 = 4194568;
pub const NV_PGRAPH_NSOURCE_DATA_ERROR_PENDING: u32 = 2;
pub const NV_PGRAPH_NSOURCE_PROTECTION_ERROR_PENDING: u32 = 4;
pub const NV_PGRAPH_NSOURCE_RANGE_EXCEPTION_PENDING: u32 = 8;
pub const NV_PGRAPH_NSOURCE_LIMIT_COLOR_PENDING: u32 = 16;
pub const NV_PGRAPH_NSOURCE_LIMIT_ZETA_PENDING: u32 = 32;
pub const NV_PGRAPH_NSOURCE_ILLEGAL_MTHD_PENDING: u32 = 64;
pub const NV_PGRAPH_NSOURCE_DMA_R_PROTECTION_PENDING: u32 = 128;
pub const NV_PGRAPH_NSOURCE_DMA_W_PROTECTION_PENDING: u32 = 256;
pub const NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION_PENDING: u32 = 512;
pub const NV_PGRAPH_NSOURCE_PATCH_EXCEPTION_PENDING: u32 = 1024;
pub const NV_PGRAPH_NSOURCE_STATE_INVALID_PENDING: u32 = 2048;
pub const NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY_PENDING: u32 = 4096;
pub const NV_PGRAPH_NSOURCE_NOTIFY_IN_USE_PENDING: u32 = 8192;
pub const NV_PGRAPH_NSOURCE_METHOD_CNT_PENDING: u32 = 16384;
pub const NV_PGRAPH_NSOURCE_BFR_NOTIFICATION_PENDING: u32 = 32768;
pub const NV_PGRAPH_NSOURCE_DMA_VTX_PROTECTION_PENDING: u32 = 65536;
pub const NV_PGRAPH_NSOURCE_IDX_INLINE_REUSE_PENDING: u32 = 131072;
pub const NV_PGRAPH_NSOURCE_INVALID_OPERATION_PENDING: u32 = 262144;
pub const NV_PGRAPH_NSOURCE_FD_INVALID_OPERATION_PENDING: u32 = 524288;
pub const NV_PGRAPH_NSOURCE_TEX_A_PROTECTION_PENDING: u32 = 4194304;
pub const NV_PGRAPH_NSOURCE_TEX_B_PROTECTION_PENDING: u32 = 8388608;
pub const NV_PGRAPH_INTR_EN: u32 = 4194624;
pub const NV_PGRAPH_INTR_EN_ALL_ENABLE: u32 = 4294967295;
pub const NV_PGRAPH_CTX_CONTROL: u32 = 4194628;
pub const NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED: u32 = 256;
pub const NV_PGRAPH_CTX_CONTROL_CHID_VALID: u32 = 65536;
pub const NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED: u32 = 268435456;
pub const NV_PGRAPH_CTX_USER: u32 = 4194632;
pub const NV_PGRAPH_CTX_USER_CHID: u32 = 520093696;
pub const NV_PGRAPH_CTX_SWITCH1: u32 = 4194636;
pub const NV_PGRAPH_CTX_SWITCH1_ALL_DISABLE: u32 = 0;
pub const NV_PGRAPH_CTX_SWITCH1_GRCLASS: u32 = 255;
pub const NV_PGRAPH_CTX_SWITCH2: u32 = 4194640;
pub const NV_PGRAPH_CTX_SWITCH2_ALL_DISABLE: u32 = 0;
pub const NV_PGRAPH_CTX_SWITCH3: u32 = 4194644;
pub const NV_PGRAPH_CTX_SWITCH3_ALL_DISABLE: u32 = 0;
pub const NV_PGRAPH_CTX_SWITCH4: u32 = 4194648;
pub const NV_PGRAPH_CTX_SWITCH4_ALL_DISABLE: u32 = 0;
pub const NV_PGRAPH_STATUS: u32 = 4196096;
pub const NV_PGRAPH_STATUS_NOT_BUSY: u32 = 0;
pub const NV_PGRAPH_TRAPPED_ADDR: u32 = 4196100;
pub const NV_PGRAPH_TRAPPED_ADDR_MTHD: u32 = 8188;
pub const NV_PGRAPH_TRAPPED_ADDR_CHID: u32 = 32505856;
pub const NV_PGRAPH_TRAPPED_DATA_LOW: u32 = 4196104;
pub const NV_PGRAPH_TRAPPED_DATA_LOW_VALUE: u32 = 4294967295;
pub const NV_PGRAPH_TRAPPED_DATA_HIGH: u32 = 4196108;
pub const NV_PGRAPH_TRAPPED_DATA_HIGH_VALUE: u32 = 4294967295;
pub const NV_PGRAPH_INCREMENT: u32 = 4196124;
pub const NV_PGRAPH_INCREMENT_READ_3D_TRIGGER: u32 = 2;
pub const NV_PGRAPH_FIFO: u32 = 4196128;
pub const NV_PGRAPH_FIFO_ACCESS_DISABLE: u32 = 0;
pub const NV_PGRAPH_FIFO_ACCESS_ENABLE: u32 = 1;
pub const NV_PGRAPH_RDI_INDEX: u32 = 4196176;
pub const NV_PGRAPH_RDI_INDEX_ADDRESS: u32 = 8188;
pub const NV_PGRAPH_RDI_INDEX_SELECT: u32 = 33488896;
pub const NV_PGRAPH_RDI_DATA: u32 = 4196180;
pub const NV_PGRAPH_FFINTFC_ST2: u32 = 4196196;
pub const NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_VALID: u32 = 134217728;
pub const NV_PGRAPH_FFINTFC_ST2_CHSWITCH_CLEAR: u32 = 4026531839;
pub const NV_PGRAPH_FFINTFC_ST2_FIFOHOLD_CLEAR: u32 = 3758096383;
pub const NV_PGRAPH_CHANNEL_CTX_TABLE: u32 = 4196224;
pub const NV_PGRAPH_CHANNEL_CTX_TABLE_INST: u32 = 65535;
pub const NV_PCRTC_CONFIG: u32 = 6293508;
pub const NV_PCRTC_CONFIG_START_ADDRESS: u32 = 7;
pub const NV_PCRTC_CONFIG_START_ADDRESS_VGA: u32 = 0;
pub const NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA: u32 = 1;
pub const NV_PCRTC_CONFIG_START_ADDRESS_HSYNC: u32 = 2;
pub const NV_PRMCIO_CRX__COLOR: u32 = 6296532;
pub const NV_PRMCIO_CR__COLOR: u32 = 6296533;
pub const NV_PRAMDAC_NVPLL_COEFF: u32 = 6817024;
pub const NV_PRAMDAC_NVPLL_COEFF_MDIV: u32 = 255;
pub const NV_PRAMDAC_NVPLL_COEFF_NDIV: u32 = 65280;
pub const NV_PRAMDAC_NVPLL_COEFF_PDIV: u32 = 458752;
pub const NV_PRAMDAC_MPLL_COEFF: u32 = 6817028;
pub const NV_PRAMDAC_MPLL_COEFF_MDIV: u32 = 255;
pub const NV_PRAMDAC_MPLL_COEFF_NDIV: u32 = 65280;
pub const NV_PRAMDAC_MPLL_COEFF_PDIV: u32 = 458752;
pub const NV_PRAMDAC_VPLL_COEFF: u32 = 6817032;
pub const NV_PRAMDAC_VPLL_COEFF_MDIV: u32 = 255;
pub const NV_PRAMDAC_VPLL_COEFF_NDIV: u32 = 65280;
pub const NV_PRAMDAC_VPLL_COEFF_PDIV: u32 = 458752;
pub const NV_USER_DAC_WRITE_MODE_ADDRESS: u32 = 6820808;
pub const NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE: u32 = 255;
pub const NV_USER_DAC_PALETTE_DATA: u32 = 6820809;
pub const NV_USER_DAC_PALETTE_DATA_VALUE: u32 = 255;
pub const NV_PRAMIN: u32 = 7340032;
pub const NV_USER: u32 = 8388608;
pub const STOP: u32 = 0;
pub const POINTS: u32 = 1;
pub const LINES: u32 = 2;
pub const LINE_LOOP: u32 = 3;
pub const LINE_STRIP: u32 = 4;
pub const TRIANGLES: u32 = 5;
pub const TRIANGLE_STRIP: u32 = 6;
pub const TRIANGLE_FAN: u32 = 7;
pub const QUADS: u32 = 8;
pub const QUAD_STRIP: u32 = 9;
pub const POLYGON: u32 = 10;
pub const NV_MEMORY_TO_MEMORY_FORMAT: u32 = 57;
pub const NV_MEMORY_TO_MEMORY_FORMAT_NOP: u32 = 256;
pub const NV_MEMORY_TO_MEMORY_FORMAT_NOTIFY: u32 = 260;
pub const NV_MEMORY_TO_MEMORY_FORMAT_DMA_NOTIFY: u32 = 384;
pub const NV_MEMORY_TO_MEMORY_FORMAT_OBJECT_IN: u32 = 388;
pub const NV_MEMORY_TO_MEMORY_FORMAT_OBJECT_OUT: u32 = 392;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK0: u32 = 512;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK1: u32 = 540;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK2: u32 = 544;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK3: u32 = 548;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK4: u32 = 552;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK5: u32 = 556;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK6: u32 = 560;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK7: u32 = 564;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK8: u32 = 568;
pub const NV_MEMORY_TO_MEMORY_FORMAT_UNK9: u32 = 572;
pub const NV_MEMORY_TO_MEMORY_FORMAT_OFFSET_IN: u32 = 780;
pub const NV_MEMORY_TO_MEMORY_FORMAT_OFFSET_OUT: u32 = 784;
pub const NV_MEMORY_TO_MEMORY_FORMAT_PITCH_IN: u32 = 788;
pub const NV_MEMORY_TO_MEMORY_FORMAT_PITCH_OUT: u32 = 792;
pub const NV_MEMORY_TO_MEMORY_FORMAT_LINE_LENGTH_IN: u32 = 796;
pub const NV_MEMORY_TO_MEMORY_FORMAT_LINE_COUNT: u32 = 800;
pub const NV_MEMORY_TO_MEMORY_FORMAT_FORMAT: u32 = 804;
pub const NV_MEMORY_TO_MEMORY_FORMAT_BUF_NOTIFY: u32 = 808;
pub const NV04_GDI_RECTANGLE_TEXT: u32 = 74;
pub const NV04_GDI_RECTANGLE_TEXT_SET_DMA_NOTIFY: u32 = 384;
pub const NV04_GDI_RECTANGLE_TEXT_PATTERN: u32 = 392;
pub const NV04_GDI_RECTANGLE_TEXT_ROP5: u32 = 396;
pub const NV04_GDI_RECTANGLE_TEXT_SURFACE: u32 = 408;
pub const NV04_GDI_RECTANGLE_TEXT_OPERATION: u32 = 764;
pub const NV04_GDI_RECTANGLE_TEXT_FORMAT: u32 = 768;
pub const NV04_GDI_RECTANGLE_TEXT_SOLID_COLOR: u32 = 1020;
pub const NV04_GDI_RECTANGLE_TEXT_SOLID_RECTS__SIZE: u32 = 32;
pub const NV04_GDI_RECTANGLE_TEXT_BLOCK_LEVEL1_TL: u32 = 1524;
pub const NV04_GDI_RECTANGLE_TEXT_BLOCK_LEVEL1_BR: u32 = 1528;
pub const NV04_GDI_RECTANGLE_TEXT_FILL_VALUE: u32 = 1532;
pub const NV04_GDI_RECTANGLE_TEXT_BLOCK_LEVEL2_TL: u32 = 1536;
pub const NV04_GDI_RECTANGLE_TEXT_BLOCK_LEVEL2_BR: u32 = 1540;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_ONE_COLOR_CLIP: u32 = 2028;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_ONE_COLOR_COLOR: u32 = 2036;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_ONE_COLOR_SIZE: u32 = 2040;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_ONE_COLOR_POINT: u32 = 2044;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_ONE_COLOR_DATA__SIZE: u32 = 128;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_CLIP: u32 = 3044;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_COLOR_0: u32 = 3052;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_COLOR_1: u32 = 3068;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_SIZE_IN: u32 = 3060;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_SIZE_OUT: u32 = 3064;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_POINT: u32 = 3068;
pub const NV04_GDI_RECTANGLE_TEXT_EXPAND_TWO_COLOR_DATA__SIZE: u32 = 128;
pub const NV04_CONTEXT_SURFACES_3D: u32 = 83;
pub const NV04_CONTEXT_SURFACES_3D_DMA_NOTIFY: u32 = 384;
pub const NV04_CONTEXT_SURFACES_3D_DMA_COLOR: u32 = 388;
pub const NV04_CONTEXT_SURFACES_3D_DMA_ZETA: u32 = 392;
pub const NV04_CONTEXT_SURFACES_3D_CLIP_HORIZONTAL: u32 = 760;
pub const NV04_CONTEXT_SURFACES_3D_CLIP_VERTICAL: u32 = 764;
pub const NV04_CONTEXT_SURFACES_3D_FORMAT: u32 = 768;
pub const NV04_CONTEXT_SURFACES_3D_CLIP_SIZE: u32 = 772;
pub const NV04_CONTEXT_SURFACES_3D_PITCH: u32 = 776;
pub const NV04_CONTEXT_SURFACES_3D_OFFSET_COLOR: u32 = 780;
pub const NV04_CONTEXT_SURFACES_3D_OFFSET_ZETA: u32 = 784;
pub const NV04_DX5_TEXTURED_TRIANGLE: u32 = 84;
pub const NV04_DX5_TEXTURED_TRIANGLE_NOP: u32 = 256;
pub const NV04_DX5_TEXTURED_TRIANGLE_NOTIFY: u32 = 260;
pub const NV04_DX5_TEXTURED_TRIANGLE_DMA_NOTIFY: u32 = 384;
pub const NV04_DX5_TEXTURED_TRIANGLE_DMA_1: u32 = 388;
pub const NV04_DX5_TEXTURED_TRIANGLE_DMA_2: u32 = 392;
pub const NV04_DX5_TEXTURED_TRIANGLE_SURFACE: u32 = 396;
pub const NV04_DX5_TEXTURED_TRIANGLE_COLOR_KEY: u32 = 768;
pub const NV04_DX5_TEXTURED_TRIANGLE_TEXTURE_OFFSET: u32 = 772;
pub const NV04_DX5_TEXTURED_TRIANGLE_TEXTURE_FORMAT: u32 = 776;
pub const NV04_DX5_TEXTURED_TRIANGLE_TEXTURE_FILTER: u32 = 780;
pub const NV04_DX5_TEXTURED_TRIANGLE_BLEND: u32 = 784;
pub const NV04_DX5_TEXTURED_TRIANGLE_CONTROL: u32 = 788;
pub const NV04_DX5_TEXTURED_TRIANGLE_FOG_COLOR: u32 = 792;
pub const NV04_DX5_TEXTURED_TRIANGLE_TLVERTEX_SX__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_TLVERTEX_SY__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_TLVERTEX_SZ__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_INV_W__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_COLOR__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_SPECULAR__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_TEXTURE_S__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_TEXTURE_T__SIZE: u32 = 16;
pub const NV04_DX5_TEXTURED_TRIANGLE_DRAW: u32 = 1536;
pub const NV04_DX6_MULTITEX_TRIANGLE: u32 = 85;
pub const NV04_DX6_MULTITEX_TRIANGLE_NOP: u32 = 256;
pub const NV04_DX6_MULTITEX_TRIANGLE_NOTIFY: u32 = 260;
pub const NV04_DX6_MULTITEX_TRIANGLE_DMA_NOTIFY: u32 = 384;
pub const NV04_DX6_MULTITEX_TRIANGLE_DMA_1: u32 = 388;
pub const NV04_DX6_MULTITEX_TRIANGLE_DMA_2: u32 = 392;
pub const NV04_DX6_MULTITEX_TRIANGLE_SURFACE: u32 = 396;
pub const NV04_DX6_MULTITEX_TRIANGLE_OFFSET0: u32 = 776;
pub const NV04_DX6_MULTITEX_TRIANGLE_OFFSET1: u32 = 780;
pub const NV04_DX6_MULTITEX_TRIANGLE_FORMAT0: u32 = 784;
pub const NV04_DX6_MULTITEX_TRIANGLE_FORMAT1: u32 = 788;
pub const NV04_DX6_MULTITEX_TRIANGLE_FILTER0: u32 = 792;
pub const NV04_DX6_MULTITEX_TRIANGLE_FILTER1: u32 = 796;
pub const NV04_DX6_MULTITEX_TRIANGLE_COMBINE_0_ALPHA: u32 = 800;
pub const NV04_DX6_MULTITEX_TRIANGLE_COMBINE_0_COLOR: u32 = 804;
pub const NV04_DX6_MULTITEX_TRIANGLE_COMBINE_1_ALPHA: u32 = 812;
pub const NV04_DX6_MULTITEX_TRIANGLE_COMBINE_1_COLOR: u32 = 816;
pub const NV04_DX6_MULTITEX_TRIANGLE_COMBINE_FACTOR: u32 = 820;
pub const NV04_DX6_MULTITEX_TRIANGLE_BLEND: u32 = 824;
pub const NV04_DX6_MULTITEX_TRIANGLE_CONTROL0: u32 = 828;
pub const NV04_DX6_MULTITEX_TRIANGLE_CONTROL1: u32 = 832;
pub const NV04_DX6_MULTITEX_TRIANGLE_CONTROL2: u32 = 836;
pub const NV04_DX6_MULTITEX_TRIANGLE_FOG_COLOR: u32 = 840;
pub const NV04_DX6_MULTITEX_TRIANGLE_TLVERTEX_SX__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TLVERTEX_SY__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TLVERTEX_SZ__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_INV_W__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_COLOR__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_SPECULAR__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TEXTURE0_S__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TEXTURE0_T__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TEXTURE1_S__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_TEXTURE1_T__SIZE: u32 = 8;
pub const NV04_DX6_MULTITEX_TRIANGLE_DRAW: u32 = 1344;
pub const NV04_COLOR_KEY: u32 = 87;
pub const NV04_COLOR_KEY_SET_DMA_NOTIFY: u32 = 384;
pub const NV04_COLOR_KEY_FORMAT: u32 = 768;
pub const NV04_COLOR_KEY_VALUE: u32 = 772;
pub const NV04_SOLID_LINE: u32 = 92;
pub const NV04_SOLID_LINE_CLIP_RECTANGLE: u32 = 388;
pub const NV04_SOLID_LINE_PATTERN: u32 = 392;
pub const NV04_SOLID_LINE_ROP: u32 = 396;
pub const NV04_SOLID_LINE_SURFACE: u32 = 408;
pub const NV04_SOLID_LINE_OPERATION: u32 = 764;
pub const NV04_SOLID_LINE_COLOR_FORMAT: u32 = 768;
pub const NV04_SOLID_LINE_COLOR_VALUE: u32 = 772;
pub const NV04_SOLID_LINE_START: u32 = 1024;
pub const NV04_SOLID_LINE_END: u32 = 1028;
pub const NV04_UNK005E: u32 = 94;
pub const NV04_UNK005E_SET_SURFACE: u32 = 408;
pub const NV04_UNK005E_UNK02fc: u32 = 764;
pub const NV04_UNK005E_UNK0300: u32 = 768;
pub const NV04_UNK005E_COUNTER: u32 = 772;
pub const NV_IMAGE_FROM_CPU: u32 = 97;
pub const NV_IMAGE_FROM_CPU_DMA_NOTIFY: u32 = 384;
pub const NV_IMAGE_FROM_CPU_CLIP_RECTANGLE: u32 = 392;
pub const NV_IMAGE_FROM_CPU_PATTERN: u32 = 396;
pub const NV_IMAGE_FROM_CPU_ROP: u32 = 400;
pub const NV_IMAGE_FROM_CPU_SURFACE: u32 = 412;
pub const NV_IMAGE_FROM_CPU_OPERATION: u32 = 764;
pub const NV_IMAGE_FROM_CPU_FORMAT: u32 = 768;
pub const NV05_IMAGE_FROM_CPU: u32 = 101;
pub const NV05_IMAGE_FROM_CPU_DMA_NOTIFY: u32 = 384;
pub const NV05_IMAGE_FROM_CPU_CLIP_RECTANGLE: u32 = 392;
pub const NV05_IMAGE_FROM_CPU_PATTERN: u32 = 396;
pub const NV05_IMAGE_FROM_CPU_ROP: u32 = 400;
pub const NV05_IMAGE_FROM_CPU_SURFACE: u32 = 412;
pub const NV05_IMAGE_FROM_CPU_OPERATION: u32 = 764;
pub const NV05_IMAGE_FROM_CPU_FORMAT: u32 = 768;
pub const NV05_IMAGE_FROM_CPU_POINT: u32 = 772;
pub const NV05_IMAGE_FROM_CPU_SIZE_OUT: u32 = 776;
pub const NV05_IMAGE_FROM_CPU_SIZE_IN: u32 = 780;
pub const NV05_IMAGE_FROM_CPU_COLOR__SIZE: u32 = 1792;
pub const NV10_TCL_PRIMITIVE_3D: u32 = 86;
pub const NV11_TCL_PRIMITIVE_3D: u32 = 150;
pub const NV17_TCL_PRIMITIVE_3D: u32 = 153;
pub const NV10_TCL_PRIMITIVE_3D_NOP: u32 = 256;
pub const NV10_TCL_PRIMITIVE_3D_NOTIFY: u32 = 260;
pub const NV10_TCL_PRIMITIVE_3D_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY0: u32 = 388;
pub const NV10_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY1: u32 = 392;
pub const NV10_TCL_PRIMITIVE_3D_SET_DISPLAY_LIST: u32 = 396;
pub const NV10_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY2: u32 = 404;
pub const NV10_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY3: u32 = 408;
pub const NV17_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY4: u32 = 428;
pub const NV17_TCL_PRIMITIVE_3D_SET_DMA_IN_MEMORY5: u32 = 432;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_HORIZ: u32 = 512;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_VERT: u32 = 516;
pub const NV10_TCL_PRIMITIVE_3D_BUFFER_FORMAT: u32 = 520;
pub const NV10_TCL_PRIMITIVE_3D_BUFFER_PITCH: u32 = 524;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_OFFSET: u32 = 528;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_OFFSET: u32 = 532;
pub const NV10_TCL_PRIMITIVE_3D_RC_COLOR0: u32 = 624;
pub const NV10_TCL_PRIMITIVE_3D_RC_COLOR1: u32 = 628;
pub const NV10_TCL_PRIMITIVE_3D_RC_FINAL0: u32 = 648;
pub const NV10_TCL_PRIMITIVE_3D_RC_FINAL1: u32 = 652;
pub const NV10_TCL_PRIMITIVE_3D_LIGHT_MODEL: u32 = 660;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MATERIAL_ENABLE: u32 = 664;
pub const NV10_TCL_PRIMITIVE_3D_FOG_MODE: u32 = 668;
pub const NV10_TCL_PRIMITIVE_3D_FOG_COORD_DIST: u32 = 672;
pub const NV10_TCL_PRIMITIVE_3D_FOG_ENABLE: u32 = 676;
pub const NV10_TCL_PRIMITIVE_3D_FOG_COLOR: u32 = 680;
pub const NV17_TCL_PRIMITIVE_3D_COLOR_MASK_ENABLE: u32 = 700;
pub const NV10_TCL_PRIMITIVE_3D_ALPHA_FUNC_ENABLE: u32 = 768;
pub const NV10_TCL_PRIMITIVE_3D_BLEND_FUNC_ENABLE: u32 = 772;
pub const NV10_TCL_PRIMITIVE_3D_CULL_FACE_ENABLE: u32 = 776;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_TEST_ENABLE: u32 = 780;
pub const NV10_TCL_PRIMITIVE_3D_DITHER_ENABLE: u32 = 784;
pub const NV10_TCL_PRIMITIVE_3D_LIGHTING_ENABLE: u32 = 788;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETERS_ENABLE: u32 = 792;
pub const NV10_TCL_PRIMITIVE_3D_POINT_SMOOTH_ENABLE: u32 = 796;
pub const NV10_TCL_PRIMITIVE_3D_LINE_SMOOTH_ENABLE: u32 = 800;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_SMOOTH_ENABLE: u32 = 804;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_WEIGHT_ENABLE: u32 = 808;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_ENABLE: u32 = 812;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_OFFSET_POINT_ENABLE: u32 = 816;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_OFFSET_LINE_ENABLE: u32 = 820;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_OFFSET_FILL_ENABLE: u32 = 824;
pub const NV10_TCL_PRIMITIVE_3D_ALPHA_FUNC_FUNC: u32 = 828;
pub const NV10_TCL_PRIMITIVE_3D_ALPHA_FUNC_REF: u32 = 832;
pub const NV10_TCL_PRIMITIVE_3D_BLEND_FUNC_SRC: u32 = 836;
pub const NV10_TCL_PRIMITIVE_3D_BLEND_FUNC_DST: u32 = 840;
pub const NV10_TCL_PRIMITIVE_3D_BLEND_COLOR: u32 = 844;
pub const NV10_TCL_PRIMITIVE_3D_BLEND_EQUATION: u32 = 848;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_FUNC: u32 = 852;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MASK: u32 = 856;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_WRITE_ENABLE: u32 = 860;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_MASK: u32 = 864;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_FUNC_FUNC: u32 = 868;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_FUNC_REF: u32 = 872;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_FUNC_MASK: u32 = 876;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_OP_FAIL: u32 = 880;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_OP_ZFAIL: u32 = 884;
pub const NV10_TCL_PRIMITIVE_3D_STENCIL_OP_ZPASS: u32 = 888;
pub const NV10_TCL_PRIMITIVE_3D_SHADE_MODEL: u32 = 892;
pub const NV10_TCL_PRIMITIVE_3D_LINE_WIDTH: u32 = 896;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_OFFSET_FACTOR: u32 = 900;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_OFFSET_UNITS: u32 = 904;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_MODE_FRONT: u32 = 908;
pub const NV10_TCL_PRIMITIVE_3D_POLYGON_MODE_BACK: u32 = 912;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_RANGE_NEAR: u32 = 916;
pub const NV10_TCL_PRIMITIVE_3D_DEPTH_RANGE_FAR: u32 = 920;
pub const NV10_TCL_PRIMITIVE_3D_CULL_FACE: u32 = 924;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_FACE: u32 = 928;
pub const NV10_TCL_PRIMITIVE_3D_NORMALIZE_ENABLE: u32 = 932;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MATERIAL_R: u32 = 936;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MATERIAL_G: u32 = 940;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MATERIAL_B: u32 = 944;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_MATERIAL_A: u32 = 948;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_CONTROL: u32 = 952;
pub const NV10_TCL_PRIMITIVE_3D_ENABLED_LIGHTS: u32 = 956;
pub const NV10_TCL_PRIMITIVE_3D_CLIP_PLANE_ENABLE__SIZE: u32 = 8;
pub const NV10_TCL_PRIMITIVE_3D_VIEW_MATRIX_ENABLE: u32 = 1000;
pub const NV10_TCL_PRIMITIVE_3D_POINT_SIZE: u32 = 1004;
pub const NV10_TCL_PRIMITIVE_3D_MODELVIEW0_MATRIX: u32 = 1024;
pub const NV10_TCL_PRIMITIVE_3D_MODELVIEW1_MATRIX: u32 = 1088;
pub const NV10_TCL_PRIMITIVE_3D_INVERSE_MODELVIEW0_MATRIX: u32 = 1152;
pub const NV10_TCL_PRIMITIVE_3D_INVERSE_MODELVIEW1_MATRIX: u32 = 1216;
pub const NV10_TCL_PRIMITIVE_3D_PROJECTION_MATRIX: u32 = 1280;
pub const NV10_TCL_PRIMITIVE_3D_FOG_EQUATION_CONSTANT: u32 = 1664;
pub const NV10_TCL_PRIMITIVE_3D_FOG_EQUATION_LINEAR: u32 = 1668;
pub const NV10_TCL_PRIMITIVE_3D_FOG_EQUATION_QUADRATIC: u32 = 1672;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_A: u32 = 1696;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_B: u32 = 1700;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_C: u32 = 1704;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_D: u32 = 1708;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_E: u32 = 1712;
pub const NV10_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_F: u32 = 1716;
pub const NV10_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_R: u32 = 1732;
pub const NV10_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_G: u32 = 1736;
pub const NV10_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_B: u32 = 1740;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_SCALE_X: u32 = 1768;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_SCALE_Y: u32 = 1772;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_SCALE_Z: u32 = 1776;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_SCALE_W: u32 = 1780;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_A: u32 = 1784;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_B: u32 = 1788;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_C: u32 = 1792;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_D: u32 = 1796;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_E: u32 = 1800;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_F: u32 = 1804;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_G: u32 = 1808;
pub const NV10_TCL_PRIMITIVE_3D_POINT_PARAMETER_H: u32 = 1812;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_3F_X: u32 = 3072;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_3F_Y: u32 = 3076;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_3F_Z: u32 = 3080;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_4F_X: u32 = 3096;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_4F_Y: u32 = 3100;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_4F_Z: u32 = 3104;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_POS_4F_W: u32 = 3108;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_X: u32 = 3120;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_Y: u32 = 3124;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_Z: u32 = 3128;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_NOR_3I_XY: u32 = 3136;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_NOR_3I_Z: u32 = 3140;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_4F_R: u32 = 3152;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_4F_G: u32 = 3156;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_4F_B: u32 = 3160;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_4F_A: u32 = 3164;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_3F_R: u32 = 3168;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_3F_G: u32 = 3172;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_3F_B: u32 = 3176;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL_4I: u32 = 3180;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_R: u32 = 3200;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_G: u32 = 3204;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_B: u32 = 3208;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_COL2_3I: u32 = 3212;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_2F_S: u32 = 3216;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_2F_T: u32 = 3220;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_2I: u32 = 3224;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_S: u32 = 3232;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_T: u32 = 3236;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_R: u32 = 3240;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_Q: u32 = 3244;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4I_ST: u32 = 3248;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX0_4I_RQ: u32 = 3252;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_2F_S: u32 = 3256;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_2F_T: u32 = 3260;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_2I: u32 = 3264;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_S: u32 = 3272;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_T: u32 = 3276;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_R: u32 = 3280;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_Q: u32 = 3284;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4I_ST: u32 = 3288;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_TX1_4I_RQ: u32 = 3292;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_FOG_1F: u32 = 3296;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_WGH_1F: u32 = 3300;
pub const NV10_TCL_PRIMITIVE_3D_EDGEFLAG_ENABLE: u32 = 3308;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_VALIDATE: u32 = 3312;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ATTR__SIZE: u32 = 8;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_POS: u32 = 3328;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_POS: u32 = 3332;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_COL: u32 = 3336;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_COL: u32 = 3340;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_COL2: u32 = 3344;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_COL2: u32 = 3348;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_TX0: u32 = 3352;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_TX0: u32 = 3356;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_TX1: u32 = 3360;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_TX1: u32 = 3364;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_NOR: u32 = 3368;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_NOR: u32 = 3372;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_WGH: u32 = 3376;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_WGH: u32 = 3380;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_OFFSET_FOG: u32 = 3384;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_FORMAT_FOG: u32 = 3388;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_LOGIC_OP_ENABLE: u32 = 3392;
pub const NV10_TCL_PRIMITIVE_3D_COLOR_LOGIC_OP_OP: u32 = 3396;
pub const NV17_TCL_PRIMITIVE_3D_LMA_DEPTH_BUFFER_PITCH: u32 = 3420;
pub const NV17_TCL_PRIMITIVE_3D_LMA_DEPTH_BUFFER_OFFSET: u32 = 3424;
pub const NV17_TCL_PRIMITIVE_3D_LMA_DEPTH_FILL_VALUE: u32 = 3432;
pub const NV17_TCL_PRIMITIVE_3D_LMA_DEPTH_CLEAR_ENABLE: u32 = 3436;
pub const NV10_TCL_PRIMITIVE_3D_BEGIN_END: u32 = 3580;
pub const NV10_TCL_PRIMITIVE_3D_INDEX_DATA: u32 = 3584;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_BUFFER_BEGIN_END: u32 = 5116;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_BUFFER_DRAW_ARRAYS: u32 = 5120;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_X: u32 = 5688;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_Y: u32 = 5692;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_Z: u32 = 5696;
pub const NV10_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_W: u32 = 5700;
pub const NV17_TCL_PRIMITIVE_3D_LMA_DEPTH_ENABLE: u32 = 5720;
pub const NV10_TCL_PRIMITIVE_3D_VERTEX_ARRAY_DATA: u32 = 6144;
pub const NV10_IMAGE_FROM_CPU: u32 = 138;
pub const NV10_IMAGE_FROM_CPU_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_IMAGE_FROM_CPU_SET_CONTEXT_CLIP_RECTANGLE: u32 = 392;
pub const NV10_IMAGE_FROM_CPU_SET_IMAGE_PATTERN: u32 = 396;
pub const NV10_IMAGE_FROM_CPU_SET_RASTER_OP: u32 = 400;
pub const NV10_IMAGE_FROM_CPU_SET_CONTEXT_SURFACES_2D: u32 = 412;
pub const NV10_IMAGE_FROM_CPU_OPERATION: u32 = 764;
pub const NV10_IMAGE_FROM_CPU_FORMAT: u32 = 768;
pub const NV10_IMAGE_FROM_CPU_POINT: u32 = 772;
pub const NV10_IMAGE_FROM_CPU_SIZE_OUT: u32 = 776;
pub const NV10_IMAGE_FROM_CPU_SIZE_IN: u32 = 780;
pub const NV10_IMAGE_FROM_CPU_HLINE: u32 = 1024;
pub const NV10_UNK0072: u32 = 114;
pub const NV10_UNK0072_COUNTER: u32 = 80;
pub const NV40_UNK0072_SET_OBJECT: u32 = 96;
pub const NV40_UNK0072_UNK0: u32 = 100;
pub const NV40_UNK0072_UNK1: u32 = 108;
pub const NV10_UNK0072_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_PRIMITIVE_2D: u32 = 123;
pub const NV10_PRIMITIVE_2D_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_PRIMITIVE_2D_SET_SURFACE: u32 = 388;
pub const NV10_PRIMITIVE_2D_SET_FORMAT: u32 = 768;
pub const NV10_PRIMITIVE_2D_SET_POINT: u32 = 772;
pub const NV10_PRIMITIVE_2D_SET_SIZE: u32 = 776;
pub const NV10_PRIMITIVE_2D_SET_CLIP_HORIZ: u32 = 780;
pub const NV10_PRIMITIVE_2D_SET_CLIP_VERT: u32 = 784;
pub const NV10_PRIMITIVE_2D_SET_DATA__SIZE: u32 = 1792;
pub const NV01_CONTEXT_CLIP_RECTANGLE: u32 = 25;
pub const NV01_CONTEXT_CLIP_RECTANGLE_SET_POINT: u32 = 768;
pub const NV01_CONTEXT_CLIP_RECTANGLE_SET_SIZE: u32 = 772;
pub const NV03_PRIMITIVE_RASTER_OP: u32 = 67;
pub const NV03_PRIMITIVE_RASTER_OP_NOTIFY: u32 = 256;
pub const NV03_PRIMITIVE_RASTER_OP_DMA_NOTIFY: u32 = 384;
pub const NV03_PRIMITIVE_RASTER_OP_LOGIC_OP: u32 = 768;
pub const NV04_CONTEXT_SURFACES_2D: u32 = 66;
pub const NV04_CONTEXT_SURFACES_2D_NOTIFY: u32 = 260;
pub const NV04_CONTEXT_SURFACES_2D_SET_DMA_NOTIFY: u32 = 384;
pub const NV04_CONTEXT_SURFACES_2D_SET_DMA_IMAGE_SRC: u32 = 388;
pub const NV04_CONTEXT_SURFACES_2D_SET_DMA_IMAGE_DST: u32 = 392;
pub const NV04_CONTEXT_SURFACES_2D_FORMAT: u32 = 768;
pub const NV04_CONTEXT_SURFACES_2D_PITCH: u32 = 772;
pub const NV04_CONTEXT_SURFACES_2D_OFFSET_SRC: u32 = 776;
pub const NV04_CONTEXT_SURFACES_2D_OFFSET_DST: u32 = 780;
pub const NV04_IMAGE_PATTERN: u32 = 68;
pub const NV04_IMAGE_PATTERN_COLOR_FORMAT: u32 = 768;
pub const NV04_IMAGE_PATTERN_MONO_FORMAT: u32 = 772;
pub const NV04_IMAGE_PATTERN_SELECT: u32 = 780;
pub const NV04_IMAGE_PATTERN_MONOCHROME_SHAPE: u32 = 776;
pub const NV04_IMAGE_PATTERN_MONOCHROME_COLOR0: u32 = 784;
pub const NV04_IMAGE_PATTERN_MONOCHROME_COLOR1: u32 = 788;
pub const NV04_IMAGE_PATTERN_MONOCHROME_PATTERN0: u32 = 792;
pub const NV04_IMAGE_PATTERN_MONOCHROME_PATTERN1: u32 = 796;
pub const NV04_SWIZZLED_SURFACE: u32 = 82;
pub const NV04_SWIZZLED_SURFACE_DMA_NOTIFY: u32 = 384;
pub const NV04_SWIZZLED_SURFACE_DMA_IMAGE: u32 = 388;
pub const NV04_SWIZZLED_SURFACE_FORMAT: u32 = 768;
pub const NV04_SWIZZLED_SURFACE_OFFSET: u32 = 772;
pub const NV_IMAGE_BLIT: u32 = 95;
pub const NV_IMAGE_BLIT_NOP: u32 = 256;
pub const NV_IMAGE_BLIT_NOTIFY: u32 = 260;
pub const NV_IMAGE_BLIT_DMA_NOTIFY: u32 = 384;
pub const NV_IMAGE_BLIT_COLOR_KEY: u32 = 388;
pub const NV_IMAGE_BLIT_CLIP_RECTANGLE: u32 = 392;
pub const NV_IMAGE_BLIT_PATTERN: u32 = 396;
pub const NV_IMAGE_BLIT_ROP5: u32 = 400;
pub const NV_IMAGE_BLIT_SURFACE: u32 = 412;
pub const NV_IMAGE_BLIT_OPERATION: u32 = 764;
pub const NV_IMAGE_BLIT_POINT_IN: u32 = 768;
pub const NV_IMAGE_BLIT_POINT_OUT: u32 = 772;
pub const NV_IMAGE_BLIT_SIZE: u32 = 776;
pub const NV10_CONTEXT_SURFACES_2D: u32 = 98;
pub const NV10_CONTEXT_SURFACES_2D_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_CONTEXT_SURFACES_2D_SET_DMA_IN_MEMORY0: u32 = 388;
pub const NV10_CONTEXT_SURFACES_2D_SET_DMA_IN_MEMORY1: u32 = 392;
pub const NV10_CONTEXT_SURFACES_2D_FORMAT: u32 = 768;
pub const NV10_CONTEXT_SURFACES_2D_PITCH: u32 = 772;
pub const NV10_CONTEXT_SURFACES_2D_OFFSET_SRC: u32 = 776;
pub const NV10_CONTEXT_SURFACES_2D_OFFSET_DST: u32 = 780;
pub const NV05_SCALED_IMAGE_FROM_MEMORY: u32 = 99;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_SURFACE: u32 = 408;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_COLOR_CONVERSION: u32 = 764;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_OPERATION: u32 = 772;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_CLIP_POS: u32 = 776;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_CLIP_SIZE: u32 = 780;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_OUT_POS: u32 = 784;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_OUT_SIZE: u32 = 788;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_DU_DX: u32 = 792;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_DV_DY: u32 = 796;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_SIZE: u32 = 1024;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_FORMAT: u32 = 1028;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_OFFSET: u32 = 1032;
pub const NV05_SCALED_IMAGE_FROM_MEMORY_POINT: u32 = 1036;
pub const NV04_SCALED_IMAGE_FROM_MEMORY: u32 = 119;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_DMA_NOTIFY: u32 = 384;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_DMA_IMAGE: u32 = 388;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_SURFACE: u32 = 408;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_COLOR_FORMAT: u32 = 768;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_OPERATION: u32 = 772;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_CLIP_POS: u32 = 776;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_CLIP_SIZE: u32 = 780;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_OUT_POS: u32 = 784;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_OUT_SIZE: u32 = 788;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_DU_DX: u32 = 792;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_DV_DY: u32 = 796;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_SIZE: u32 = 1024;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_FORMAT: u32 = 1028;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_OFFSET: u32 = 1032;
pub const NV04_SCALED_IMAGE_FROM_MEMORY_POINT: u32 = 1036;
pub const NV10_VIDEO_DISPLAY: u32 = 124;
pub const NV10_VIDEO_DISPLAY_COUNTER: u32 = 80;
pub const NV10_VIDEO_DISPLAY_SET_DMA_FROM_MEMORY: u32 = 384;
pub const NV10_VIDEO_DISPLAY_SET_DMA_IN_MEMORY0: u32 = 388;
pub const NV10_VIDEO_DISPLAY_SET_DMA_IN_MEMORY1: u32 = 392;
pub const NV10_VIDEO_DISPLAY_SET_OBJECT3: u32 = 412;
pub const NV10_VIDEO_DISPLAY_UNK0250: u32 = 592;
pub const NV10_VIDEO_DISPLAY_SIZE: u32 = 760;
pub const NV10_VIDEO_DISPLAY_OFFSET: u32 = 768;
pub const NV10_VIDEO_DISPLAY_UNK0304: u32 = 772;
pub const NV10_SCALED_IMAGE_FROM_MEMORY: u32 = 137;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_COUNTER: u32 = 80;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_SET_DMA_IN_MEMORY: u32 = 388;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_SET_IMAGE_PATTERN: u32 = 392;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_SET_RASTER_OP: u32 = 396;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_SET_SURFACE: u32 = 408;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_UNK02fc: u32 = 764;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_UNK0300: u32 = 768;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_OPERATION: u32 = 772;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_CLIP_POS: u32 = 776;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_CLIP_SIZE: u32 = 780;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_OUT_POS: u32 = 784;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_OUT_SIZE: u32 = 788;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_SIZE: u32 = 1024;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_FORMAT: u32 = 1028;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_OFFSET: u32 = 1032;
pub const NV10_SCALED_IMAGE_FROM_MEMORY_POINT: u32 = 1036;
pub const NV10_IMAGE_BLIT: u32 = 159;
pub const NV10_IMAGE_BLIT_NOP: u32 = 256;
pub const NV10_IMAGE_BLIT_NOTIFY: u32 = 260;
pub const NV10_IMAGE_BLIT_SET_DMA_NOTIFY: u32 = 384;
pub const NV10_IMAGE_BLIT_SET_CONTEXT_CLIP_RECTANGLE: u32 = 392;
pub const NV10_IMAGE_BLIT_SET_IMAGE_PATTERN: u32 = 396;
pub const NV10_IMAGE_BLIT_SET_RASTER_OP: u32 = 400;
pub const NV10_IMAGE_BLIT_SET_CONTEXT_SURFACES_2D: u32 = 412;
pub const NV10_IMAGE_BLIT_SET_OPERATION: u32 = 764;
pub const NV10_IMAGE_BLIT_SET_POINT: u32 = 768;
pub const NV10_IMAGE_BLIT_SET_PITCH: u32 = 772;
pub const NV10_IMAGE_BLIT_SET_SIZE: u32 = 776;
pub const NV20_SWIZZLED_SURFACE: u32 = 158;
pub const NV20_SWIZZLED_SURFACE_SET_OBJECT0: u32 = 384;
pub const NV20_SWIZZLED_SURFACE_SET_OBJECT1: u32 = 388;
pub const NV20_SWIZZLED_SURFACE_FORMAT: u32 = 768;
pub const NV20_SWIZZLED_SURFACE_OFFSET: u32 = 772;
pub const NV20_TCL_PRIMITIVE_SET_MAIN_OBJECT: u32 = 0;
pub const NV20_TCL_PRIMITIVE_3D: u32 = 151;
pub const NV20_TCL_PRIMITIVE_3D_NOP: u32 = 256;
pub const NV20_TCL_PRIMITIVE_3D_FIRE_INTERRUPT: u32 = 256;
pub const NV20_TCL_PRIMITIVE_3D_NOTIFY: u32 = 260;
pub const NV20_TCL_PRIMITIVE_3D_WAIT_MAKESPACE: u32 = 272;
pub const NV20_TCL_PRIMITIVE_3D_MAIN_TILES_INDICES: u32 = 288;
pub const NV20_TCL_PRIMITIVE_3D_ASK_FOR_IDLE: u32 = 300;
pub const NV20_TCL_PRIMITIVE_3D_STALL_PIPELINE: u32 = 304;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT0: u32 = 384;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT1: u32 = 388;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT2: u32 = 392;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT2A: u32 = 400;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT3: u32 = 404;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT4: u32 = 408;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT5: u32 = 412;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT6: u32 = 416;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT7: u32 = 420;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT8: u32 = 424;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT9: u32 = 428;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT10: u32 = 432;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_HORIZ: u32 = 512;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_VERT: u32 = 516;
pub const NV20_TCL_PRIMITIVE_3D_BUFFER_FORMAT: u32 = 520;
pub const NV20_TCL_PRIMITIVE_3D_BUFFER_PITCH: u32 = 524;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_OFFSET: u32 = 528;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_OFFSET: u32 = 532;
pub const NV20_TCL_PRIMITIVE_3D_LMA_DEPTH_BUFFER_PITCH: u32 = 556;
pub const NV20_TCL_PRIMITIVE_3D_LMA_DEPTH_BUFFER_OFFSET: u32 = 560;
pub const NV20_TCL_PRIMITIVE_3D_W_YUV_FPZ_FLAGS: u32 = 656;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_CONTROL: u32 = 660;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_CONTROL: u32 = 664;
pub const NV20_TCL_PRIMITIVE_3D_FOG_MODE: u32 = 668;
pub const NV20_TCL_PRIMITIVE_3D_FOG_COORD_DIST: u32 = 672;
pub const NV20_TCL_PRIMITIVE_3D_FOG_ENABLE: u32 = 676;
pub const NV20_TCL_PRIMITIVE_3D_FOG_COLOR: u32 = 680;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_CLIP_MODE: u32 = 692;
pub const NV20_TCL_PRIMITIVE_3D_SET_OBJECT_UNKNOWN: u32 = 764;
pub const NV20_TCL_PRIMITIVE_3D_ALPHA_FUNC_ENABLE: u32 = 768;
pub const NV20_TCL_PRIMITIVE_3D_BLEND_FUNC_ENABLE: u32 = 772;
pub const NV20_TCL_PRIMITIVE_3D_CULL_FACE_ENABLE: u32 = 776;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_TEST_ENABLE: u32 = 780;
pub const NV20_TCL_PRIMITIVE_3D_DITHER_ENABLE: u32 = 784;
pub const NV20_TCL_PRIMITIVE_3D_LIGHTING_ENABLE: u32 = 788;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETERS_ENABLE: u32 = 792;
pub const NV20_TCL_PRIMITIVE_3D_POINT_SMOOTH_ENABLE: u32 = 796;
pub const NV20_TCL_PRIMITIVE_3D_LINE_SMOOTH_ENABLE: u32 = 800;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_SMOOTH_ENABLE: u32 = 804;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_BLEND_ENABLE: u32 = 808;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_ENABLE: u32 = 812;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_OFFSET_POINT_ENABLE: u32 = 816;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_OFFSET_LINE_ENABLE: u32 = 820;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_OFFSET_FILL_ENABLE: u32 = 824;
pub const NV20_TCL_PRIMITIVE_3D_ALPHA_FUNC_FUNC: u32 = 828;
pub const NV20_TCL_PRIMITIVE_3D_ALPHA_FUNC_REF: u32 = 832;
pub const NV20_TCL_PRIMITIVE_3D_BLEND_FUNC_SRC: u32 = 836;
pub const NV20_TCL_PRIMITIVE_3D_BLEND_FUNC_DST: u32 = 840;
pub const NV20_TCL_PRIMITIVE_3D_BLEND_COLOR: u32 = 844;
pub const NV20_TCL_PRIMITIVE_3D_BLEND_EQUATION: u32 = 848;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_FUNC: u32 = 852;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MASK: u32 = 856;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_WRITE_ENABLE: u32 = 860;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_MASK: u32 = 864;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_FUNC_FUNC: u32 = 868;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_FUNC_REF: u32 = 872;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_FUNC_MASK: u32 = 876;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_OP_FAIL: u32 = 880;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_OP_ZFAIL: u32 = 884;
pub const NV20_TCL_PRIMITIVE_3D_STENCIL_OP_ZPASS: u32 = 888;
pub const NV20_TCL_PRIMITIVE_3D_SHADE_MODEL: u32 = 892;
pub const NV20_TCL_PRIMITIVE_3D_LINE_WIDTH: u32 = 896;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_OFFSET_FACTOR: u32 = 900;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_OFFSET_UNITS: u32 = 904;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_MODE_FRONT: u32 = 908;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_MODE_BACK: u32 = 912;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_RANGE_NEAR: u32 = 916;
pub const NV20_TCL_PRIMITIVE_3D_DEPTH_RANGE_FAR: u32 = 920;
pub const NV20_TCL_PRIMITIVE_3D_CULL_FACE: u32 = 924;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_FACE: u32 = 928;
pub const NV20_TCL_PRIMITIVE_3D_NORMALIZE_ENABLE: u32 = 932;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_FRONT_R: u32 = 936;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_FRONT_G: u32 = 940;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_FRONT_B: u32 = 944;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_FRONT_A: u32 = 948;
pub const NV20_TCL_PRIMITIVE_3D_SEPARATE_SPECULAR_ENABLE: u32 = 952;
pub const NV20_TCL_PRIMITIVE_3D_ENABLED_LIGHTS: u32 = 956;
pub const NV20_TCL_PRIMITIVE_3D_POINT_SIZE: u32 = 1084;
pub const NV20_TCL_PRIMITIVE_3D_MODELVIEW_MATRIX: u32 = 1152;
pub const NV20_TCL_PRIMITIVE_3D_INVERSE_MODELVIEW_MATRIX: u32 = 1408;
pub const NV20_TCL_PRIMITIVE_3D_PROJECTION_MATRIX: u32 = 1664;
pub const NV20_TCL_PRIMITIVE_3D_FOG_EQUATION_CONSTANT: u32 = 2496;
pub const NV20_TCL_PRIMITIVE_3D_FOG_EQUATION_LINEAR: u32 = 2500;
pub const NV20_TCL_PRIMITIVE_3D_FOG_EQUATION_QUADRATIC: u32 = 2504;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_A: u32 = 2528;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_B: u32 = 2532;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_C: u32 = 2536;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_D: u32 = 2540;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_E: u32 = 2544;
pub const NV20_TCL_PRIMITIVE_3D_FRONT_MATERIAL_SHININESS_F: u32 = 2548;
pub const NV20_TCL_PRIMITIVE_3D_SWATHWIDTH: u32 = 2552;
pub const NV20_TCL_PRIMITIVE_3D_POINT_SPRITE: u32 = 2588;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_OX: u32 = 2592;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_OY: u32 = 2596;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_DEPTH_AVG_S: u32 = 2600;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_UNKNOWN_A: u32 = 2604;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_A: u32 = 2608;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_B: u32 = 2612;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_C: u32 = 2616;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_D: u32 = 2620;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_E: u32 = 2624;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_F: u32 = 2628;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_G: u32 = 2632;
pub const NV20_TCL_PRIMITIVE_3D_POINT_PARAMETER_H: u32 = 2636;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_PX_DIV2: u32 = 2800;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_PY_DIV2: u32 = 2804;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_DEPTH_HALF_S: u32 = 2808;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_UNKNOWN_B: u32 = 2812;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_INST0: u32 = 2816;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_INST1: u32 = 2820;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_INST2: u32 = 2824;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_INST3: u32 = 2828;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_CONST_X: u32 = 2944;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_CONST_Y: u32 = 2948;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_CONST_Z: u32 = 2952;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_CONST_W: u32 = 2956;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_R: u32 = 2576;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_G: u32 = 2580;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_FRONT_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_B: u32 = 2584;
pub const NV20_TCL_PRIMITIVE_3D_RC_ENABLE: u32 = 7776;
pub const NV20_TCL_PRIMITIVE_3D_TX_SHADER_OP: u32 = 7792;
pub const NV20_TCL_PRIMITIVE_3D_TX_SHADER_CULL_MODE: u32 = 6136;
pub const NV20_TCL_PRIMITIVE_3D_TX_SHADER_PREVIOUS: u32 = 7800;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_CONST_ID: u32 = 7844;
pub const NV20_TCL_PRIMITIVE_3D_RC_COLOR0: u32 = 7712;
pub const NV20_TCL_PRIMITIVE_3D_RC_COLOR1: u32 = 7716;
pub const NV20_TCL_PRIMITIVE_3D_RC_FINAL0: u32 = 648;
pub const NV20_TCL_PRIMITIVE_3D_RC_FINAL1: u32 = 652;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_A: u32 = 7720;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_B: u32 = 7724;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_C: u32 = 7728;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_D: u32 = 7732;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_E: u32 = 7736;
pub const NV20_TCL_PRIMITIVE_3D_BACK_MATERIAL_SHININESS_F: u32 = 7740;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_STIPPLE_ENABLE: u32 = 5244;
pub const NV20_TCL_PRIMITIVE_3D_POLYGON_STIPPLE_PATTERN__SIZE: u32 = 32;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_3F_X: u32 = 5376;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_3F_Y: u32 = 5380;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_3F_Z: u32 = 5384;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4F_X: u32 = 5400;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4F_Y: u32 = 5404;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4F_Z: u32 = 5408;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4F_W: u32 = 5412;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4I_XY: u32 = 5416;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_POS_4I_ZW: u32 = 5420;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_X: u32 = 5424;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_Y: u32 = 5428;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_NOR_3F_Z: u32 = 5432;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_NOR_3I_XY: u32 = 5440;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_NOR_3I_Z: u32 = 5444;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_4F_R: u32 = 5456;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_4F_G: u32 = 5460;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_4F_B: u32 = 5464;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_4F_A: u32 = 5468;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_3F_R: u32 = 5472;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_3F_G: u32 = 5476;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_3F_B: u32 = 5480;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL_4I: u32 = 5484;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_R: u32 = 5504;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_G: u32 = 5508;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL2_3F_B: u32 = 5512;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_COL2_3I: u32 = 5516;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_2F_S: u32 = 5520;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_2F_T: u32 = 5524;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_2I: u32 = 5528;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_S: u32 = 5536;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_T: u32 = 5540;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_R: u32 = 5544;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4F_Q: u32 = 5548;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4I_ST: u32 = 5552;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX0_4I_RQ: u32 = 5556;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_2F_S: u32 = 5560;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_2F_T: u32 = 5564;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_2I: u32 = 5568;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_S: u32 = 5576;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_T: u32 = 5580;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_R: u32 = 5584;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4F_Q: u32 = 5588;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4I_ST: u32 = 5592;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX1_4I_RQ: u32 = 5596;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_2F_S: u32 = 5600;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_2F_T: u32 = 5604;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_2I: u32 = 5608;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4F_S: u32 = 5616;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4F_T: u32 = 5620;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4F_R: u32 = 5624;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4F_Q: u32 = 5628;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4I_ST: u32 = 5632;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX2_4I_RQ: u32 = 5636;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_2F_S: u32 = 5640;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_2F_T: u32 = 5644;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_2I: u32 = 5648;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4F_S: u32 = 5664;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4F_T: u32 = 5668;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4F_R: u32 = 5672;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4F_Q: u32 = 5676;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4I_ST: u32 = 5680;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_TX3_4I_RQ: u32 = 5684;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_FOG_1F: u32 = 5784;
pub const NV20_TCL_PRIMITIVE_3D_EDGE_FLAG: u32 = 5820;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR0_POS: u32 = 5920;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR1_WGH: u32 = 5924;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR2_NOR: u32 = 5928;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR3_COL: u32 = 5932;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR4_COL2: u32 = 5936;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR5_FOG: u32 = 5940;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR6: u32 = 5944;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR7: u32 = 5948;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR8_TX0: u32 = 5952;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR9_TX1: u32 = 5956;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR10_TX2: u32 = 5960;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR11_TX3: u32 = 5964;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR12_TX4: u32 = 5968;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR13_TX5: u32 = 5972;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR14_TX6: u32 = 5976;
pub const NV20_TCL_PRIMITIVE_3D_VB_POINTER_ATTR15_TX7: u32 = 5980;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR__SIZE: u32 = 16;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR0_POS: u32 = 5984;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR1_WGH: u32 = 5988;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR2_NOR: u32 = 5992;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR3_COL: u32 = 5996;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR4_COL2: u32 = 6000;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR5_FOG: u32 = 6004;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR6: u32 = 6008;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR7: u32 = 6012;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR8_TX0: u32 = 6016;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR9_TX1: u32 = 6020;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR10_TX2: u32 = 6024;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR11_TX3: u32 = 6028;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR12_TX4: u32 = 6032;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR13_TX5: u32 = 6036;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR14_TX6: u32 = 6040;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_ATTR15_TX7: u32 = 6044;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_BACK_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_R: u32 = 6048;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_BACK_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_G: u32 = 6052;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_BACK_SIDE_PRODUCT_AMBIENT_PLUS_EMISSION_B: u32 = 6056;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_BACK_A: u32 = 6060;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_BACK_R: u32 = 6064;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_BACK_G: u32 = 6068;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_MATERIAL_BACK_B: u32 = 6072;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_LOGIC_OP_ENABLE: u32 = 6076;
pub const NV20_TCL_PRIMITIVE_3D_COLOR_LOGIC_OP_OP: u32 = 6080;
pub const NV20_TCL_PRIMITIVE_3D_LIGHT_MODEL_TWO_SIDE_ENABLE: u32 = 6084;
pub const NV20_TCL_PRIMITIVE_3D_BEGIN_END: u32 = 6140;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S0_ZERO: u32 = 0;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S0_ONE: u32 = 1;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S0_S1: u32 = 2;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S1_X: u32 = 3;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S1_Y: u32 = 2;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S1_Z: u32 = 1;
pub const NV20_TCL_PRIMITIVE_3D_TX_SWIZZLE_S1_W: u32 = 0;
pub const NV20_TCL_PRIMITIVE_3D_INDEX_DATA: u32 = 6144;
pub const NV20_TCL_PRIMITIVE_3D_VB_VERTEX_BATCH: u32 = 6160;
pub const NV20_TCL_PRIMITIVE_3D_VERTEX_DATA: u32 = 6168;
pub const NV20_TCL_PRIMITIVE_3D_SCISSOR_X2_X1: u32 = 7216;
pub const NV20_TCL_PRIMITIVE_3D_SCISSOR_Y2_Y1: u32 = 7248;
pub const NV20_TCL_PRIMITIVE_3D_ACTIVATE_COLORS: u32 = 7532;
pub const NV20_TCL_PRIMITIVE_3D_MULTISAMPLE: u32 = 7548;
pub const NV20_TCL_PRIMITIVE_3D_CULL_ENABLE: u32 = 7556;
pub const NV20_TCL_PRIMITIVE_3D_PARAMETER_A: u32 = 7564;
pub const NV20_TCL_PRIMITIVE_3D_PARAMETER_B: u32 = 7568;
pub const NV20_TCL_PRIMITIVE_3D_CLEAR_VALUE_DEPTH: u32 = 7564;
pub const NV20_TCL_PRIMITIVE_3D_CLEAR_VALUE_ARGB: u32 = 7568;
pub const NV20_TCL_PRIMITIVE_3D_CLEAR_WHICH_BUFFERS: u32 = 7572;
pub const NV20_TCL_PRIMITIVE_3D_CLEAR_VALUE_HORIZ: u32 = 7576;
pub const NV20_TCL_PRIMITIVE_3D_CLEAR_VALUE_VERT: u32 = 7580;
pub const NV20_TCL_PRIMITIVE_3D_SHADOW_FUNC_FUNC: u32 = 7788;
pub const NV20_TCL_PRIMITIVE_3D_TX_SHADER_DOTMAPPING: u32 = 7796;
pub const NV20_TCL_PRIMITIVE_3D_SHADER_TYPE: u32 = 7828;
pub const SHADER_TYPE_INTERNAL: u32 = 4;
pub const SHADER_TYPE_EXTERNAL: u32 = 6;
pub const SHADER_TYPE_INTERNAL_LIMITED: u32 = 0;
pub const SHADER_TYPE_EXTERNAL_LIMITED: u32 = 2;
pub const NV20_TCL_PRIMITIVE_3D_SHADER_SUBTYPE: u32 = 7832;
pub const SHADER_SUBTYPE_REGULAR: u32 = 0;
pub const SHADER_SUBTYPE_WRITE: u32 = 1;
pub const NV20_TCL_PRIMITIVE_3D_VP_UPLOAD_FROM_ID: u32 = 7836;
pub const NV20_TCL_PRIMITIVE_3D_VP_PROGRAM_START_ID: u32 = 7840;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_X: u32 = 7936;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_Y: u32 = 7940;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_Z: u32 = 7944;
pub const NV20_TCL_PRIMITIVE_3D_VIEWPORT_ORIGIN_W: u32 = 7948;
pub const NV_KELVIN_PRIMITIVE: u32 = 151;
pub const NV097_NO_OPERATION: u32 = 256;
pub const NV097_WAIT_FOR_IDLE: u32 = 272;
pub const NV097_SET_FLIP_READ: u32 = 288;
pub const NV097_SET_FLIP_WRITE: u32 = 292;
pub const NV097_SET_FLIP_MODULO: u32 = 296;
pub const NV097_FLIP_INCREMENT_WRITE: u32 = 300;
pub const NV097_FLIP_STALL: u32 = 304;
pub const NV097_SET_CONTEXT_DMA_NOTIFIES: u32 = 384;
pub const NV097_SET_CONTEXT_DMA_A: u32 = 388;
pub const NV097_SET_CONTEXT_DMA_B: u32 = 392;
pub const NV097_SET_CONTEXT_DMA_STATE: u32 = 400;
pub const NV097_SET_CONTEXT_DMA_COLOR: u32 = 404;
pub const NV097_SET_CONTEXT_DMA_ZETA: u32 = 408;
pub const NV097_SET_CONTEXT_DMA_VERTEX_A: u32 = 412;
pub const NV097_SET_CONTEXT_DMA_VERTEX_B: u32 = 416;
pub const NV097_SET_CONTEXT_DMA_SEMAPHORE: u32 = 420;
pub const NV097_SET_CONTEXT_DMA_REPORT: u32 = 424;
pub const NV097_SET_SURFACE_CLIP_HORIZONTAL: u32 = 512;
pub const NV097_SET_SURFACE_CLIP_HORIZONTAL_X: u32 = 65535;
pub const NV097_SET_SURFACE_CLIP_HORIZONTAL_WIDTH: u32 = 4294901760;
pub const NV097_SET_SURFACE_CLIP_VERTICAL: u32 = 516;
pub const NV097_SET_SURFACE_CLIP_VERTICAL_Y: u32 = 65535;
pub const NV097_SET_SURFACE_CLIP_VERTICAL_HEIGHT: u32 = 4294901760;
pub const NV097_SET_SURFACE_FORMAT: u32 = 520;
pub const NV097_SET_SURFACE_FORMAT_COLOR: u32 = 15;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5: u32 = 1;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5: u32 = 2;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5: u32 = 3;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8: u32 = 4;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8: u32 = 5;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8: u32 = 6;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8: u32 = 7;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8: u32 = 8;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_B8: u32 = 9;
pub const NV097_SET_SURFACE_FORMAT_COLOR_LE_G8B8: u32 = 10;
pub const NV097_SET_SURFACE_FORMAT_ZETA: u32 = 240;
pub const NV097_SET_SURFACE_FORMAT_ZETA_Z16: u32 = 1;
pub const NV097_SET_SURFACE_FORMAT_ZETA_Z24S8: u32 = 2;
pub const NV097_SET_SURFACE_FORMAT_TYPE: u32 = 3840;
pub const NV097_SET_SURFACE_FORMAT_TYPE_PITCH: u32 = 1;
pub const NV097_SET_SURFACE_FORMAT_TYPE_SWIZZLE: u32 = 2;
pub const NV097_SET_SURFACE_FORMAT_ANTI_ALIASING: u32 = 61440;
pub const NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1: u32 = 0;
pub const NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_CORNER_2: u32 = 1;
pub const NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_SQUARE_OFFSET_4: u32 = 2;
pub const NV097_SET_SURFACE_FORMAT_WIDTH: u32 = 16711680;
pub const NV097_SET_SURFACE_FORMAT_HEIGHT: u32 = 4278190080;
pub const NV097_SET_SURFACE_PITCH: u32 = 524;
pub const NV097_SET_SURFACE_PITCH_COLOR: u32 = 65535;
pub const NV097_SET_SURFACE_PITCH_ZETA: u32 = 4294901760;
pub const NV097_SET_SURFACE_COLOR_OFFSET: u32 = 528;
pub const NV097_SET_SURFACE_ZETA_OFFSET: u32 = 532;
pub const NV097_SET_COMBINER_ALPHA_ICW: u32 = 608;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP: u32 = 3758096384;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY: u32 = 0;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT: u32 = 1;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL: u32 = 2;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE: u32 = 3;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL: u32 = 4;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE: u32 = 5;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY: u32 = 6;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE: u32 = 7;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA: u32 = 268435456;
pub const NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE: u32 = 251658240;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP: u32 = 14680064;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY: u32 = 0;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT: u32 = 1;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL: u32 = 2;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE: u32 = 3;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL: u32 = 4;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE: u32 = 5;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY: u32 = 6;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE: u32 = 7;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA: u32 = 1048576;
pub const NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE: u32 = 983040;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP: u32 = 57344;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY: u32 = 0;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT: u32 = 1;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL: u32 = 2;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE: u32 = 3;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL: u32 = 4;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE: u32 = 5;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY: u32 = 6;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE: u32 = 7;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA: u32 = 4096;
pub const NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE: u32 = 3840;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP: u32 = 224;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY: u32 = 0;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT: u32 = 1;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL: u32 = 2;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE: u32 = 3;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL: u32 = 4;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE: u32 = 5;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY: u32 = 6;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE: u32 = 7;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA: u32 = 16;
pub const NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0: u32 = 648;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE: u32 = 3758096384;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA: u32 = 268435456;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE: u32 = 251658240;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT: u32 = 14;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE: u32 = 14680064;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA: u32 = 1048576;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE: u32 = 983040;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT: u32 = 14;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE: u32 = 57344;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA: u32 = 4096;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE: u32 = 3840;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT: u32 = 14;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE: u32 = 224;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA: u32 = 16;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT: u32 = 14;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD: u32 = 15;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1: u32 = 652;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE: u32 = 3758096384;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA: u32 = 268435456;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE: u32 = 251658240;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE: u32 = 14680064;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA: u32 = 1048576;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE: u32 = 983040;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE: u32 = 57344;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA: u32 = 4096;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE: u32 = 3840;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP: u32 = 128;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5: u32 = 64;
pub const NV097_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12: u32 = 63;
pub const NV097_SET_CONTROL0: u32 = 656;
pub const NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE: u32 = 1;
pub const NV097_SET_CONTROL0_Z_FORMAT: u32 = 4096;
pub const NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE: u32 = 65536;
pub const NV097_SET_FOG_MODE: u32 = 668;
pub const NV097_SET_FOG_MODE_V_LINEAR: u32 = 9729;
pub const NV097_SET_FOG_MODE_V_EXP: u32 = 2048;
pub const NV097_SET_FOG_MODE_V_EXP2: u32 = 2049;
pub const NV097_SET_FOG_MODE_V_EXP_ABS: u32 = 2050;
pub const NV097_SET_FOG_MODE_V_EXP2_ABS: u32 = 2051;
pub const NV097_SET_FOG_MODE_V_LINEAR_ABS: u32 = 2052;
pub const NV097_SET_FOG_GEN_MODE: u32 = 672;
pub const NV097_SET_FOG_GEN_MODE_V_SPEC_ALPHA: u32 = 0;
pub const NV097_SET_FOG_GEN_MODE_V_RADIAL: u32 = 1;
pub const NV097_SET_FOG_GEN_MODE_V_PLANAR: u32 = 2;
pub const NV097_SET_FOG_GEN_MODE_V_ABS_PLANAR: u32 = 3;
pub const NV097_SET_FOG_GEN_MODE_V_FOG_X: u32 = 6;
pub const NV097_SET_FOG_ENABLE: u32 = 676;
pub const NV097_SET_FOG_COLOR: u32 = 680;
pub const NV097_SET_FOG_COLOR_RED: u32 = 255;
pub const NV097_SET_FOG_COLOR_GREEN: u32 = 65280;
pub const NV097_SET_FOG_COLOR_BLUE: u32 = 16711680;
pub const NV097_SET_FOG_COLOR_ALPHA: u32 = 4278190080;
pub const NV097_SET_ALPHA_TEST_ENABLE: u32 = 768;
pub const NV097_SET_BLEND_ENABLE: u32 = 772;
pub const NV097_SET_CULL_FACE_ENABLE: u32 = 776;
pub const NV097_SET_DEPTH_TEST_ENABLE: u32 = 780;
pub const NV097_SET_DITHER_ENABLE: u32 = 784;
pub const NV097_SET_LIGHTING_ENABLE: u32 = 788;
pub const NV097_SET_SKIN_MODE: u32 = 808;
pub const NV097_SET_SKIN_MODE_OFF: u32 = 0;
pub const NV097_SET_SKIN_MODE_2G: u32 = 1;
pub const NV097_SET_SKIN_MODE_2: u32 = 2;
pub const NV097_SET_SKIN_MODE_3G: u32 = 3;
pub const NV097_SET_SKIN_MODE_3: u32 = 4;
pub const NV097_SET_SKIN_MODE_4G: u32 = 5;
pub const NV097_SET_SKIN_MODE_4: u32 = 6;
pub const NV097_SET_STENCIL_TEST_ENABLE: u32 = 812;
pub const NV097_SET_POLY_OFFSET_POINT_ENABLE: u32 = 816;
pub const NV097_SET_POLY_OFFSET_LINE_ENABLE: u32 = 820;
pub const NV097_SET_POLY_OFFSET_FILL_ENABLE: u32 = 824;
pub const NV097_SET_ALPHA_FUNC: u32 = 828;
pub const NV097_SET_ALPHA_REF: u32 = 832;
pub const NV097_SET_BLEND_FUNC_SFACTOR: u32 = 836;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ZERO: u32 = 0;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE: u32 = 1;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR: u32 = 768;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR: u32 = 769;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA: u32 = 770;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA: u32 = 771;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA: u32 = 772;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA: u32 = 773;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR: u32 = 774;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR: u32 = 775;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE: u32 = 776;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR: u32 = 32769;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR: u32 = 32770;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA: u32 = 32771;
pub const NV097_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA: u32 = 32772;
pub const NV097_SET_BLEND_FUNC_DFACTOR: u32 = 840;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO: u32 = 0;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE: u32 = 1;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR: u32 = 768;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR: u32 = 769;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA: u32 = 770;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA: u32 = 771;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA: u32 = 772;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA: u32 = 773;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR: u32 = 774;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR: u32 = 775;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_SATURATE: u32 = 776;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR: u32 = 32769;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR: u32 = 32770;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA: u32 = 32771;
pub const NV097_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA: u32 = 32772;
pub const NV097_SET_BLEND_COLOR: u32 = 844;
pub const NV097_SET_BLEND_EQUATION: u32 = 848;
pub const NV097_SET_BLEND_EQUATION_V_FUNC_SUBTRACT: u32 = 32778;
pub const NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT: u32 = 32779;
pub const NV097_SET_BLEND_EQUATION_V_FUNC_ADD: u32 = 32774;
pub const NV097_SET_BLEND_EQUATION_V_MIN: u32 = 32775;
pub const NV097_SET_BLEND_EQUATION_V_MAX: u32 = 32776;
pub const NV097_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_SIGNED: u32 = 61445;
pub const NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED: u32 = 61446;
pub const NV097_SET_DEPTH_FUNC: u32 = 852;
pub const NV097_SET_COLOR_MASK: u32 = 856;
pub const NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE: u32 = 1;
pub const NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE: u32 = 256;
pub const NV097_SET_COLOR_MASK_RED_WRITE_ENABLE: u32 = 65536;
pub const NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE: u32 = 16777216;
pub const NV097_SET_DEPTH_MASK: u32 = 860;
pub const NV097_SET_STENCIL_MASK: u32 = 864;
pub const NV097_SET_STENCIL_FUNC: u32 = 868;
pub const NV097_SET_STENCIL_FUNC_REF: u32 = 872;
pub const NV097_SET_STENCIL_FUNC_MASK: u32 = 876;
pub const NV097_SET_STENCIL_OP_FAIL: u32 = 880;
pub const NV097_SET_STENCIL_OP_ZFAIL: u32 = 884;
pub const NV097_SET_STENCIL_OP_ZPASS: u32 = 888;
pub const NV097_SET_STENCIL_OP_V_KEEP: u32 = 7680;
pub const NV097_SET_STENCIL_OP_V_ZERO: u32 = 0;
pub const NV097_SET_STENCIL_OP_V_REPLACE: u32 = 7681;
pub const NV097_SET_STENCIL_OP_V_INCRSAT: u32 = 7682;
pub const NV097_SET_STENCIL_OP_V_DECRSAT: u32 = 7683;
pub const NV097_SET_STENCIL_OP_V_INVERT: u32 = 5386;
pub const NV097_SET_STENCIL_OP_V_INCR: u32 = 34055;
pub const NV097_SET_STENCIL_OP_V_DECR: u32 = 34056;
pub const NV097_SET_POLYGON_OFFSET_SCALE_FACTOR: u32 = 900;
pub const NV097_SET_POLYGON_OFFSET_BIAS: u32 = 904;
pub const NV097_SET_FRONT_POLYGON_MODE: u32 = 908;
pub const NV097_SET_FRONT_POLYGON_MODE_V_POINT: u32 = 6912;
pub const NV097_SET_FRONT_POLYGON_MODE_V_LINE: u32 = 6913;
pub const NV097_SET_FRONT_POLYGON_MODE_V_FILL: u32 = 6914;
pub const NV097_SET_BACK_POLYGON_MODE: u32 = 912;
pub const NV097_SET_CLIP_MIN: u32 = 916;
pub const NV097_SET_CLIP_MAX: u32 = 920;
pub const NV097_SET_CULL_FACE: u32 = 924;
pub const NV097_SET_CULL_FACE_V_FRONT: u32 = 1028;
pub const NV097_SET_CULL_FACE_V_BACK: u32 = 1029;
pub const NV097_SET_CULL_FACE_V_FRONT_AND_BACK: u32 = 1032;
pub const NV097_SET_FRONT_FACE: u32 = 928;
pub const NV097_SET_FRONT_FACE_V_CW: u32 = 2304;
pub const NV097_SET_FRONT_FACE_V_CCW: u32 = 2305;
pub const NV097_SET_NORMALIZATION_ENABLE: u32 = 932;
pub const NV097_SET_LIGHT_ENABLE_MASK: u32 = 956;
pub const NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF: u32 = 0;
pub const NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE: u32 = 1;
pub const NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL: u32 = 2;
pub const NV097_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT: u32 = 3;
pub const NV097_SET_TEXGEN_S: u32 = 960;
pub const NV097_SET_TEXGEN_S_DISABLE: u32 = 0;
pub const NV097_SET_TEXGEN_S_EYE_LINEAR: u32 = 9216;
pub const NV097_SET_TEXGEN_S_OBJECT_LINEAR: u32 = 9217;
pub const NV097_SET_TEXGEN_S_SPHERE_MAP: u32 = 9218;
pub const NV097_SET_TEXGEN_S_REFLECTION_MAP: u32 = 34066;
pub const NV097_SET_TEXGEN_S_NORMAL_MAP: u32 = 34065;
pub const NV097_SET_TEXGEN_T: u32 = 964;
pub const NV097_SET_TEXGEN_R: u32 = 968;
pub const NV097_SET_TEXGEN_Q: u32 = 972;
pub const NV097_SET_TEXTURE_MATRIX_ENABLE: u32 = 1056;
pub const NV097_SET_PROJECTION_MATRIX: u32 = 1088;
pub const NV097_SET_MODEL_VIEW_MATRIX: u32 = 1152;
pub const NV097_SET_INVERSE_MODEL_VIEW_MATRIX: u32 = 1408;
pub const NV097_SET_COMPOSITE_MATRIX: u32 = 1664;
pub const NV097_SET_TEXTURE_MATRIX: u32 = 1728;
pub const NV097_SET_FOG_PARAMS: u32 = 2496;
pub const NV097_SET_TEXGEN_PLANE_S: u32 = 2112;
pub const NV097_SET_TEXGEN_PLANE_T: u32 = 2128;
pub const NV097_SET_TEXGEN_PLANE_R: u32 = 2144;
pub const NV097_SET_TEXGEN_PLANE_Q: u32 = 2160;
pub const NV097_SET_TEXGEN_VIEW_MODEL: u32 = 2508;
pub const NV097_SET_TEXGEN_VIEW_MODEL_LOCAL_VIEWER: u32 = 0;
pub const NV097_SET_TEXGEN_VIEW_MODEL_INFINITE_VIEWER: u32 = 1;
pub const NV097_SET_FOG_PLANE: u32 = 2512;
pub const NV097_SET_FLAT_SHADE_OP: u32 = 2556;
pub const NV097_SET_SCENE_AMBIENT_COLOR: u32 = 2576;
pub const NV097_SET_VIEWPORT_OFFSET: u32 = 2592;
pub const NV097_SET_EYE_POSITION: u32 = 2640;
pub const NV097_SET_COMBINER_FACTOR0: u32 = 2656;
pub const NV097_SET_COMBINER_FACTOR1: u32 = 2688;
pub const NV097_SET_COMBINER_ALPHA_OCW: u32 = 2720;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP: u32 = 4294934528;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_NOSHIFT: u32 = 0;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_NOSHIFT_BIAS: u32 = 1;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_SHIFTLEFTBY1: u32 = 2;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_SHIFTLEFTBY1_BIAS: u32 = 3;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_SHIFTLEFTBY2: u32 = 4;
pub const NV097_SET_COMBINER_ALPHA_OCW_OP_SHIFTRIGHTBY1: u32 = 6;
pub const NV097_SET_COMBINER_ALPHA_OCW_MUX_ENABLE: u32 = 16384;
pub const NV097_SET_COMBINER_ALPHA_OCW_SUM_DST: u32 = 3840;
pub const NV097_SET_COMBINER_ALPHA_OCW_AB_DST: u32 = 240;
pub const NV097_SET_COMBINER_ALPHA_OCW_CD_DST: u32 = 15;
pub const NV097_SET_COMBINER_COLOR_ICW: u32 = 2752;
pub const NV097_SET_COMBINER_COLOR_ICW_A_MAP: u32 = 3758096384;
pub const NV097_SET_COMBINER_COLOR_ICW_A_ALPHA: u32 = 268435456;
pub const NV097_SET_COMBINER_COLOR_ICW_A_SOURCE: u32 = 251658240;
pub const NV097_SET_COMBINER_COLOR_ICW_B_MAP: u32 = 14680064;
pub const NV097_SET_COMBINER_COLOR_ICW_B_ALPHA: u32 = 1048576;
pub const NV097_SET_COMBINER_COLOR_ICW_B_SOURCE: u32 = 983040;
pub const NV097_SET_COMBINER_COLOR_ICW_C_MAP: u32 = 57344;
pub const NV097_SET_COMBINER_COLOR_ICW_C_ALPHA: u32 = 4096;
pub const NV097_SET_COMBINER_COLOR_ICW_C_SOURCE: u32 = 3840;
pub const NV097_SET_COMBINER_COLOR_ICW_D_MAP: u32 = 224;
pub const NV097_SET_COMBINER_COLOR_ICW_D_ALPHA: u32 = 16;
pub const NV097_SET_COMBINER_COLOR_ICW_D_SOURCE: u32 = 15;
pub const NV097_SET_VIEWPORT_SCALE: u32 = 2800;
pub const NV097_SET_TRANSFORM_PROGRAM: u32 = 2816;
pub const NV097_SET_TRANSFORM_CONSTANT: u32 = 2944;
pub const NV097_SET_VERTEX3F: u32 = 5376;
pub const NV097_SET_BACK_LIGHT_AMBIENT_COLOR: u32 = 3072;
pub const NV097_SET_BACK_LIGHT_DIFFUSE_COLOR: u32 = 3084;
pub const NV097_SET_BACK_LIGHT_SPECULAR_COLOR: u32 = 3096;
pub const NV097_SET_LIGHT_AMBIENT_COLOR: u32 = 4096;
pub const NV097_SET_LIGHT_DIFFUSE_COLOR: u32 = 4108;
pub const NV097_SET_LIGHT_SPECULAR_COLOR: u32 = 4120;
pub const NV097_SET_LIGHT_LOCAL_RANGE: u32 = 4132;
pub const NV097_SET_LIGHT_INFINITE_HALF_VECTOR: u32 = 4136;
pub const NV097_SET_LIGHT_INFINITE_DIRECTION: u32 = 4148;
pub const NV097_SET_LIGHT_SPOT_FALLOFF: u32 = 4160;
pub const NV097_SET_LIGHT_SPOT_DIRECTION: u32 = 4172;
pub const NV097_SET_LIGHT_LOCAL_POSITION: u32 = 4188;
pub const NV097_SET_LIGHT_LOCAL_ATTENUATION: u32 = 4200;
pub const NV097_SET_VERTEX4F: u32 = 5400;
pub const NV097_SET_VERTEX_DATA_ARRAY_OFFSET: u32 = 5920;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT: u32 = 5984;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE: u32 = 15;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_D3D: u32 = 0;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S1: u32 = 1;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_F: u32 = 2;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_UB_OGL: u32 = 4;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K: u32 = 5;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_CMP: u32 = 6;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE: u32 = 240;
pub const NV097_SET_VERTEX_DATA_ARRAY_FORMAT_STRIDE: u32 = 4294967040;
pub const NV097_SET_LOGIC_OP_ENABLE: u32 = 6076;
pub const NV097_SET_LOGIC_OP: u32 = 6080;
pub const NV097_CLEAR_REPORT_VALUE: u32 = 6088;
pub const NV097_CLEAR_REPORT_VALUE_TYPE: u32 = 4294967295;
pub const NV097_CLEAR_REPORT_VALUE_TYPE_ZPASS_PIXEL_CNT: u32 = 1;
pub const NV097_SET_ZPASS_PIXEL_COUNT_ENABLE: u32 = 6092;
pub const NV097_GET_REPORT: u32 = 6096;
pub const NV097_GET_REPORT_OFFSET: u32 = 16777215;
pub const NV097_GET_REPORT_TYPE: u32 = 4278190080;
pub const NV097_GET_REPORT_TYPE_ZPASS_PIXEL_CNT: u32 = 1;
pub const NV097_SET_EYE_DIRECTION: u32 = 6112;
pub const NV097_SET_SHADER_CLIP_PLANE_MODE: u32 = 6136;
pub const NV097_SET_BEGIN_END: u32 = 6140;
pub const NV097_SET_BEGIN_END_OP_END: u32 = 0;
pub const NV097_SET_BEGIN_END_OP_POINTS: u32 = 1;
pub const NV097_SET_BEGIN_END_OP_LINES: u32 = 2;
pub const NV097_SET_BEGIN_END_OP_LINE_LOOP: u32 = 3;
pub const NV097_SET_BEGIN_END_OP_LINE_STRIP: u32 = 4;
pub const NV097_SET_BEGIN_END_OP_TRIANGLES: u32 = 5;
pub const NV097_SET_BEGIN_END_OP_TRIANGLE_STRIP: u32 = 6;
pub const NV097_SET_BEGIN_END_OP_TRIANGLE_FAN: u32 = 7;
pub const NV097_SET_BEGIN_END_OP_QUADS: u32 = 8;
pub const NV097_SET_BEGIN_END_OP_QUAD_STRIP: u32 = 9;
pub const NV097_SET_BEGIN_END_OP_POLYGON: u32 = 10;
pub const NV097_ARRAY_ELEMENT16: u32 = 6144;
pub const NV097_ARRAY_ELEMENT32: u32 = 6152;
pub const NV097_DRAW_ARRAYS: u32 = 6160;
pub const NV097_DRAW_ARRAYS_COUNT: u32 = 4278190080;
pub const NV097_DRAW_ARRAYS_START_INDEX: u32 = 16777215;
pub const NV097_INLINE_ARRAY: u32 = 6168;
pub const NV097_SET_EYE_VECTOR: u32 = 6172;
pub const NV097_SET_VERTEX_DATA2F_M: u32 = 6272;
pub const NV097_SET_VERTEX_DATA4F_M: u32 = 6656;
pub const NV097_SET_VERTEX_DATA2S: u32 = 6400;
pub const NV097_SET_VERTEX_DATA4UB: u32 = 6464;
pub const NV097_SET_VERTEX_DATA4S_M: u32 = 6528;
pub const NV097_SET_TEXTURE_OFFSET: u32 = 6912;
pub const NV097_SET_TEXTURE_FORMAT: u32 = 6916;
pub const NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA: u32 = 3;
pub const NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE: u32 = 4;
pub const NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE: u32 = 8;
pub const NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_TEXTURE: u32 = 0;
pub const NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR: u32 = 1;
pub const NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY: u32 = 240;
pub const NV097_SET_TEXTURE_FORMAT_COLOR: u32 = 65280;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_Y8: u32 = 0;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_AY8: u32 = 1;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A1R5G5B5: u32 = 2;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X1R5G5B5: u32 = 3;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A4R4G4B4: u32 = 4;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R5G6B5: u32 = 5;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8R8G8B8: u32 = 6;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_X8R8G8B8: u32 = 7;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_I8_A8R8G8B8: u32 = 11;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT1_A1R5G5B5: u32 = 12;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT23_A8R8G8B8: u32 = 14;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_L_DXT45_A8R8G8B8: u32 = 15;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A1R5G5B5: u32 = 16;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R5G6B5: u32 = 17;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8: u32 = 18;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y8: u32 = 19;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8: u32 = 25;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8Y8: u32 = 26;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_AY8: u32 = 27;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X1R5G5B5: u32 = 28;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A4R4G4B4: u32 = 29;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_X8R8G8B8: u32 = 30;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8: u32 = 31;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8Y8: u32 = 32;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LC_IMAGE_CR8YB8CB8YA8: u32 = 36;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R6G5B5: u32 = 39;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_G8B8: u32 = 40;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8B8: u32 = 41;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_X8_Y24_FIXED: u32 = 46;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_DEPTH_Y16_FIXED: u32 = 48;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_Y16: u32 = 53;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_A8B8G8R8: u32 = 58;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_SZ_R8G8B8A8: u32 = 60;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8B8G8R8: u32 = 63;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_B8G8R8A8: u32 = 64;
pub const NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_R8G8B8A8: u32 = 65;
pub const NV097_SET_TEXTURE_FORMAT_MIPMAP_LEVELS: u32 = 983040;
pub const NV097_SET_TEXTURE_FORMAT_BASE_SIZE_U: u32 = 15728640;
pub const NV097_SET_TEXTURE_FORMAT_BASE_SIZE_V: u32 = 251658240;
pub const NV097_SET_TEXTURE_FORMAT_BASE_SIZE_P: u32 = 4026531840;
pub const NV097_SET_TEXTURE_ADDRESS: u32 = 6920;
pub const NV097_SET_TEXTURE_CONTROL0: u32 = 6924;
pub const NV097_SET_TEXTURE_CONTROL0_ENABLE: u32 = 1073741824;
pub const NV097_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP: u32 = 1073479680;
pub const NV097_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP: u32 = 262080;
pub const NV097_SET_TEXTURE_CONTROL1: u32 = 6928;
pub const NV097_SET_TEXTURE_CONTROL1_IMAGE_PITCH: u32 = 4294901760;
pub const NV097_SET_TEXTURE_FILTER: u32 = 6932;
pub const NV097_SET_TEXTURE_FILTER_MIPMAP_LOD_BIAS: u32 = 8191;
pub const NV097_SET_TEXTURE_FILTER_MIN: u32 = 16711680;
pub const NV097_SET_TEXTURE_FILTER_MAG: u32 = 251658240;
pub const NV097_SET_TEXTURE_FILTER_ASIGNED: u32 = 268435456;
pub const NV097_SET_TEXTURE_FILTER_RSIGNED: u32 = 536870912;
pub const NV097_SET_TEXTURE_FILTER_GSIGNED: u32 = 1073741824;
pub const NV097_SET_TEXTURE_FILTER_BSIGNED: u32 = 2147483648;
pub const NV097_SET_TEXTURE_IMAGE_RECT: u32 = 6940;
pub const NV097_SET_TEXTURE_IMAGE_RECT_WIDTH: u32 = 4294901760;
pub const NV097_SET_TEXTURE_IMAGE_RECT_HEIGHT: u32 = 65535;
pub const NV097_SET_TEXTURE_PALETTE: u32 = 6944;
pub const NV097_SET_TEXTURE_PALETTE_CONTEXT_DMA: u32 = 1;
pub const NV097_SET_TEXTURE_PALETTE_LENGTH: u32 = 12;
pub const NV097_SET_TEXTURE_PALETTE_LENGTH_256: u32 = 0;
pub const NV097_SET_TEXTURE_PALETTE_LENGTH_128: u32 = 1;
pub const NV097_SET_TEXTURE_PALETTE_LENGTH_64: u32 = 2;
pub const NV097_SET_TEXTURE_PALETTE_LENGTH_32: u32 = 3;
pub const NV097_SET_TEXTURE_PALETTE_OFFSET: u32 = 4294967232;
pub const NV097_SET_TEXTURE_BORDER_COLOR: u32 = 6948;
pub const NV097_SET_TEXTURE_SET_BUMP_ENV_MAT: u32 = 6952;
pub const NV097_SET_TEXTURE_SET_BUMP_ENV_SCALE: u32 = 6968;
pub const NV097_SET_TEXTURE_SET_BUMP_ENV_OFFSET: u32 = 6972;
pub const NV097_SET_SEMAPHORE_OFFSET: u32 = 7532;
pub const NV097_BACK_END_WRITE_SEMAPHORE_RELEASE: u32 = 7536;
pub const NV097_SET_ZMIN_MAX_CONTROL: u32 = 7544;
pub const NV097_SET_COMPRESS_ZBUFFER_EN: u32 = 7552;
pub const NV097_SET_ZSTENCIL_CLEAR_VALUE: u32 = 7564;
pub const NV097_SET_COLOR_CLEAR_VALUE: u32 = 7568;
pub const NV097_CLEAR_SURFACE: u32 = 7572;
pub const NV097_CLEAR_SURFACE_Z: u32 = 1;
pub const NV097_CLEAR_SURFACE_STENCIL: u32 = 2;
pub const NV097_CLEAR_SURFACE_COLOR: u32 = 240;
pub const NV097_CLEAR_SURFACE_R: u32 = 16;
pub const NV097_CLEAR_SURFACE_G: u32 = 32;
pub const NV097_CLEAR_SURFACE_B: u32 = 64;
pub const NV097_CLEAR_SURFACE_A: u32 = 128;
pub const NV097_SET_CLEAR_RECT_HORIZONTAL: u32 = 7576;
pub const NV097_SET_CLEAR_RECT_VERTICAL: u32 = 7580;
pub const NV097_SET_SPECULAR_FOG_FACTOR: u32 = 7712;
pub const NV097_SET_COMBINER_COLOR_OCW: u32 = 7744;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB: u32 = 4294443008;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_DISABLE: u32 = 0;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_AB_AB_DST_ENABLE: u32 = 1;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD: u32 = 262144;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_DISABLE: u32 = 0;
pub const NV097_SET_COMBINER_COLOR_OCW_BLUETOALPHA_CD_CD_DST_ENABLE: u32 = 1;
pub const NV097_SET_COMBINER_COLOR_OCW_OP: u32 = 229376;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT: u32 = 0;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_NOSHIFT_BIAS: u32 = 1;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1: u32 = 2;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY1_BIAS: u32 = 3;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTLEFTBY2: u32 = 4;
pub const NV097_SET_COMBINER_COLOR_OCW_OP_SHIFTRIGHTBY1: u32 = 6;
pub const NV097_SET_COMBINER_COLOR_OCW_MUX_ENABLE: u32 = 16384;
pub const NV097_SET_COMBINER_COLOR_OCW_AB_DOT_ENABLE: u32 = 8192;
pub const NV097_SET_COMBINER_COLOR_OCW_CD_DOT_ENABLE: u32 = 4096;
pub const NV097_SET_COMBINER_COLOR_OCW_SUM_DST: u32 = 3840;
pub const NV097_SET_COMBINER_COLOR_OCW_AB_DST: u32 = 240;
pub const NV097_SET_COMBINER_COLOR_OCW_CD_DST: u32 = 15;
pub const NV097_SET_COMBINER_CONTROL: u32 = 7776;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT: u32 = 255;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE: u32 = 1;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_TWO: u32 = 2;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_THREE: u32 = 3;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FOUR: u32 = 4;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_FIVE: u32 = 5;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SIX: u32 = 6;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_SEVEN: u32 = 7;
pub const NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_EIGHT: u32 = 8;
pub const NV097_SET_COMBINER_CONTROL_MUX_SELECT: u32 = 3840;
pub const NV097_SET_COMBINER_CONTROL_MUX_SELECT_LSB: u32 = 0;
pub const NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB: u32 = 1;
pub const NV097_SET_COMBINER_CONTROL_FACTOR0: u32 = 61440;
pub const NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL: u32 = 0;
pub const NV097_SET_COMBINER_CONTROL_FACTOR0_EACH_STAGE: u32 = 1;
pub const NV097_SET_COMBINER_CONTROL_FACTOR1: u32 = 4294901760;
pub const NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL: u32 = 0;
pub const NV097_SET_COMBINER_CONTROL_FACTOR1_EACH_STAGE: u32 = 1;
pub const NV097_SET_SHADOW_ZSLOPE_THRESHOLD: u32 = 7784;
pub const NV097_SET_SHADER_STAGE_PROGRAM: u32 = 7792;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0: u32 = 31;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PROGRAM_NONE: u32 = 0;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE: u32 = 1;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_3D_PROJECTIVE: u32 = 2;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CUBE_MAP: u32 = 3;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_PASS_THROUGH: u32 = 4;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_CLIP_PLANE: u32 = 5;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1: u32 = 992;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PROGRAM_NONE: u32 = 0;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE: u32 = 1;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_3D_PROJECTIVE: u32 = 2;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CUBE_MAP: u32 = 3;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_PASS_THROUGH: u32 = 4;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_CLIP_PLANE: u32 = 5;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP: u32 = 6;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_BUMPENVMAP_LUMINANCE: u32 = 7;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_AR: u32 = 15;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DEPENDENT_GB: u32 = 16;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_DOT_PRODUCT: u32 = 17;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2: u32 = 31744;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE: u32 = 0;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_2D_PROJECTIVE: u32 = 1;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_3D_PROJECTIVE: u32 = 2;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CUBE_MAP: u32 = 3;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PASS_THROUGH: u32 = 4;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_CLIP_PLANE: u32 = 5;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP: u32 = 6;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BUMPENVMAP_LUMINANCE: u32 = 7;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_BRDF: u32 = 8;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ST: u32 = 9;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_ZW: u32 = 10;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_REFLECT_DIFFUSE: u32 = 11;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_AR: u32 = 15;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DEPENDENT_GB: u32 = 16;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_DOT_PRODUCT: u32 = 17;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3: u32 = 1015808;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE: u32 = 0;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_2D_PROJECTIVE: u32 = 1;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_3D_PROJECTIVE: u32 = 2;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CUBE_MAP: u32 = 3;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PASS_THROUGH: u32 = 4;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_CLIP_PLANE: u32 = 5;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP: u32 = 6;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BUMPENVMAP_LUMINANCE: u32 = 7;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_BRDF: u32 = 8;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ST: u32 = 9;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_ZW: u32 = 10;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR: u32 = 12;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_3D: u32 = 13;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_STR_CUBE: u32 = 14;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_AR: u32 = 15;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DEPENDENT_GB: u32 = 16;
pub const NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_DOT_REFLECT_SPECULAR_CONST: u32 = 18;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT: u32 = 7800;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1: u32 = 65535;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE1_INSTAGE_0: u32 = 0;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2: u32 = 983040;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_0: u32 = 0;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE2_INSTAGE_1: u32 = 1;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3: u32 = 15728640;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_0: u32 = 0;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_1: u32 = 1;
pub const NV097_SET_SHADER_OTHER_STAGE_INPUT_STAGE3_INSTAGE_2: u32 = 2;
pub const NV097_SET_TRANSFORM_DATA: u32 = 7808;
pub const NV097_LAUNCH_TRANSFORM_PROGRAM: u32 = 7824;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE: u32 = 7828;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_MODE: u32 = 3;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED: u32 = 0;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_PROGRAM: u32 = 2;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE: u32 = 4294967292;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_USER: u32 = 0;
pub const NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV: u32 = 1;
pub const NV097_SET_TRANSFORM_PROGRAM_CXT_WRITE_EN: u32 = 7832;
pub const NV097_SET_TRANSFORM_PROGRAM_LOAD: u32 = 7836;
pub const NV097_SET_TRANSFORM_PROGRAM_START: u32 = 7840;
pub const NV097_SET_TRANSFORM_CONSTANT_LOAD: u32 = 7844;
pub const _11: u32 = 0;
pub const _12: u32 = 1;
pub const _13: u32 = 2;
pub const _14: u32 = 3;
pub const _21: u32 = 4;
pub const _22: u32 = 5;
pub const _23: u32 = 6;
pub const _24: u32 = 7;
pub const _31: u32 = 8;
pub const _32: u32 = 9;
pub const _33: u32 = 10;
pub const _34: u32 = 11;
pub const _41: u32 = 12;
pub const _42: u32 = 13;
pub const _43: u32 = 14;
pub const _44: u32 = 15;
pub const SUBCH_3D: u32 = 0;
pub const SUBCH_2: u32 = 2;
pub const SUBCH_3: u32 = 3;
pub const SUBCH_4: u32 = 4;
pub type LPCVOID = *const libc::c_void;
pub type VOID = libc::c_void;
pub type PVOID = *mut libc::c_void;
pub type LPVOID = *mut libc::c_void;
pub type HANDLE = PVOID;
pub type PHANDLE = *mut PVOID;
pub type BOOLEAN = libc::c_uchar;
pub type PBOOLEAN = *mut libc::c_uchar;
pub type SCHAR = libc::c_schar;
pub type PSCHAR = *mut libc::c_schar;
pub type CHAR = libc::c_char;
pub type PCHAR = *mut libc::c_char;
pub type CCHAR = libc::c_char;
pub type LPCH = *mut libc::c_char;
pub type PCH = *mut libc::c_char;
pub type OCHAR = libc::c_char;
pub type POCHAR = *mut libc::c_char;
pub type SHORT = libc::c_short;
pub type PSHORT = *mut libc::c_short;
pub type INT = libc::c_int;
pub type PINT = *mut libc::c_int;
pub type LPINT = *mut libc::c_int;
pub type LONG = libc::c_long;
pub type PLONG = *mut libc::c_long;
pub type LPLONG = *mut libc::c_long;
pub type LONGLONG = libc::c_longlong;
pub type PLONGLONG = *mut libc::c_longlong;
pub type BYTE = libc::c_uchar;
pub type UCHAR = libc::c_uchar;
pub type PUCHAR = *mut libc::c_uchar;
pub type USHORT = libc::c_ushort;
pub type PUSHORT = *mut libc::c_ushort;
pub type CSHORT = libc::c_ushort;
pub type WORD = libc::c_ushort;
pub type WCHAR = libc::c_ushort;
pub type PWSTR = *mut libc::c_ushort;
pub type UINT = libc::c_uint;
pub type PUINT = *mut libc::c_uint;
pub type LPUINT = *mut libc::c_uint;
pub type DWORD = libc::c_ulong;
pub type PDWORD = *mut libc::c_ulong;
pub type LPDWORD = *mut libc::c_ulong;
pub type ULONG = libc::c_ulong;
pub type PULONG = *mut libc::c_ulong;
pub type ULONGLONG = libc::c_ulonglong;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
pub type SIZE_T = libc::c_uint;
pub type PSIZE_T = *mut libc::c_uint;
pub type BOOL = libc::c_int;
pub type PBOOL = *mut libc::c_int;
pub type PCSZ = *const libc::c_char;
pub type PCSTR = *const libc::c_char;
pub type LPCSTR = *const libc::c_char;
pub type QUAD = ULONGLONG;
pub type ULONG_PTR = ULONG;
pub type LONG_PTR = LONG;
pub type DWORD_PTR = ULONG_PTR;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOATING_SAVE_AREA {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: WORD,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub MXCsr: DWORD,
    pub Reserved2: DWORD,
    pub RegisterArea: [BYTE; 128usize],
    pub XmmRegisterArea: [BYTE; 128usize],
    pub Reserved4: [BYTE; 224usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__FLOATING_SAVE_AREA() {
    const UNINIT: ::core::mem::MaybeUninit<_FLOATING_SAVE_AREA> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FLOATING_SAVE_AREA>(),
        516usize,
        concat!("Size of: ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::core::mem::align_of::<_FLOATING_SAVE_AREA>(),
        1usize,
        concat!("Alignment of ", stringify!(_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TagWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOpcode) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MXCsr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(MXCsr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved2) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegisterArea) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).XmmRegisterArea) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(XmmRegisterArea)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved4) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type FLOATING_SAVE_AREA = _FLOATING_SAVE_AREA;
pub type PFLOATING_SAVE_AREA = *mut _FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT {
    pub ContextFlags: DWORD,
    pub FloatSave: FLOATING_SAVE_AREA,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_CONTEXT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_CONTEXT>(),
        568usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FloatSave) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edi) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esi) as usize - ptr as usize },
        524usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebx) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Edx) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ecx) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eax) as usize - ptr as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ebp) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Eip) as usize - ptr as usize },
        548usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegCs) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EFlags) as usize - ptr as usize },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Esp) as usize - ptr as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegSs) as usize - ptr as usize },
        564usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: NTSTATUS,
    pub ExceptionFlags: ULONG,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: ULONG,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    const UNINIT: ::core::mem::MaybeUninit<_EXCEPTION_RECORD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EXCEPTION_RECORD>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::core::mem::align_of::<_EXCEPTION_RECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionCode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionFlags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionRecord) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberParameters) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExceptionInformation) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut _EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _STRING {
    pub Length: USHORT,
    pub MaximumLength: USHORT,
    pub Buffer: PCHAR,
}
#[test]
fn bindgen_test_layout__STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type STRING = _STRING;
pub type PSTRING = *mut _STRING;
pub type ANSI_STRING = STRING;
pub type PANSI_STRING = *mut STRING;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    #[doc = "< A signed 64-bit integer."]
    pub QuadPart: LONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_LARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type LARGE_INTEGER = _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit signed int on platforms that may not support\n them directly."]
pub type PLARGE_INTEGER = *mut _LARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    #[doc = "< An unsigned 64-bit integer."]
    pub QuadPart: ULONGLONG,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits. */ /**< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    #[doc = "< The low-order 32 bits."]
    pub LowPart: ULONG,
    #[doc = "< The high-order 32 bits."]
    pub HighPart: ULONG,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HighPart) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    const UNINIT: ::core::mem::MaybeUninit<_ULARGE_INTEGER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::core::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuadPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
#[doc = " MS's way to represent a 64-bit unsigned int on platforms that may not support\n them directly."]
pub type PULARGE_INTEGER = *mut _ULARGE_INTEGER;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    #[doc = "< Points to the next entry of the list or the header if there is no next entry"]
    pub Flink: *mut _LIST_ENTRY,
    #[doc = "< Points to the previous entry of the list or the header if there is no previous entry"]
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type LIST_ENTRY = _LIST_ENTRY;
#[doc = " Header or descriptor for an entry in a doubly linked list.\n Initialized by InitializeListHead, members shouldn't be updated manually."]
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub Synchronization: _RTL_CRITICAL_SECTION__bindgen_ty_1,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_CRITICAL_SECTION__bindgen_ty_1 {
    pub Event: _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1,
    pub RawEvent: [ULONG; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1 {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(WaitListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(Event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RawEvent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION__bindgen_ty_1),
            "::",
            stringify!(RawEvent)
        )
    );
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::core::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        28usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::core::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        4usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Synchronization) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(Synchronization)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
}
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[doc = " Struct for modelling critical sections in the XBOX-kernel"]
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBE_SECTION_HEADER {
    pub Flags: DWORD,
    pub VirtualAddress: DWORD,
    pub VirtualSize: DWORD,
    pub FileAddress: DWORD,
    pub FileSize: DWORD,
    pub SectionName: PCSZ,
    pub SectionReferenceCount: LONG,
    pub HeadReferenceCount: *mut WORD,
    pub TailReferenceCount: *mut WORD,
    pub CheckSum: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__XBE_SECTION_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_XBE_SECTION_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBE_SECTION_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualAddress) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(VirtualSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAddress) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionName) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectionReferenceCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(SectionReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadReferenceCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(HeadReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TailReferenceCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(TailReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CheckSum) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBE_SECTION_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
}
pub type XBE_SECTION_HEADER = _XBE_SECTION_HEADER;
pub type PXBE_SECTION_HEADER = *mut _XBE_SECTION_HEADER;
pub type PHYSICAL_ADDRESS = ULONG;
pub type PPHYSICAL_ADDRESS = *mut ULONG;
pub type KIRQL = UCHAR;
pub type PKIRQL = *mut UCHAR;
pub type PFN_COUNT = ULONG;
pub type PFN_NUMBER = ULONG;
pub type PPFN_NUMBER = *mut ULONG;
pub type KPRIORITY = LONG;
pub type DEVICE_TYPE = ULONG;
pub type LOGICAL = ULONG;
pub type PSZ = *mut libc::c_char;
pub type PSTR = *mut libc::c_char;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type ACCESS_MASK = ULONG;
pub type PACCESS_MASK = *mut ULONG;
pub type KPROCESSOR_MODE = CCHAR;
pub const _MODE_KernelMode: _MODE = 0;
pub const _MODE_UserMode: _MODE = 1;
pub const _MODE_MaximumMode: _MODE = 2;
pub type _MODE = libc::c_int;
pub use self::_MODE as MODE;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type OBJECT_STRING = STRING;
#[doc = " This struct defines a counted string used for ANSI-strings"]
pub type POBJECT_STRING = *mut STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNICODE_STRING {
    #[doc = "< Length in bytes of the string stored in the buffer"]
    pub Length: USHORT,
    #[doc = "< Length in bytes of the buffer"]
    pub MaximumLength: USHORT,
    #[doc = "< Pointer to the buffer used for the character-string"]
    pub Buffer: PWSTR,
}
#[test]
fn bindgen_test_layout__UNICODE_STRING() {
    const UNINIT: ::core::mem::MaybeUninit<_UNICODE_STRING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_UNICODE_STRING>(),
        8usize,
        concat!("Size of: ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        ::core::mem::align_of::<_UNICODE_STRING>(),
        4usize,
        concat!("Alignment of ", stringify!(_UNICODE_STRING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumLength) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(MaximumLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNICODE_STRING),
            "::",
            stringify!(Buffer)
        )
    );
}
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type UNICODE_STRING = _UNICODE_STRING;
#[doc = " This struct defines a counted string used for UNICODE-strings"]
pub type PUNICODE_STRING = *mut _UNICODE_STRING;
pub type PCUNICODE_STRING = *const UNICODE_STRING;
#[doc = " Time information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TIME_FIELDS {
    #[doc = "< Specifies a value from 1601 on"]
    pub Year: SHORT,
    #[doc = "< Specifies a value from 1 to 12"]
    pub Month: SHORT,
    #[doc = "< Specifies a value from 1 to 31"]
    pub Day: SHORT,
    #[doc = "< Specifies a value from 0 to 23"]
    pub Hour: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Minute: SHORT,
    #[doc = "< Specifies a value from 0 to 59"]
    pub Second: SHORT,
    #[doc = "< Specifies a value from 0 to 999"]
    pub Millisecond: SHORT,
    #[doc = "< Specifies a value from 0 to 6 (Sunday to Saturday)"]
    pub Weekday: SHORT,
}
#[test]
fn bindgen_test_layout__TIME_FIELDS() {
    const UNINIT: ::core::mem::MaybeUninit<_TIME_FIELDS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIME_FIELDS>(),
        16usize,
        concat!("Size of: ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIME_FIELDS>(),
        2usize,
        concat!("Alignment of ", stringify!(_TIME_FIELDS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Year) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Month) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Month)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Day) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Day)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hour) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Minute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Second) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Second)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Millisecond) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Millisecond)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Weekday) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIME_FIELDS),
            "::",
            stringify!(Weekday)
        )
    );
}
#[doc = " Time information"]
pub type TIME_FIELDS = _TIME_FIELDS;
#[doc = " Time information"]
pub type PTIME_FIELDS = *mut _TIME_FIELDS;
pub const _WAIT_TYPE_WaitAll: _WAIT_TYPE = 0;
pub const _WAIT_TYPE_WaitAny: _WAIT_TYPE = 1;
pub type _WAIT_TYPE = libc::c_int;
pub use self::_WAIT_TYPE as WAIT_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_STATUS_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
pub type IO_STATUS_BLOCK = _IO_STATUS_BLOCK;
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
pub const _FSINFOCLASS_FileFsVolumeInformation: _FSINFOCLASS = 1;
pub const _FSINFOCLASS_FileFsLabelInformation: _FSINFOCLASS = 2;
pub const _FSINFOCLASS_FileFsSizeInformation: _FSINFOCLASS = 3;
pub const _FSINFOCLASS_FileFsDeviceInformation: _FSINFOCLASS = 4;
pub const _FSINFOCLASS_FileFsAttributeInformation: _FSINFOCLASS = 5;
pub const _FSINFOCLASS_FileFsControlInformation: _FSINFOCLASS = 6;
pub const _FSINFOCLASS_FileFsFullSizeInformation: _FSINFOCLASS = 7;
pub const _FSINFOCLASS_FileFsObjectIdInformation: _FSINFOCLASS = 8;
pub const _FSINFOCLASS_FileFsMaximumInformation: _FSINFOCLASS = 9;
pub type _FSINFOCLASS = libc::c_int;
pub use self::_FSINFOCLASS as FS_INFORMATION_CLASS;
pub type PFS_INFORMATION_CLASS = *mut _FSINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_LABEL_INFORMATION {
    pub VolumeLabelLength: ULONG,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_LABEL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_LABEL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_LABEL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_LABEL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_LABEL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_LABEL_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_LABEL_INFORMATION = _FILE_FS_LABEL_INFORMATION;
pub type PFILE_FS_LABEL_INFORMATION = *mut _FILE_FS_LABEL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_VOLUME_INFORMATION {
    pub VolumeCreationTime: LARGE_INTEGER,
    pub VolumeSerialNumber: ULONG,
    pub VolumeLabelLength: ULONG,
    pub SupportsObjects: BOOLEAN,
    pub VolumeLabel: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_VOLUME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_VOLUME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_VOLUME_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_VOLUME_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_VOLUME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SupportsObjects) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(SupportsObjects)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_VOLUME_INFORMATION),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
pub type FILE_FS_VOLUME_INFORMATION = _FILE_FS_VOLUME_INFORMATION;
pub type PFILE_FS_VOLUME_INFORMATION = *mut _FILE_FS_VOLUME_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub AvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_SIZE_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailableAllocationUnits) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(AvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_SIZE_INFORMATION = _FILE_FS_SIZE_INFORMATION;
pub type PFILE_FS_SIZE_INFORMATION = *mut _FILE_FS_SIZE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FS_FULL_SIZE_INFORMATION {
    pub TotalAllocationUnits: LARGE_INTEGER,
    pub CallerAvailableAllocationUnits: LARGE_INTEGER,
    pub ActualAvailableAllocationUnits: LARGE_INTEGER,
    pub SectorsPerAllocationUnit: ULONG,
    pub BytesPerSector: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_FULL_SIZE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_FULL_SIZE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_FULL_SIZE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FS_FULL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalAllocationUnits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(TotalAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).CallerAvailableAllocationUnits) as usize - ptr as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(CallerAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ActualAvailableAllocationUnits) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(ActualAvailableAllocationUnits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_FULL_SIZE_INFORMATION),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type FILE_FS_FULL_SIZE_INFORMATION = _FILE_FS_FULL_SIZE_INFORMATION;
pub type PFILE_FS_FULL_SIZE_INFORMATION = *mut _FILE_FS_FULL_SIZE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_OBJECTID_INFORMATION {
    pub ObjectId: [UCHAR; 16usize],
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_OBJECTID_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_FS_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_OBJECTID_INFORMATION),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
pub type FILE_FS_OBJECTID_INFORMATION = _FILE_FS_OBJECTID_INFORMATION;
pub type PFILE_FS_OBJECTID_INFORMATION = *mut _FILE_FS_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_DEVICE_INFORMATION {
    pub DeviceType: DEVICE_TYPE,
    pub Characteristics: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_FS_DEVICE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_DEVICE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_DEVICE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_DEVICE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_DEVICE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Characteristics) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_DEVICE_INFORMATION),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type FILE_FS_DEVICE_INFORMATION = _FILE_FS_DEVICE_INFORMATION;
pub type PFILE_FS_DEVICE_INFORMATION = *mut _FILE_FS_DEVICE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FS_ATTRIBUTE_INFORMATION {
    pub FileSystemAttributes: ULONG,
    pub MaximumComponentNameLength: LONG,
    pub FileSystemNameLength: ULONG,
    pub FileSystemName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FS_ATTRIBUTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FS_ATTRIBUTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FS_ATTRIBUTE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FS_ATTRIBUTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumComponentNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(MaximumComponentNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FS_ATTRIBUTE_INFORMATION),
            "::",
            stringify!(FileSystemName)
        )
    );
}
pub type FILE_FS_ATTRIBUTE_INFORMATION = _FILE_FS_ATTRIBUTE_INFORMATION;
pub type PFILE_FS_ATTRIBUTE_INFORMATION = *mut _FILE_FS_ATTRIBUTE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MEMORY_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
        28usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BaseAddress) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationBase) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationProtect) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RegionSize) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Protect) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    const UNINIT: ::core::mem::MaybeUninit<_SID_IDENTIFIER_AUTHORITY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    #[doc = "< Actually has size 'SubAuthorityCount'"]
    pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    const UNINIT: ::core::mem::MaybeUninit<_SID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::core::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Revision) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthorityCount) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IdentifierAuthority) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SubAuthority) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthority)
        )
    );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
pub const _FILE_INFORMATION_CLASS_FileDirectoryInformation: _FILE_INFORMATION_CLASS = 1;
pub const _FILE_INFORMATION_CLASS_FileFullDirectoryInformation: _FILE_INFORMATION_CLASS = 2;
pub const _FILE_INFORMATION_CLASS_FileBothDirectoryInformation: _FILE_INFORMATION_CLASS = 3;
pub const _FILE_INFORMATION_CLASS_FileBasicInformation: _FILE_INFORMATION_CLASS = 4;
pub const _FILE_INFORMATION_CLASS_FileStandardInformation: _FILE_INFORMATION_CLASS = 5;
pub const _FILE_INFORMATION_CLASS_FileInternalInformation: _FILE_INFORMATION_CLASS = 6;
pub const _FILE_INFORMATION_CLASS_FileEaInformation: _FILE_INFORMATION_CLASS = 7;
pub const _FILE_INFORMATION_CLASS_FileAccessInformation: _FILE_INFORMATION_CLASS = 8;
pub const _FILE_INFORMATION_CLASS_FileNameInformation: _FILE_INFORMATION_CLASS = 9;
pub const _FILE_INFORMATION_CLASS_FileRenameInformation: _FILE_INFORMATION_CLASS = 10;
pub const _FILE_INFORMATION_CLASS_FileLinkInformation: _FILE_INFORMATION_CLASS = 11;
pub const _FILE_INFORMATION_CLASS_FileNamesInformation: _FILE_INFORMATION_CLASS = 12;
pub const _FILE_INFORMATION_CLASS_FileDispositionInformation: _FILE_INFORMATION_CLASS = 13;
pub const _FILE_INFORMATION_CLASS_FilePositionInformation: _FILE_INFORMATION_CLASS = 14;
pub const _FILE_INFORMATION_CLASS_FileFullEaInformation: _FILE_INFORMATION_CLASS = 15;
pub const _FILE_INFORMATION_CLASS_FileModeInformation: _FILE_INFORMATION_CLASS = 16;
pub const _FILE_INFORMATION_CLASS_FileAlignmentInformation: _FILE_INFORMATION_CLASS = 17;
pub const _FILE_INFORMATION_CLASS_FileAllInformation: _FILE_INFORMATION_CLASS = 18;
pub const _FILE_INFORMATION_CLASS_FileAllocationInformation: _FILE_INFORMATION_CLASS = 19;
pub const _FILE_INFORMATION_CLASS_FileEndOfFileInformation: _FILE_INFORMATION_CLASS = 20;
pub const _FILE_INFORMATION_CLASS_FileAlternateNameInformation: _FILE_INFORMATION_CLASS = 21;
pub const _FILE_INFORMATION_CLASS_FileStreamInformation: _FILE_INFORMATION_CLASS = 22;
pub const _FILE_INFORMATION_CLASS_FilePipeInformation: _FILE_INFORMATION_CLASS = 23;
pub const _FILE_INFORMATION_CLASS_FilePipeLocalInformation: _FILE_INFORMATION_CLASS = 24;
pub const _FILE_INFORMATION_CLASS_FilePipeRemoteInformation: _FILE_INFORMATION_CLASS = 25;
pub const _FILE_INFORMATION_CLASS_FileMailslotQueryInformation: _FILE_INFORMATION_CLASS = 26;
pub const _FILE_INFORMATION_CLASS_FileMailslotSetInformation: _FILE_INFORMATION_CLASS = 27;
pub const _FILE_INFORMATION_CLASS_FileCompressionInformation: _FILE_INFORMATION_CLASS = 28;
pub const _FILE_INFORMATION_CLASS_FileObjectIdInformation: _FILE_INFORMATION_CLASS = 29;
pub const _FILE_INFORMATION_CLASS_FileCompletionInformation: _FILE_INFORMATION_CLASS = 30;
pub const _FILE_INFORMATION_CLASS_FileMoveClusterInformation: _FILE_INFORMATION_CLASS = 31;
pub const _FILE_INFORMATION_CLASS_FileQuotaInformation: _FILE_INFORMATION_CLASS = 32;
pub const _FILE_INFORMATION_CLASS_FileReparsePointInformation: _FILE_INFORMATION_CLASS = 33;
pub const _FILE_INFORMATION_CLASS_FileNetworkOpenInformation: _FILE_INFORMATION_CLASS = 34;
pub const _FILE_INFORMATION_CLASS_FileAttributeTagInformation: _FILE_INFORMATION_CLASS = 35;
pub const _FILE_INFORMATION_CLASS_FileTrackingInformation: _FILE_INFORMATION_CLASS = 36;
pub const _FILE_INFORMATION_CLASS_FileMaximumInformation: _FILE_INFORMATION_CLASS = 37;
pub type _FILE_INFORMATION_CLASS = libc::c_int;
pub use self::_FILE_INFORMATION_CLASS as FILE_INFORMATION_CLASS;
pub type PFILE_INFORMATION_CLASS = *mut _FILE_INFORMATION_CLASS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_DIRECTORY_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DIRECTORY_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DIRECTORY_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DIRECTORY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_DIRECTORY_INFORMATION = _FILE_DIRECTORY_INFORMATION;
pub type PFILE_DIRECTORY_INFORMATION = *mut _FILE_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_FULL_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_DIR_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_FULL_DIR_INFORMATION = _FILE_FULL_DIR_INFORMATION;
pub type PFILE_FULL_DIR_INFORMATION = *mut _FILE_FULL_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BOTH_DIR_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub FileAttributes: ULONG,
    pub FileNameLength: ULONG,
    pub EaSize: ULONG,
    pub ShortNameLength: CCHAR,
    pub ShortName: [WCHAR; 12usize],
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_BOTH_DIR_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BOTH_DIR_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BOTH_DIR_INFORMATION>(),
        96usize,
        concat!("Size of: ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BOTH_DIR_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BOTH_DIR_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortNameLength) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShortName) as usize - ptr as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(ShortName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BOTH_DIR_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_BOTH_DIR_INFORMATION = _FILE_BOTH_DIR_INFORMATION;
pub type PFILE_BOTH_DIR_INFORMATION = *mut _FILE_BOTH_DIR_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_BASIC_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_BASIC_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_BASIC_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_BASIC_INFORMATION = _FILE_BASIC_INFORMATION;
pub type PFILE_BASIC_INFORMATION = *mut _FILE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STANDARD_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub NumberOfLinks: ULONG,
    pub DeletePending: BOOLEAN,
    pub Directory: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_STANDARD_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STANDARD_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STANDARD_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STANDARD_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STANDARD_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NumberOfLinks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(NumberOfLinks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Directory) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STANDARD_INFORMATION),
            "::",
            stringify!(Directory)
        )
    );
}
pub type FILE_STANDARD_INFORMATION = _FILE_STANDARD_INFORMATION;
pub type PFILE_STANDARD_INFORMATION = *mut _FILE_STANDARD_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_INTERNAL_INFORMATION {
    pub IndexNumber: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_INTERNAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_INTERNAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_INTERNAL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_INTERNAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_INTERNAL_INFORMATION),
            "::",
            stringify!(IndexNumber)
        )
    );
}
pub type FILE_INTERNAL_INFORMATION = _FILE_INTERNAL_INFORMATION;
pub type PFILE_INTERNAL_INFORMATION = *mut _FILE_INTERNAL_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_EA_INFORMATION {
    pub EaSize: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_EA_INFORMATION),
            "::",
            stringify!(EaSize)
        )
    );
}
pub type FILE_EA_INFORMATION = _FILE_EA_INFORMATION;
pub type PFILE_EA_INFORMATION = *mut _FILE_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ACCESS_INFORMATION {
    pub AccessFlags: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__FILE_ACCESS_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ACCESS_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ACCESS_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessFlags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ACCESS_INFORMATION),
            "::",
            stringify!(AccessFlags)
        )
    );
}
pub type FILE_ACCESS_INFORMATION = _FILE_ACCESS_INFORMATION;
pub type PFILE_ACCESS_INFORMATION = *mut _FILE_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAME_INFORMATION {
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAME_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAME_INFORMATION = _FILE_NAME_INFORMATION;
pub type PFILE_NAME_INFORMATION = *mut _FILE_NAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_RENAME_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileName: OBJECT_STRING,
}
#[test]
fn bindgen_test_layout__FILE_RENAME_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_RENAME_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_RENAME_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_RENAME_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_RENAME_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_RENAME_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_RENAME_INFORMATION = _FILE_RENAME_INFORMATION;
pub type PFILE_RENAME_INFORMATION = *mut _FILE_RENAME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_LINK_INFORMATION {
    pub ReplaceIfExists: BOOLEAN,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_LINK_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_LINK_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_LINK_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_LINK_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_LINK_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReplaceIfExists) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(ReplaceIfExists)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_LINK_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_LINK_INFORMATION = _FILE_LINK_INFORMATION;
pub type PFILE_LINK_INFORMATION = *mut _FILE_LINK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NAMES_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub FileIndex: ULONG,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NAMES_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NAMES_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NAMES_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NAMES_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NAMES_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileIndex) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileIndex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NAMES_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NAMES_INFORMATION = _FILE_NAMES_INFORMATION;
pub type PFILE_NAMES_INFORMATION = *mut _FILE_NAMES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_DISPOSITION_INFORMATION {
    pub DeleteFile: BOOLEAN,
}
#[test]
fn bindgen_test_layout__FILE_DISPOSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_DISPOSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_DISPOSITION_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_DISPOSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_DISPOSITION_INFORMATION),
            "::",
            stringify!(DeleteFile)
        )
    );
}
pub type FILE_DISPOSITION_INFORMATION = _FILE_DISPOSITION_INFORMATION;
pub type PFILE_DISPOSITION_INFORMATION = *mut _FILE_DISPOSITION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_POSITION_INFORMATION {
    pub CurrentByteOffset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_POSITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_POSITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_POSITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_POSITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_POSITION_INFORMATION),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
}
pub type FILE_POSITION_INFORMATION = _FILE_POSITION_INFORMATION;
pub type PFILE_POSITION_INFORMATION = *mut _FILE_POSITION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_FULL_EA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
        )
    );
}
pub type FILE_FULL_EA_INFORMATION = _FILE_FULL_EA_INFORMATION;
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MODE_INFORMATION {
    pub Mode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_MODE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MODE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MODE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MODE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MODE_INFORMATION),
            "::",
            stringify!(Mode)
        )
    );
}
pub type FILE_MODE_INFORMATION = _FILE_MODE_INFORMATION;
pub type PFILE_MODE_INFORMATION = *mut _FILE_MODE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ALIGNMENT_INFORMATION {
    pub AlignmentRequirement: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ALIGNMENT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALIGNMENT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALIGNMENT_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ALIGNMENT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALIGNMENT_INFORMATION),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
}
pub type FILE_ALIGNMENT_INFORMATION = _FILE_ALIGNMENT_INFORMATION;
pub type PFILE_ALIGNMENT_INFORMATION = *mut _FILE_ALIGNMENT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALL_INFORMATION {
    pub BasicInformation: FILE_BASIC_INFORMATION,
    pub StandardInformation: FILE_STANDARD_INFORMATION,
    pub InternalInformation: FILE_INTERNAL_INFORMATION,
    pub EaInformation: FILE_EA_INFORMATION,
    pub AccessInformation: FILE_ACCESS_INFORMATION,
    pub PositionInformation: FILE_POSITION_INFORMATION,
    pub ModeInformation: FILE_MODE_INFORMATION,
    pub AlignmentInformation: FILE_ALIGNMENT_INFORMATION,
    pub NameInformation: FILE_NAME_INFORMATION,
}
#[test]
fn bindgen_test_layout__FILE_ALL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALL_INFORMATION>(),
        104usize,
        concat!("Size of: ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALL_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasicInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(BasicInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StandardInformation) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(StandardInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InternalInformation) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(InternalInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EaInformation) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(EaInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AccessInformation) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AccessInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PositionInformation) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(PositionInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ModeInformation) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(ModeInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentInformation) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(AlignmentInformation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NameInformation) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALL_INFORMATION),
            "::",
            stringify!(NameInformation)
        )
    );
}
pub type FILE_ALL_INFORMATION = _FILE_ALL_INFORMATION;
pub type PFILE_ALL_INFORMATION = *mut _FILE_ALL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_ALLOCATION_INFORMATION {
    pub AllocationSize: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_ALLOCATION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ALLOCATION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ALLOCATION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_ALLOCATION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ALLOCATION_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
}
pub type FILE_ALLOCATION_INFORMATION = _FILE_ALLOCATION_INFORMATION;
pub type PFILE_ALLOCATION_INFORMATION = *mut _FILE_ALLOCATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_END_OF_FILE_INFORMATION {
    pub EndOfFile: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_END_OF_FILE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_END_OF_FILE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_END_OF_FILE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_END_OF_FILE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_END_OF_FILE_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
}
pub type FILE_END_OF_FILE_INFORMATION = _FILE_END_OF_FILE_INFORMATION;
pub type PFILE_END_OF_FILE_INFORMATION = *mut _FILE_END_OF_FILE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_STREAM_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub StreamNameLength: ULONG,
    pub StreamSize: LARGE_INTEGER,
    pub StreamAllocationSize: LARGE_INTEGER,
    pub StreamName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_STREAM_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_STREAM_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_STREAM_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_STREAM_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_STREAM_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamNameLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StreamName) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_STREAM_INFORMATION),
            "::",
            stringify!(StreamName)
        )
    );
}
pub type FILE_STREAM_INFORMATION = _FILE_STREAM_INFORMATION;
pub type PFILE_STREAM_INFORMATION = *mut _FILE_STREAM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_INFORMATION {
    pub ReadMode: ULONG,
    pub CompletionMode: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadMode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(ReadMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_INFORMATION),
            "::",
            stringify!(CompletionMode)
        )
    );
}
pub type FILE_PIPE_INFORMATION = _FILE_PIPE_INFORMATION;
pub type PFILE_PIPE_INFORMATION = *mut _FILE_PIPE_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_PIPE_LOCAL_INFORMATION {
    pub NamedPipeType: ULONG,
    pub NamedPipeConfiguration: ULONG,
    pub MaximumInstances: ULONG,
    pub CurrentInstances: ULONG,
    pub InboundQuota: ULONG,
    pub ReadDataAvailable: ULONG,
    pub OutboundQuota: ULONG,
    pub WriteQuotaAvailable: ULONG,
    pub NamedPipeState: ULONG,
    pub NamedPipeEnd: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_LOCAL_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_LOCAL_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        40usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_LOCAL_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_LOCAL_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeConfiguration) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeConfiguration)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumInstances) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(MaximumInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentInstances) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(CurrentInstances)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InboundQuota) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(InboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadDataAvailable) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(ReadDataAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OutboundQuota) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(OutboundQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriteQuotaAvailable) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(WriteQuotaAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeState) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NamedPipeEnd) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_LOCAL_INFORMATION),
            "::",
            stringify!(NamedPipeEnd)
        )
    );
}
pub type FILE_PIPE_LOCAL_INFORMATION = _FILE_PIPE_LOCAL_INFORMATION;
pub type PFILE_PIPE_LOCAL_INFORMATION = *mut _FILE_PIPE_LOCAL_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_PIPE_REMOTE_INFORMATION {
    pub CollectDataTime: LARGE_INTEGER,
    pub MaximumCollectionCount: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_PIPE_REMOTE_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_PIPE_REMOTE_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_PIPE_REMOTE_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_PIPE_REMOTE_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CollectDataTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(CollectDataTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCollectionCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_PIPE_REMOTE_INFORMATION),
            "::",
            stringify!(MaximumCollectionCount)
        )
    );
}
pub type FILE_PIPE_REMOTE_INFORMATION = _FILE_PIPE_REMOTE_INFORMATION;
pub type PFILE_PIPE_REMOTE_INFORMATION = *mut _FILE_PIPE_REMOTE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_MAILSLOT_QUERY_INFORMATION {
    pub MaximumMessageSize: ULONG,
    pub MailslotQuota: ULONG,
    pub NextMessageSize: ULONG,
    pub MessagesAvailable: ULONG,
    pub ReadTimeout: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_QUERY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_QUERY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_QUERY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_QUERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumMessageSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MaximumMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MailslotQuota) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MailslotQuota)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextMessageSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(NextMessageSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MessagesAvailable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(MessagesAvailable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_QUERY_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_QUERY_INFORMATION = _FILE_MAILSLOT_QUERY_INFORMATION;
pub type PFILE_MAILSLOT_QUERY_INFORMATION = *mut _FILE_MAILSLOT_QUERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MAILSLOT_SET_INFORMATION {
    pub ReadTimeout: PLARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__FILE_MAILSLOT_SET_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MAILSLOT_SET_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MAILSLOT_SET_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MAILSLOT_SET_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadTimeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MAILSLOT_SET_INFORMATION),
            "::",
            stringify!(ReadTimeout)
        )
    );
}
pub type FILE_MAILSLOT_SET_INFORMATION = _FILE_MAILSLOT_SET_INFORMATION;
pub type PFILE_MAILSLOT_SET_INFORMATION = *mut _FILE_MAILSLOT_SET_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_COMPRESSION_INFORMATION {
    pub CompressedFileSize: LARGE_INTEGER,
    pub CompressionFormat: USHORT,
    pub CompressionUnitShift: UCHAR,
    pub ChunkShift: UCHAR,
    pub ClusterShift: UCHAR,
    pub Reserved: [UCHAR; 3usize],
}
#[test]
fn bindgen_test_layout__FILE_COMPRESSION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPRESSION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPRESSION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPRESSION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_COMPRESSION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressedFileSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressedFileSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionFormat) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionFormat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompressionUnitShift) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(CompressionUnitShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChunkShift) as usize - ptr as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ChunkShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterShift) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(ClusterShift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPRESSION_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type FILE_COMPRESSION_INFORMATION = _FILE_COMPRESSION_INFORMATION;
pub type PFILE_COMPRESSION_INFORMATION = *mut _FILE_COMPRESSION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION {
    pub FileReference: LONGLONG,
    pub ObjectId: [UCHAR; 16usize],
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_OBJECTID_INFORMATION__bindgen_ty_1 {
    pub __bindgen_anon_1: _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub ExtendedInfo: [UCHAR; 48usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub BirthVolumeId: [UCHAR; 16usize],
    pub BirthObjectId: [UCHAR; 16usize],
    pub DomainId: [UCHAR; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthVolumeId) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthVolumeId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BirthObjectId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BirthObjectId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DomainId) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DomainId)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExtendedInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ExtendedInfo)
        )
    );
}
#[test]
fn bindgen_test_layout__FILE_OBJECTID_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECTID_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECTID_INFORMATION>(),
        72usize,
        concat!("Size of: ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECTID_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECTID_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECTID_INFORMATION),
            "::",
            stringify!(ObjectId)
        )
    );
}
pub type FILE_OBJECTID_INFORMATION = _FILE_OBJECTID_INFORMATION;
pub type PFILE_OBJECTID_INFORMATION = *mut _FILE_OBJECTID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_COMPLETION_INFORMATION {
    pub Port: HANDLE,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__FILE_COMPLETION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_COMPLETION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_COMPLETION_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_COMPLETION_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_COMPLETION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_COMPLETION_INFORMATION),
            "::",
            stringify!(Key)
        )
    );
}
pub type FILE_COMPLETION_INFORMATION = _FILE_COMPLETION_INFORMATION;
pub type PFILE_COMPLETION_INFORMATION = *mut _FILE_COMPLETION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_MOVE_CLUSTER_INFORMATION {
    pub ClusterCount: ULONG,
    pub RootDirectory: HANDLE,
    pub FileNameLength: ULONG,
    pub FileName: [OCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_MOVE_CLUSTER_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_MOVE_CLUSTER_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_MOVE_CLUSTER_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_MOVE_CLUSTER_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ClusterCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(ClusterCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileNameLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_MOVE_CLUSTER_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_MOVE_CLUSTER_INFORMATION = _FILE_MOVE_CLUSTER_INFORMATION;
pub type PFILE_MOVE_CLUSTER_INFORMATION = *mut _FILE_MOVE_CLUSTER_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_QUOTA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub SidLength: ULONG,
    pub ChangeTime: LARGE_INTEGER,
    pub QuotaUsed: LARGE_INTEGER,
    pub QuotaThreshold: LARGE_INTEGER,
    pub QuotaLimit: LARGE_INTEGER,
    pub Sid: SID,
}
#[test]
fn bindgen_test_layout__FILE_QUOTA_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_QUOTA_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_QUOTA_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_QUOTA_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_QUOTA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SidLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaUsed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaUsed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaThreshold) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaThreshold)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QuotaLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(QuotaLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sid) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_QUOTA_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
pub type FILE_QUOTA_INFORMATION = _FILE_QUOTA_INFORMATION;
pub type PFILE_QUOTA_INFORMATION = *mut _FILE_QUOTA_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_REPARSE_POINT_INFORMATION {
    pub FileReference: LONGLONG,
    pub Tag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_REPARSE_POINT_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_REPARSE_POINT_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_REPARSE_POINT_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_REPARSE_POINT_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileReference) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(FileReference)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_REPARSE_POINT_INFORMATION),
            "::",
            stringify!(Tag)
        )
    );
}
pub type FILE_REPARSE_POINT_INFORMATION = _FILE_REPARSE_POINT_INFORMATION;
pub type PFILE_REPARSE_POINT_INFORMATION = *mut _FILE_REPARSE_POINT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NETWORK_OPEN_INFORMATION {
    pub CreationTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub LastWriteTime: LARGE_INTEGER,
    pub ChangeTime: LARGE_INTEGER,
    pub AllocationSize: LARGE_INTEGER,
    pub EndOfFile: LARGE_INTEGER,
    pub FileAttributes: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_NETWORK_OPEN_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_NETWORK_OPEN_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        56usize,
        concat!("Size of: ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_NETWORK_OPEN_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_NETWORK_OPEN_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NETWORK_OPEN_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
}
pub type FILE_NETWORK_OPEN_INFORMATION = _FILE_NETWORK_OPEN_INFORMATION;
pub type PFILE_NETWORK_OPEN_INFORMATION = *mut _FILE_NETWORK_OPEN_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ATTRIBUTE_TAG_INFORMATION {
    pub FileAttributes: ULONG,
    pub ReparseTag: ULONG,
}
#[test]
fn bindgen_test_layout__FILE_ATTRIBUTE_TAG_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_ATTRIBUTE_TAG_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_ATTRIBUTE_TAG_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ATTRIBUTE_TAG_INFORMATION),
            "::",
            stringify!(ReparseTag)
        )
    );
}
pub type FILE_ATTRIBUTE_TAG_INFORMATION = _FILE_ATTRIBUTE_TAG_INFORMATION;
pub type PFILE_ATTRIBUTE_TAG_INFORMATION = *mut _FILE_ATTRIBUTE_TAG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_TRACKING_INFORMATION {
    pub DestinationFile: HANDLE,
    pub ObjectInformationLength: ULONG,
    pub ObjectInformation: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_TRACKING_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_TRACKING_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_TRACKING_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_TRACKING_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_TRACKING_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DestinationFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(DestinationFile)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformationLength) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformationLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectInformation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_TRACKING_INFORMATION),
            "::",
            stringify!(ObjectInformation)
        )
    );
}
pub type FILE_TRACKING_INFORMATION = _FILE_TRACKING_INFORMATION;
pub type PFILE_TRACKING_INFORMATION = *mut _FILE_TRACKING_INFORMATION;
#[doc = " Object Attributes Structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_ATTRIBUTES {
    #[doc = "< Optional handle to the root object directory for the path name specified by the ObjectName member. If RootDirectory is NULL, ObjectName must point to a fully qualified object name that includes the full path to the target object. If RootDirectory is non-NULL, ObjectName specifies an object name relative to the RootDirectory directory."]
    pub RootDirectory: HANDLE,
    #[doc = "< Pointer to an ANSI string that contains the name of the object for which a handle is to be opened. This must either be a fully qualified object name, or a relative path name to the directory specified by the RootDirectory member."]
    pub ObjectName: PANSI_STRING,
    #[doc = "< Bitmask of flags that specify object handle attributes."]
    pub Attributes: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_ATTRIBUTES() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_ATTRIBUTES> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(RootDirectory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ObjectName) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(ObjectName)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Attributes) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
#[doc = " Object Attributes Structure"]
pub type OBJECT_ATTRIBUTES = _OBJECT_ATTRIBUTES;
#[doc = " Object Attributes Structure"]
pub type POBJECT_ATTRIBUTES = *mut _OBJECT_ATTRIBUTES;
pub const _EVENT_TYPE_NotificationEvent: _EVENT_TYPE = 0;
pub const _EVENT_TYPE_SynchronizationEvent: _EVENT_TYPE = 1;
pub type _EVENT_TYPE = libc::c_int;
pub use self::_EVENT_TYPE as EVENT_TYPE;
#[doc = " Memory manager statistics"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MM_STATISTICS {
    #[doc = "< Length of MM_STATISTICS in bytes"]
    pub Length: ULONG,
    pub TotalPhysicalPages: ULONG,
    pub AvailablePages: ULONG,
    pub VirtualMemoryBytesCommitted: ULONG,
    pub VirtualMemoryBytesReserved: ULONG,
    pub CachePagesCommitted: ULONG,
    pub PoolPagesCommitted: ULONG,
    pub StackPagesCommitted: ULONG,
    pub ImagePagesCommitted: ULONG,
}
#[test]
fn bindgen_test_layout__MM_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_MM_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MM_STATISTICS>(),
        36usize,
        concat!("Size of: ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_MM_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_MM_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TotalPhysicalPages) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(TotalPhysicalPages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesCommitted) as usize - ptr as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VirtualMemoryBytesReserved) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(VirtualMemoryBytesReserved)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CachePagesCommitted) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(CachePagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolPagesCommitted) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(PoolPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackPagesCommitted) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(StackPagesCommitted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ImagePagesCommitted) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MM_STATISTICS),
            "::",
            stringify!(ImagePagesCommitted)
        )
    );
}
#[doc = " Memory manager statistics"]
pub type MM_STATISTICS = _MM_STATISTICS;
#[doc = " Memory manager statistics"]
pub type PMM_STATISTICS = *mut _MM_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_HEADER {
    pub dwLaunchDataType: DWORD,
    pub dwTitleId: DWORD,
    pub szLaunchPath: [CHAR; 520usize],
    pub dwFlags: DWORD,
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_HEADER> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_HEADER>(),
        532usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwLaunchDataType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwLaunchDataType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwTitleId) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwTitleId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).szLaunchPath) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(szLaunchPath)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dwFlags) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_HEADER),
            "::",
            stringify!(dwFlags)
        )
    );
}
pub type LAUNCH_DATA_HEADER = _LAUNCH_DATA_HEADER;
pub type PLAUNCH_DATA_HEADER = *mut _LAUNCH_DATA_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LAUNCH_DATA_PAGE {
    pub Header: LAUNCH_DATA_HEADER,
    pub Pad: [UCHAR; 492usize],
    pub LaunchData: [UCHAR; 3072usize],
}
#[test]
fn bindgen_test_layout__LAUNCH_DATA_PAGE() {
    const UNINIT: ::core::mem::MaybeUninit<_LAUNCH_DATA_PAGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_LAUNCH_DATA_PAGE>(),
        4096usize,
        concat!("Size of: ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_LAUNCH_DATA_PAGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_LAUNCH_DATA_PAGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Pad) as usize - ptr as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LaunchData) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(_LAUNCH_DATA_PAGE),
            "::",
            stringify!(LaunchData)
        )
    );
}
pub type LAUNCH_DATA_PAGE = _LAUNCH_DATA_PAGE;
pub type PLAUNCH_DATA_PAGE = *mut _LAUNCH_DATA_PAGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_HEADER {
    pub Type: UCHAR,
    pub Absolute: UCHAR,
    pub Size: UCHAR,
    pub Inserted: UCHAR,
    pub SignalState: LONG,
    pub WaitListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__DISPATCHER_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_DISPATCHER_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISPATCHER_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISPATCHER_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Absolute) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Absolute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SignalState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(SignalState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_HEADER),
            "::",
            stringify!(WaitListHead)
        )
    );
}
pub type DISPATCHER_HEADER = _DISPATCHER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDPC {
    pub Type: CSHORT,
    pub Inserted: BOOLEAN,
    pub Padding: UCHAR,
    pub DpcListEntry: LIST_ENTRY,
    pub DeferredRoutine: PVOID,
    pub DeferredContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KDPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KDPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDPC>(),
        28usize,
        concat!("Size of: ", stringify!(_KDPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DpcListEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DpcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeferredContext) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(DeferredContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KDPC = _KDPC;
pub type PKDPC = *mut _KDPC;
pub type PRKDPC = *mut _KDPC;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTIMER {
    pub Header: DISPATCHER_HEADER,
    pub DueTime: ULARGE_INTEGER,
    pub TimerListEntry: LIST_ENTRY,
    pub Dpc: PKDPC,
    pub Period: LONG,
}
#[test]
fn bindgen_test_layout__KTIMER() {
    const UNINIT: ::core::mem::MaybeUninit<_KTIMER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTIMER>(),
        40usize,
        concat!("Size of: ", stringify!(_KTIMER))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTIMER>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTIMER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DueTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(DueTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerListEntry) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(TimerListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Dpc) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Dpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Period) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTIMER),
            "::",
            stringify!(Period)
        )
    );
}
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type KTIMER = _KTIMER;
#[doc = " The kernels way of representing a timer object. MS recommends not to\n manipulate the members directly."]
pub type PKTIMER = *mut _KTIMER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KPROCESS {
    pub ReadListHead: LIST_ENTRY,
    pub ThreadListHead: LIST_ENTRY,
    pub StackCount: ULONG,
    pub ThreadQuantum: LONG,
    pub BasePriority: SCHAR,
    pub DisableBoost: UCHAR,
    pub DisableQuantum: UCHAR,
}
#[test]
fn bindgen_test_layout__KPROCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_KPROCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KPROCESS>(),
        28usize,
        concat!("Size of: ", stringify!(_KPROCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_KPROCESS>(),
        4usize,
        concat!("Alignment of ", stringify!(_KPROCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ReadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadQuantum) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(ThreadQuantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableQuantum) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_KPROCESS),
            "::",
            stringify!(DisableQuantum)
        )
    );
}
pub type KPROCESS = _KPROCESS;
pub type PKPROCESS = *mut _KPROCESS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC_STATE {
    pub ApcListHead: [LIST_ENTRY; 2usize],
    pub Process: PKPROCESS,
    pub KernelApcInProgress: UCHAR,
    pub KernelApcPending: UCHAR,
    pub UserApcPending: UCHAR,
    pub ApcQueueable: UCHAR,
}
#[test]
fn bindgen_test_layout__KAPC_STATE() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC_STATE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC_STATE>(),
        24usize,
        concat!("Size of: ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC_STATE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Process) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(Process)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcInProgress) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcInProgress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcPending) as usize - ptr as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(KernelApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcPending) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(UserApcPending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcQueueable) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC_STATE),
            "::",
            stringify!(ApcQueueable)
        )
    );
}
pub type KAPC_STATE = _KAPC_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KQUEUE {
    pub Header: DISPATCHER_HEADER,
    pub EntryListHead: LIST_ENTRY,
    pub CurrentCount: ULONG,
    pub MaximumCount: ULONG,
    pub ThreadListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KQUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KQUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KQUEUE>(),
        40usize,
        concat!("Size of: ", stringify!(_KQUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KQUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KQUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EntryListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(EntryListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(MaximumCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListHead) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KQUEUE),
            "::",
            stringify!(ThreadListHead)
        )
    );
}
pub type KQUEUE = _KQUEUE;
pub type PKQUEUE = *mut _KQUEUE;
pub type PRKQUEUE = *mut _KQUEUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KWAIT_BLOCK {
    pub WaitListEntry: LIST_ENTRY,
    pub Thread: *mut _KTHREAD,
    pub Object: PVOID,
    pub NextWaitBlock: *mut _KWAIT_BLOCK,
    pub WaitKey: SHORT,
    pub WaitType: SHORT,
}
#[test]
fn bindgen_test_layout__KWAIT_BLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_KWAIT_BLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KWAIT_BLOCK>(),
        24usize,
        concat!("Size of: ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_KWAIT_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_KWAIT_BLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Object) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(Object)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextWaitBlock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(NextWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitKey) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitType) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_KWAIT_BLOCK),
            "::",
            stringify!(WaitType)
        )
    );
}
pub type KWAIT_BLOCK = _KWAIT_BLOCK;
pub type PKWAIT_BLOCK = *mut _KWAIT_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KAPC {
    pub Type: SHORT,
    pub ApcMode: CHAR,
    pub Inserted: UCHAR,
    pub Thread: *mut _KTHREAD,
    pub ApcListEntry: LIST_ENTRY,
    pub KernelRoutine: PVOID,
    pub RundownRoutine: PVOID,
    pub NormalRoutine: PVOID,
    pub NormalContext: PVOID,
    pub SystemArgument1: PVOID,
    pub SystemArgument2: PVOID,
}
#[test]
fn bindgen_test_layout__KAPC() {
    const UNINIT: ::core::mem::MaybeUninit<_KAPC> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KAPC>(),
        40usize,
        concat!("Size of: ", stringify!(_KAPC))
    );
    assert_eq!(
        ::core::mem::align_of::<_KAPC>(),
        4usize,
        concat!("Alignment of ", stringify!(_KAPC))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcMode) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Inserted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(ApcListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(KernelRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RundownRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(RundownRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalRoutine) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NormalContext) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(NormalContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument1) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemArgument2) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KAPC),
            "::",
            stringify!(SystemArgument2)
        )
    );
}
pub type KAPC = _KAPC;
pub type PKAPC = *mut _KAPC;
pub type PRKAPC = *mut _KAPC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSEMAPHORE {
    pub Header: DISPATCHER_HEADER,
    pub Limit: LONG,
}
#[test]
fn bindgen_test_layout__KSEMAPHORE() {
    const UNINIT: ::core::mem::MaybeUninit<_KSEMAPHORE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSEMAPHORE>(),
        20usize,
        concat!("Size of: ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSEMAPHORE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSEMAPHORE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Limit) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSEMAPHORE),
            "::",
            stringify!(Limit)
        )
    );
}
pub type KSEMAPHORE = _KSEMAPHORE;
pub type PKSEMAPHORE = *mut _KSEMAPHORE;
pub type PRKSEMAPHORE = *mut _KSEMAPHORE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KTHREAD {
    pub Header: DISPATCHER_HEADER,
    pub MutantListHead: LIST_ENTRY,
    pub KernelTime: ULONG,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub KernelStack: PVOID,
    pub TlsData: PVOID,
    pub State: UCHAR,
    pub Alerted: [UCHAR; 2usize],
    pub Alertable: UCHAR,
    pub NpxState: UCHAR,
    pub Saturation: CHAR,
    pub Priority: SCHAR,
    pub Padding: UCHAR,
    pub ApcState: KAPC_STATE,
    pub ContextSwitches: ULONG,
    pub WaitStatus: LONG,
    pub WaitIrql: UCHAR,
    pub WaitMode: CHAR,
    pub WaitNext: UCHAR,
    pub WaitReason: UCHAR,
    pub WaitBlockList: PKWAIT_BLOCK,
    pub WaitListEntry: LIST_ENTRY,
    pub WaitTime: ULONG,
    pub KernelApcDisable: ULONG,
    pub Quantum: LONG,
    pub BasePriority: SCHAR,
    pub DecrementCount: UCHAR,
    pub PriorityDecrement: SCHAR,
    pub DisableBoost: UCHAR,
    pub NpxIrql: UCHAR,
    pub SuspendCount: CHAR,
    pub Preempted: UCHAR,
    pub HasTerminated: UCHAR,
    pub Queue: PKQUEUE,
    pub QueueListEntry: LIST_ENTRY,
    pub Timer: KTIMER,
    pub TimerWaitBlock: KWAIT_BLOCK,
    pub SuspendApc: KAPC,
    pub SuspendSemaphore: KSEMAPHORE,
    pub ThreadListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KTHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_KTHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KTHREAD>(),
        272usize,
        concat!("Size of: ", stringify!(_KTHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_KTHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_KTHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListHead) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(MutantListHead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackBase) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackLimit) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelStack) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelStack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TlsData) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TlsData)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).State) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alerted) as usize - ptr as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alerted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alertable) as usize - ptr as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Alertable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxState) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Saturation) as usize - ptr as usize },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Saturation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        51usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ApcState) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ApcState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ContextSwitches) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ContextSwitches)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitStatus) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitIrql) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitMode) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitMode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitNext) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitNext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitReason) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitReason)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitBlockList) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitBlockList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitListEntry) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WaitTime) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(WaitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).KernelApcDisable) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(KernelApcDisable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Quantum) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Quantum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BasePriority) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(BasePriority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DecrementCount) as usize - ptr as usize },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DecrementCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PriorityDecrement) as usize - ptr as usize },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(PriorityDecrement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DisableBoost) as usize - ptr as usize },
        115usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(DisableBoost)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NpxIrql) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(NpxIrql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendCount) as usize - ptr as usize },
        117usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Preempted) as usize - ptr as usize },
        118usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Preempted)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HasTerminated) as usize - ptr as usize },
        119usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(HasTerminated)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Queue) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Queue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).QueueListEntry) as usize - ptr as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(QueueListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerWaitBlock) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(TimerWaitBlock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendApc) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendApc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SuspendSemaphore) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(SuspendSemaphore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTHREAD),
            "::",
            stringify!(ThreadListEntry)
        )
    );
}
pub type KTHREAD = _KTHREAD;
pub type PKTHREAD = *mut _KTHREAD;
pub type PRKTHREAD = *mut _KTHREAD;
pub const _TIMER_TYPE_NotificationTimer: _TIMER_TYPE = 0;
pub const _TIMER_TYPE_SynchronizationTimer: _TIMER_TYPE = 1;
pub type _TIMER_TYPE = libc::c_int;
pub use self::_TIMER_TYPE as TIMER_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KINTERRUPT {
    pub ServiceRoutine: PVOID,
    pub ServiceContext: PVOID,
    pub BusInterruptLevel: ULONG,
    pub Irql: ULONG,
    pub Connected: UCHAR,
    pub ShareVector: UCHAR,
    pub Mode: UCHAR,
    pub Padding7: UCHAR,
    pub ServiceCount: ULONG,
    pub DispatchCode: [ULONG; 22usize],
}
#[test]
fn bindgen_test_layout__KINTERRUPT() {
    const UNINIT: ::core::mem::MaybeUninit<_KINTERRUPT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KINTERRUPT>(),
        112usize,
        concat!("Size of: ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KINTERRUPT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KINTERRUPT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BusInterruptLevel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(BusInterruptLevel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Irql) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Irql)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Connected) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Connected)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ShareVector) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ShareVector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Mode) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Padding7) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(Padding7)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ServiceCount) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(ServiceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DispatchCode) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KINTERRUPT),
            "::",
            stringify!(DispatchCode)
        )
    );
}
pub type KINTERRUPT = _KINTERRUPT;
pub type PKINTERRUPT = *mut _KINTERRUPT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KSYSTEM_TIME {
    pub LowPart: ULONG,
    pub High1Time: LONG,
    pub High2Time: LONG,
}
#[test]
fn bindgen_test_layout__KSYSTEM_TIME() {
    const UNINIT: ::core::mem::MaybeUninit<_KSYSTEM_TIME> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KSYSTEM_TIME>(),
        12usize,
        concat!("Size of: ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        ::core::mem::align_of::<_KSYSTEM_TIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_KSYSTEM_TIME))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LowPart) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High1Time) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High1Time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).High2Time) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KSYSTEM_TIME),
            "::",
            stringify!(High2Time)
        )
    );
}
pub type KSYSTEM_TIME = _KSYSTEM_TIME;
pub const _FIRMWARE_REENTRY_HalHaltRoutine: _FIRMWARE_REENTRY = 0;
pub const _FIRMWARE_REENTRY_HalRebootRoutine: _FIRMWARE_REENTRY = 1;
pub const _FIRMWARE_REENTRY_HalQuickRebootRoutine: _FIRMWARE_REENTRY = 2;
pub const _FIRMWARE_REENTRY_HalKdRebootRoutine: _FIRMWARE_REENTRY = 3;
pub const _FIRMWARE_REENTRY_HalFatalErrorRebootRoutine: _FIRMWARE_REENTRY = 4;
pub const _FIRMWARE_REENTRY_HalMaximumRoutine: _FIRMWARE_REENTRY = 5;
pub type _FIRMWARE_REENTRY = libc::c_int;
pub use self::_FIRMWARE_REENTRY as FIRMWARE_REENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE {
    pub AllocateProcedure: PVOID,
    pub FreeProcedure: PVOID,
    pub CloseProcedure: PVOID,
    pub DeleteProcedure: PVOID,
    pub ParseProcedure: PVOID,
    pub DefaultObject: PVOID,
    pub PoolTag: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_TYPE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_TYPE>(),
        28usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_TYPE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocateProcedure) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(AllocateProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreeProcedure) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(FreeProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CloseProcedure) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(CloseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeleteProcedure) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DeleteProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ParseProcedure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(ParseProcedure)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DefaultObject) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(DefaultObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PoolTag) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE),
            "::",
            stringify!(PoolTag)
        )
    );
}
pub type OBJECT_TYPE = _OBJECT_TYPE;
pub type POBJECT_TYPE = *mut _OBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HEADER {
    pub PointerCount: LONG,
    pub HandleCount: LONG,
    pub Type: POBJECT_TYPE,
    pub Flags: ULONG,
    pub Body: QUAD,
}
#[test]
fn bindgen_test_layout__OBJECT_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HEADER>(),
        24usize,
        concat!("Size of: ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PointerCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(PointerCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Body) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HEADER),
            "::",
            stringify!(Body)
        )
    );
}
pub type OBJECT_HEADER = _OBJECT_HEADER;
pub type POBJECT_HEADER = *mut _OBJECT_HEADER;
pub type PKDEFERRED_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Dpc: PKDPC,
        DeferredContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE {
    pub Type: SHORT,
    pub Size: UCHAR,
    pub Busy: UCHAR,
    pub DeviceListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE>(),
        12usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Busy) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(Busy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListHead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE),
            "::",
            stringify!(DeviceListHead)
        )
    );
}
pub type KDEVICE_QUEUE = _KDEVICE_QUEUE;
pub type PKDEVICE_QUEUE = *mut _KDEVICE_QUEUE;
pub type PKSTART_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(StartContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: PVOID,
    pub Alignment: DWORD,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_SEGMENT_ELEMENT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
pub type PIO_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcContext: PVOID, IoStatusBlock: PIO_STATUS_BLOCK, Reserved: ULONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SEMAPHORE_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub MaximumCount: LONG,
}
#[test]
fn bindgen_test_layout__SEMAPHORE_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_SEMAPHORE_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_SEMAPHORE_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SEMAPHORE_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SEMAPHORE_BASIC_INFORMATION),
            "::",
            stringify!(MaximumCount)
        )
    );
}
pub type SEMAPHORE_BASIC_INFORMATION = _SEMAPHORE_BASIC_INFORMATION;
pub type PSEMAPHORE_BASIC_INFORMATION = *mut _SEMAPHORE_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MUTANT_BASIC_INFORMATION {
    pub CurrentCount: LONG,
    pub OwnedByCaller: UCHAR,
    pub AbandonedState: UCHAR,
}
#[test]
fn bindgen_test_layout__MUTANT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_MUTANT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MUTANT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MUTANT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MUTANT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(CurrentCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnedByCaller) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(OwnedByCaller)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AbandonedState) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_MUTANT_BASIC_INFORMATION),
            "::",
            stringify!(AbandonedState)
        )
    );
}
pub type MUTANT_BASIC_INFORMATION = _MUTANT_BASIC_INFORMATION;
pub type PMUTANT_BASIC_INFORMATION = *mut _MUTANT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_BASIC_INFORMATION {
    pub Depth: LONG,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_BASIC_INFORMATION),
            "::",
            stringify!(Depth)
        )
    );
}
pub type IO_COMPLETION_BASIC_INFORMATION = _IO_COMPLETION_BASIC_INFORMATION;
pub type PIO_COMPLETION_BASIC_INFORMATION = *mut _IO_COMPLETION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENT_BASIC_INFORMATION {
    pub EventType: EVENT_TYPE,
    pub EventState: LONG,
}
#[test]
fn bindgen_test_layout__EVENT_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_EVENT_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_EVENT_BASIC_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_EVENT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EventState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENT_BASIC_INFORMATION),
            "::",
            stringify!(EventState)
        )
    );
}
pub type EVENT_BASIC_INFORMATION = _EVENT_BASIC_INFORMATION;
pub type PEVENT_BASIC_INFORMATION = *mut _EVENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PS_STATISTICS {
    pub Length: ULONG,
    pub ThreadCount: ULONG,
    pub HandleCount: ULONG,
}
#[test]
fn bindgen_test_layout__PS_STATISTICS() {
    const UNINIT: ::core::mem::MaybeUninit<_PS_STATISTICS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PS_STATISTICS>(),
        12usize,
        concat!("Size of: ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        ::core::mem::align_of::<_PS_STATISTICS>(),
        4usize,
        concat!("Alignment of ", stringify!(_PS_STATISTICS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(ThreadCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PS_STATISTICS),
            "::",
            stringify!(HandleCount)
        )
    );
}
pub type PS_STATISTICS = _PS_STATISTICS;
pub type PPS_STATISTICS = *mut _PS_STATISTICS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ETHREAD {
    pub Tcb: KTHREAD,
    pub CreateTime: LARGE_INTEGER,
    pub ExitTime: LARGE_INTEGER,
    pub __bindgen_anon_1: _ETHREAD__bindgen_ty_1,
    pub __bindgen_anon_2: _ETHREAD__bindgen_ty_2,
    pub UniqueThread: HANDLE,
    pub StartAddress: PVOID,
    pub IrpList: LIST_ENTRY,
    pub DebugData: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_1 {
    pub ExitStatus: NTSTATUS,
    pub OfsChain: PVOID,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitStatus) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(ExitStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OfsChain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_1),
            "::",
            stringify!(OfsChain)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ETHREAD__bindgen_ty_2 {
    pub ReaperListEntry: LIST_ENTRY,
    pub ActiveTimerListHead: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__ETHREAD__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ETHREAD__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaperListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ReaperListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ActiveTimerListHead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD__bindgen_ty_2),
            "::",
            stringify!(ActiveTimerListHead)
        )
    );
}
#[test]
fn bindgen_test_layout__ETHREAD() {
    const UNINIT: ::core::mem::MaybeUninit<_ETHREAD> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ETHREAD>(),
        320usize,
        concat!("Size of: ", stringify!(_ETHREAD))
    );
    assert_eq!(
        ::core::mem::align_of::<_ETHREAD>(),
        8usize,
        concat!("Alignment of ", stringify!(_ETHREAD))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tcb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(Tcb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CreateTime) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(CreateTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ExitTime) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(ExitTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UniqueThread) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(UniqueThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartAddress) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(StartAddress)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IrpList) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(IrpList)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DebugData) as usize - ptr as usize },
        316usize,
        concat!(
            "Offset of field: ",
            stringify!(_ETHREAD),
            "::",
            stringify!(DebugData)
        )
    );
}
pub type ETHREAD = _ETHREAD;
pub type PETHREAD = *mut _ETHREAD;
pub type PCREATE_THREAD_NOTIFY_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Thread: PETHREAD, ThreadId: HANDLE, Create: BOOLEAN),
>;
#[doc = "< Interrupt is level-triggered. Used for traditional PCI line-based interrupts."]
pub const _KINTERRUPT_MODE_LevelSensitive: _KINTERRUPT_MODE = 0;
#[doc = "< Interrupt is edge-triggered. Used for PCI message-signaled interrupts"]
pub const _KINTERRUPT_MODE_Latched: _KINTERRUPT_MODE = 1;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub type _KINTERRUPT_MODE = libc::c_int;
#[doc = " Enumeration type for indicating whether an interrupt is level- or\n edge-triggered."]
pub use self::_KINTERRUPT_MODE as KINTERRUPT_MODE;
pub type PKSERVICE_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(Interrupt: PKINTERRUPT, ServiceContext: PVOID) -> BOOLEAN,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TIMER_BASIC_INFORMATION {
    pub RemainingTime: LARGE_INTEGER,
    pub TimerState: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TIMER_BASIC_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_TIMER_BASIC_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_TIMER_BASIC_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_TIMER_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TIMER_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemainingTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(RemainingTime)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerState) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TIMER_BASIC_INFORMATION),
            "::",
            stringify!(TimerState)
        )
    );
}
pub type TIMER_BASIC_INFORMATION = _TIMER_BASIC_INFORMATION;
pub type PTIMER_BASIC_INFORMATION = *mut _TIMER_BASIC_INFORMATION;
pub type PTIMER_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(TimerContext: PVOID, TimerLowValue: ULONG, TimerHighValue: LONG),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_KRNL_VERSION {
    pub Major: USHORT,
    pub Minor: USHORT,
    pub Build: USHORT,
    pub Qfe: USHORT,
}
#[test]
fn bindgen_test_layout__XBOX_KRNL_VERSION() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_KRNL_VERSION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_KRNL_VERSION>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_KRNL_VERSION>(),
        2usize,
        concat!("Alignment of ", stringify!(_XBOX_KRNL_VERSION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Build) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Build)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Qfe) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_KRNL_VERSION),
            "::",
            stringify!(Qfe)
        )
    );
}
pub type XBOX_KRNL_VERSION = _XBOX_KRNL_VERSION;
pub type PXBOX_KRNL_VERSION = *mut _XBOX_KRNL_VERSION;
#[doc = " Information about the XBOX-hardware"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XBOX_HARDWARE_INFO {
    pub Flags: ULONG,
    pub GpuRevision: UCHAR,
    pub McpRevision: UCHAR,
    pub reserved: [UCHAR; 2usize],
}
#[test]
fn bindgen_test_layout__XBOX_HARDWARE_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_HARDWARE_INFO> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_HARDWARE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_HARDWARE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_XBOX_HARDWARE_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GpuRevision) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(GpuRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).McpRevision) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(McpRevision)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_HARDWARE_INFO),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " Information about the XBOX-hardware"]
pub type XBOX_HARDWARE_INFO = _XBOX_HARDWARE_INFO;
pub type XBOX_KEY_DATA = [UCHAR; 16usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    const UNINIT: ::core::mem::MaybeUninit<_GENERIC_MAPPING> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::core::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut _GENERIC_MAPPING;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    #[doc = "< Pointer to the next (or first, if this is a header) entry in the singly linked list (NULL if there is none)"]
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_SINGLE_LIST_ENTRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
#[doc = " Describes an entry in (or the header of) a singly linked list"]
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER {
    pub Alignment: ULONGLONG,
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Next: SINGLE_LIST_ENTRY,
    pub Depth: USHORT,
    pub Sequence: USHORT,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Depth) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Depth)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Sequence) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Sequence)
        )
    );
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    const UNINIT: ::core::mem::MaybeUninit<_SLIST_HEADER> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        ::core::mem::align_of::<_SLIST_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Alignment) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(Alignment)
        )
    );
}
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type SLIST_HEADER = _SLIST_HEADER;
#[doc = " Serves as a header for a singly linked list. Initialized by ExInitializeSListHead"]
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KEVENT {
    pub Header: DISPATCHER_HEADER,
}
#[test]
fn bindgen_test_layout__KEVENT() {
    const UNINIT: ::core::mem::MaybeUninit<_KEVENT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KEVENT>(),
        16usize,
        concat!("Size of: ", stringify!(_KEVENT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KEVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KEVENT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KEVENT),
            "::",
            stringify!(Header)
        )
    );
}
pub type KEVENT = _KEVENT;
pub type PKEVENT = *mut _KEVENT;
pub type PRKEVENT = *mut _KEVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KDEVICE_QUEUE_ENTRY {
    pub DeviceListEntry: LIST_ENTRY,
    pub SortKey: ULONG,
    pub Inserted: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KDEVICE_QUEUE_ENTRY() {
    const UNINIT: ::core::mem::MaybeUninit<_KDEVICE_QUEUE_ENTRY> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KDEVICE_QUEUE_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_KDEVICE_QUEUE_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_KDEVICE_QUEUE_ENTRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(DeviceListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SortKey) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(SortKey)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Inserted) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KDEVICE_QUEUE_ENTRY),
            "::",
            stringify!(Inserted)
        )
    );
}
pub type KDEVICE_QUEUE_ENTRY = _KDEVICE_QUEUE_ENTRY;
pub type PKDEVICE_QUEUE_ENTRY = *mut _KDEVICE_QUEUE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COMPLETION_CONTEXT {
    pub Port: PVOID,
    pub Key: PVOID,
}
#[test]
fn bindgen_test_layout__IO_COMPLETION_CONTEXT() {
    const UNINIT: ::core::mem::MaybeUninit<_IO_COMPLETION_CONTEXT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IO_COMPLETION_CONTEXT>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_COMPLETION_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_COMPLETION_CONTEXT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COMPLETION_CONTEXT),
            "::",
            stringify!(Key)
        )
    );
}
pub type IO_COMPLETION_CONTEXT = _IO_COMPLETION_CONTEXT;
pub type PIO_COMPLETION_CONTEXT = *mut _IO_COMPLETION_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_OBJECT {
    pub Type: CSHORT,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub Flags: UCHAR,
    pub DeviceObject: *mut _DEVICE_OBJECT,
    pub FsContext: PVOID,
    pub FsContext2: PVOID,
    pub FinalStatus: NTSTATUS,
    pub CurrentByteOffset: LARGE_INTEGER,
    pub RelatedFileObject: *mut _FILE_OBJECT,
    pub CompletionContext: PIO_COMPLETION_CONTEXT,
    pub LockCount: LONG,
    pub Lock: KEVENT,
    pub Event: KEVENT,
}
#[test]
fn bindgen_test_layout__FILE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_FILE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_FILE_OBJECT>(),
        80usize,
        concat!("Size of: ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_FILE_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceObject) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(DeviceObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FsContext2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FsContext2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinalStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(FinalStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentByteOffset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CurrentByteOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RelatedFileObject) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(RelatedFileObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionContext) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(CompletionContext)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Lock) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Event) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_OBJECT),
            "::",
            stringify!(Event)
        )
    );
}
impl _FILE_OBJECT {
    #[inline]
    pub fn DeletePending(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeletePending(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_ReadAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_WriteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeleteAccess(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_DeleteAccess(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedRead(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedRead(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedWrite(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedWrite(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SharedDelete(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_SharedDelete(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BOOLEAN {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BOOLEAN) {
        unsafe {
            let val: u8 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DeletePending: BOOLEAN,
        ReadAccess: BOOLEAN,
        WriteAccess: BOOLEAN,
        DeleteAccess: BOOLEAN,
        SharedRead: BOOLEAN,
        SharedWrite: BOOLEAN,
        SharedDelete: BOOLEAN,
        Reserved: BOOLEAN,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DeletePending: u8 = unsafe { ::core::mem::transmute(DeletePending) };
            DeletePending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let ReadAccess: u8 = unsafe { ::core::mem::transmute(ReadAccess) };
            ReadAccess as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let WriteAccess: u8 = unsafe { ::core::mem::transmute(WriteAccess) };
            WriteAccess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DeleteAccess: u8 = unsafe { ::core::mem::transmute(DeleteAccess) };
            DeleteAccess as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SharedRead: u8 = unsafe { ::core::mem::transmute(SharedRead) };
            SharedRead as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SharedWrite: u8 = unsafe { ::core::mem::transmute(SharedWrite) };
            SharedWrite as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let SharedDelete: u8 = unsafe { ::core::mem::transmute(SharedDelete) };
            SharedDelete as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Reserved: u8 = unsafe { ::core::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FILE_OBJECT = _FILE_OBJECT;
pub type PFILE_OBJECT = *mut _FILE_OBJECT;
#[doc = " This struct represents an I/O request packet"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP {
    pub Type: CSHORT,
    pub Size: USHORT,
    #[doc = "< Flags for the packet"]
    pub Flags: ULONG,
    pub ThreadListEntry: LIST_ENTRY,
    pub IoStatus: IO_STATUS_BLOCK,
    pub StackCount: CHAR,
    pub CurrentLocation: CHAR,
    pub PendingReturned: BOOLEAN,
    #[doc = "< Has the packet been canceled?"]
    pub Cancel: BOOLEAN,
    pub UserIosb: PIO_STATUS_BLOCK,
    pub UserEvent: PKEVENT,
    pub Overlay: _IRP__bindgen_ty_1,
    pub UserBuffer: PVOID,
    pub SegmentArray: PFILE_SEGMENT_ELEMENT,
    pub LockedBufferLength: ULONG,
    pub Tail: _IRP__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_1 {
    pub AsynchronousParameters: _IRP__bindgen_ty_1__bindgen_ty_1,
    pub AllocationSize: LARGE_INTEGER,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_1__bindgen_ty_1 {
    pub UserApcRoutine: PIO_APC_ROUTINE,
    pub UserApcContext: PVOID,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserApcContext) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserApcContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_1> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AsynchronousParameters) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AsynchronousParameters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_1),
            "::",
            stringify!(AllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2 {
    pub Overlay: _IRP__bindgen_ty_2__bindgen_ty_1,
    pub Apc: KAPC,
    pub CompletionKey: PVOID,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1 {
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Thread: PETHREAD,
    pub __bindgen_anon_2: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    pub OriginalFileObject: PFILE_OBJECT,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub DeviceQueueEntry: KDEVICE_QUEUE_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub DriverContext: [PVOID; 5usize],
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DriverContext)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueueEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DeviceQueueEntry)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub ListEntry: LIST_ENTRY,
    pub __bindgen_anon_1: _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub CurrentStackLocation: *mut _IO_STATUS_LOCATION,
    pub PacketType: ULONG,
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        _IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentStackLocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(CurrentStackLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PacketType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(PacketType)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Thread) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Thread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OriginalFileObject) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(OriginalFileObject)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP__bindgen_ty_2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP__bindgen_ty_2>(),
        40usize,
        concat!("Size of: ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_IRP__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Apc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(Apc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CompletionKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP__bindgen_ty_2),
            "::",
            stringify!(CompletionKey)
        )
    );
}
#[test]
fn bindgen_test_layout__IRP() {
    const UNINIT: ::core::mem::MaybeUninit<_IRP> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IRP>(),
        104usize,
        concat!("Size of: ", stringify!(_IRP))
    );
    assert_eq!(
        ::core::mem::align_of::<_IRP>(),
        8usize,
        concat!("Alignment of ", stringify!(_IRP))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ThreadListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(ThreadListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(IoStatus)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackCount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(StackCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentLocation) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(CurrentLocation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PendingReturned) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(PendingReturned)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cancel) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Cancel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserIosb) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserIosb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserEvent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Overlay) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Overlay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).UserBuffer) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(UserBuffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SegmentArray) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(SegmentArray)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockedBufferLength) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(LockedBufferLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Tail) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IRP),
            "::",
            stringify!(Tail)
        )
    );
}
#[doc = " This struct represents an I/O request packet"]
pub type IRP = _IRP;
#[doc = " This struct represents an I/O request packet"]
pub type PIRP = *mut _IRP;
pub type PDRIVER_STARTIO = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP),
>;
pub type PDRIVER_DELETEDEVICE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT)>;
pub type PDRIVER_DISMOUNTVOLUME = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT) -> NTSTATUS,
>;
pub type PDRIVER_DISPATCH = ::core::option::Option<
    unsafe extern "stdcall" fn(DeviceObject: *mut _DEVICE_OBJECT, Irp: *mut _IRP) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DRIVER_OBJECT {
    pub DriverStartIo: PDRIVER_STARTIO,
    pub DriverDeleteDevice: PDRIVER_DELETEDEVICE,
    pub DriverDismountVolume: PDRIVER_DISMOUNTVOLUME,
    pub MajorFunction: [PDRIVER_DISPATCH; 14usize],
}
#[test]
fn bindgen_test_layout__DRIVER_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DRIVER_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DRIVER_OBJECT>(),
        68usize,
        concat!("Size of: ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DRIVER_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DRIVER_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverStartIo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverStartIo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDeleteDevice) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDeleteDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverDismountVolume) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(DriverDismountVolume)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MajorFunction) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DRIVER_OBJECT),
            "::",
            stringify!(MajorFunction)
        )
    );
}
pub type DRIVER_OBJECT = _DRIVER_OBJECT;
pub type PDRIVER_OBJECT = *mut _DRIVER_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DEVICE_OBJECT {
    pub Type: CSHORT,
    pub Size: USHORT,
    pub ReferenceCount: LONG,
    pub DriverObject: PDRIVER_OBJECT,
    pub MountedOrSelfDevice: *mut _DEVICE_OBJECT,
    pub CurrentIrp: PIRP,
    pub Flags: ULONG,
    pub DeviceExtension: PVOID,
    pub DeviceType: UCHAR,
    pub StartIoFlags: UCHAR,
    pub StackSize: CCHAR,
    pub DeletePending: BOOLEAN,
    pub SectorSize: ULONG,
    pub AlignmentRequirement: ULONG,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub DeviceLock: KEVENT,
    pub StartIoKey: ULONG,
}
#[test]
fn bindgen_test_layout__DEVICE_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_DEVICE_OBJECT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DEVICE_OBJECT>(),
        72usize,
        concat!("Size of: ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_DEVICE_OBJECT>(),
        4usize,
        concat!("Alignment of ", stringify!(_DEVICE_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReferenceCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(ReferenceCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DriverObject) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DriverObject)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MountedOrSelfDevice) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(MountedOrSelfDevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceExtension) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceExtension)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceType) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoFlags) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoFlags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StackSize) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StackSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeletePending) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeletePending)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AlignmentRequirement) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(AlignmentRequirement)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceLock) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(DeviceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartIoKey) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_DEVICE_OBJECT),
            "::",
            stringify!(StartIoKey)
        )
    );
}
pub type DEVICE_OBJECT = _DEVICE_OBJECT;
pub type PDEVICE_OBJECT = *mut _DEVICE_OBJECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_DIRECTORY_INFORMATION {
    pub Name: OBJECT_STRING,
    pub Type: ULONG,
}
#[test]
fn bindgen_test_layout__OBJECT_DIRECTORY_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_DIRECTORY_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_DIRECTORY_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_DIRECTORY_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_DIRECTORY_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type OBJECT_DIRECTORY_INFORMATION = _OBJECT_DIRECTORY_INFORMATION;
pub type POBJECT_DIRECTORY_INFORMATION = *mut _OBJECT_DIRECTORY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ERWLOCK {
    pub LockCount: LONG,
    pub WritersWaitingCount: ULONG,
    pub ReadersWaitingCount: ULONG,
    pub ReadersEntryCount: ULONG,
    pub WriterEvent: KEVENT,
    pub ReaderSemaphore: KSEMAPHORE,
}
#[test]
fn bindgen_test_layout__ERWLOCK() {
    const UNINIT: ::core::mem::MaybeUninit<_ERWLOCK> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_ERWLOCK>(),
        52usize,
        concat!("Size of: ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        ::core::mem::align_of::<_ERWLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_ERWLOCK))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WritersWaitingCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WritersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersWaitingCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersWaitingCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReadersEntryCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReadersEntryCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).WriterEvent) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(WriterEvent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ReaderSemaphore) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ERWLOCK),
            "::",
            stringify!(ReaderSemaphore)
        )
    );
}
pub type ERWLOCK = _ERWLOCK;
pub type PERWLOCK = *mut _ERWLOCK;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XBOX_REFURB_INFO {
    pub Signature: ULONG,
    pub PowerCycleCount: ULONG,
    pub FirstSetTime: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__XBOX_REFURB_INFO() {
    const UNINIT: ::core::mem::MaybeUninit<_XBOX_REFURB_INFO> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_XBOX_REFURB_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        ::core::mem::align_of::<_XBOX_REFURB_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_XBOX_REFURB_INFO))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Signature) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PowerCycleCount) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(PowerCycleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstSetTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XBOX_REFURB_INFO),
            "::",
            stringify!(FirstSetTime)
        )
    );
}
pub type XBOX_REFURB_INFO = _XBOX_REFURB_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KFLOATING_SAVE {
    pub ControlWord: ULONG,
    pub StatusWord: ULONG,
    pub ErrorOffset: ULONG,
    pub ErrorSelector: ULONG,
    pub DataOffset: ULONG,
    pub DataSelector: ULONG,
    pub Cr0NpxState: ULONG,
    pub Spare1: ULONG,
}
#[test]
fn bindgen_test_layout__KFLOATING_SAVE() {
    const UNINIT: ::core::mem::MaybeUninit<_KFLOATING_SAVE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KFLOATING_SAVE>(),
        32usize,
        concat!("Size of: ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        ::core::mem::align_of::<_KFLOATING_SAVE>(),
        4usize,
        concat!("Alignment of ", stringify!(_KFLOATING_SAVE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ControlWord) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StatusWord) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorOffset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ErrorSelector) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataOffset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DataSelector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cr0NpxState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Cr0NpxState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Spare1) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KFLOATING_SAVE),
            "::",
            stringify!(Spare1)
        )
    );
}
pub type KFLOATING_SAVE = _KFLOATING_SAVE;
pub type PKFLOATING_SAVE = *mut _KFLOATING_SAVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_PTE {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__HARDWARE_PTE() {
    assert_eq!(
        ::core::mem::size_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Size of: ", stringify!(_HARDWARE_PTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_HARDWARE_PTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_HARDWARE_PTE))
    );
}
impl _HARDWARE_PTE {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Write(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Write(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Owner(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Owner(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WriteThrough(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WriteThrough(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CacheDisable(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CacheDisable(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Accessed(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Accessed(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Dirty(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Dirty(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LargePage(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LargePage(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Global(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Global(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GuardOrEndOfAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GuardOrEndOfAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistAllocation(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistAllocation(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PageFrameNumber(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_PageFrameNumber(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        Write: ULONG,
        Owner: ULONG,
        WriteThrough: ULONG,
        CacheDisable: ULONG,
        Accessed: ULONG,
        Dirty: ULONG,
        LargePage: ULONG,
        Global: ULONG,
        GuardOrEndOfAllocation: ULONG,
        PersistAllocation: ULONG,
        reserved: ULONG,
        PageFrameNumber: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Write: u32 = unsafe { ::core::mem::transmute(Write) };
            Write as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Owner: u32 = unsafe { ::core::mem::transmute(Owner) };
            Owner as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let WriteThrough: u32 = unsafe { ::core::mem::transmute(WriteThrough) };
            WriteThrough as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let CacheDisable: u32 = unsafe { ::core::mem::transmute(CacheDisable) };
            CacheDisable as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Accessed: u32 = unsafe { ::core::mem::transmute(Accessed) };
            Accessed as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Dirty: u32 = unsafe { ::core::mem::transmute(Dirty) };
            Dirty as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let LargePage: u32 = unsafe { ::core::mem::transmute(LargePage) };
            LargePage as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Global: u32 = unsafe { ::core::mem::transmute(Global) };
            Global as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let GuardOrEndOfAllocation: u32 =
                unsafe { ::core::mem::transmute(GuardOrEndOfAllocation) };
            GuardOrEndOfAllocation as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PersistAllocation: u32 = unsafe { ::core::mem::transmute(PersistAllocation) };
            PersistAllocation as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let reserved: u32 = unsafe { ::core::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let PageFrameNumber: u32 = unsafe { ::core::mem::transmute(PageFrameNumber) };
            PageFrameNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type HARDWARE_PTE = _HARDWARE_PTE;
pub type PHARDWARE_PTE = *mut _HARDWARE_PTE;
pub type PPS_APC_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(ApcArgument1: PVOID, ApcArgument2: PVOID, ApcArgument3: PVOID),
>;
pub const _KWAIT_REASON_Executive: _KWAIT_REASON = 0;
pub const _KWAIT_REASON_FreePage: _KWAIT_REASON = 1;
pub const _KWAIT_REASON_PageIn: _KWAIT_REASON = 2;
pub const _KWAIT_REASON_PoolAllocation: _KWAIT_REASON = 3;
pub const _KWAIT_REASON_DelayExecution: _KWAIT_REASON = 4;
pub const _KWAIT_REASON_Suspended: _KWAIT_REASON = 5;
pub const _KWAIT_REASON_UserRequest: _KWAIT_REASON = 6;
pub const _KWAIT_REASON_WrExecutive: _KWAIT_REASON = 7;
pub const _KWAIT_REASON_WrFreePage: _KWAIT_REASON = 8;
pub const _KWAIT_REASON_WrPageIn: _KWAIT_REASON = 9;
pub const _KWAIT_REASON_WrPoolAllocation: _KWAIT_REASON = 10;
pub const _KWAIT_REASON_WrDelayExecution: _KWAIT_REASON = 11;
pub const _KWAIT_REASON_WrSuspended: _KWAIT_REASON = 12;
pub const _KWAIT_REASON_WrUserRequest: _KWAIT_REASON = 13;
pub const _KWAIT_REASON_WrEventPair: _KWAIT_REASON = 14;
pub const _KWAIT_REASON_WrQueue: _KWAIT_REASON = 15;
pub const _KWAIT_REASON_WrLpcReceive: _KWAIT_REASON = 16;
pub const _KWAIT_REASON_WrLpcReply: _KWAIT_REASON = 17;
pub const _KWAIT_REASON_WrVirtualMemory: _KWAIT_REASON = 18;
pub const _KWAIT_REASON_WrPageOut: _KWAIT_REASON = 19;
pub const _KWAIT_REASON_WrRendezvous: _KWAIT_REASON = 20;
pub const _KWAIT_REASON_WrFsCacheIn: _KWAIT_REASON = 21;
pub const _KWAIT_REASON_WrFsCacheOut: _KWAIT_REASON = 22;
pub const _KWAIT_REASON_Spare4: _KWAIT_REASON = 23;
pub const _KWAIT_REASON_Spare5: _KWAIT_REASON = 24;
pub const _KWAIT_REASON_Spare6: _KWAIT_REASON = 25;
pub const _KWAIT_REASON_WrKernel: _KWAIT_REASON = 26;
pub const _KWAIT_REASON_MaximumWaitReason: _KWAIT_REASON = 27;
pub type _KWAIT_REASON = libc::c_int;
pub use self::_KWAIT_REASON as KWAIT_REASON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KMUTANT {
    pub Header: DISPATCHER_HEADER,
    pub MutantListEntry: LIST_ENTRY,
    pub OwnerThread: PRKTHREAD,
    pub Abandoned: BOOLEAN,
}
#[test]
fn bindgen_test_layout__KMUTANT() {
    const UNINIT: ::core::mem::MaybeUninit<_KMUTANT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_KMUTANT>(),
        32usize,
        concat!("Size of: ", stringify!(_KMUTANT))
    );
    assert_eq!(
        ::core::mem::align_of::<_KMUTANT>(),
        4usize,
        concat!("Alignment of ", stringify!(_KMUTANT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MutantListEntry) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(MutantListEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OwnerThread) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(OwnerThread)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Abandoned) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KMUTANT),
            "::",
            stringify!(Abandoned)
        )
    );
}
pub type KMUTANT = _KMUTANT;
pub type PKMUTANT = *mut _KMUTANT;
pub type PRKMUTANT = *mut _KMUTANT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARE_ACCESS {
    pub OpenCount: UCHAR,
    pub Readers: UCHAR,
    pub Writers: UCHAR,
    pub Deleters: UCHAR,
    pub SharedRead: UCHAR,
    pub SharedWrite: UCHAR,
    pub SharedDelete: UCHAR,
}
#[test]
fn bindgen_test_layout__SHARE_ACCESS() {
    const UNINIT: ::core::mem::MaybeUninit<_SHARE_ACCESS> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_SHARE_ACCESS>(),
        7usize,
        concat!("Size of: ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        ::core::mem::align_of::<_SHARE_ACCESS>(),
        1usize,
        concat!("Alignment of ", stringify!(_SHARE_ACCESS))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).OpenCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(OpenCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Readers) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Readers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Writers) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Writers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Deleters) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(Deleters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedRead) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedRead)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedWrite) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedWrite)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SharedDelete) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARE_ACCESS),
            "::",
            stringify!(SharedDelete)
        )
    );
}
pub type SHARE_ACCESS = _SHARE_ACCESS;
pub type PSHARE_ACCESS = *mut _SHARE_ACCESS;
pub type PKSYNCHRONIZE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(SynchronizeContext: PVOID) -> BOOLEAN>;
pub type PKRUNDOWN_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn(Apc: PKAPC)>;
pub type PKNORMAL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        NormalContext: PVOID,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
    ),
>;
pub type PKKERNEL_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(
        Apc: PKAPC,
        NormalRoutine: *mut PKNORMAL_ROUTINE,
        NormalContext: *mut PVOID,
        SystemArgument1: *mut PVOID,
        SystemArgument2: *mut PVOID,
    ),
>;
pub type PHAL_SHUTDOWN_NOTIFICATION = ::core::option::Option<
    unsafe extern "stdcall" fn(ShutdownRegistration: *mut _HAL_SHUTDOWN_REGISTRATION),
>;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _HAL_SHUTDOWN_REGISTRATION {
    #[doc = "< Function pointer which will be called on shutdown"]
    pub NotificationRoutine: PHAL_SHUTDOWN_NOTIFICATION,
    #[doc = "< Priority of the notification.The higher the priority, the earliert the callback function is called"]
    pub Priority: LONG,
    #[doc = "< Used to put the notifications into a linked list"]
    pub ListEntry: LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__HAL_SHUTDOWN_REGISTRATION() {
    const UNINIT: ::core::mem::MaybeUninit<_HAL_SHUTDOWN_REGISTRATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        16usize,
        concat!("Size of: ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_HAL_SHUTDOWN_REGISTRATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_HAL_SHUTDOWN_REGISTRATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NotificationRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(NotificationRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Priority) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(Priority)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ListEntry) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HAL_SHUTDOWN_REGISTRATION),
            "::",
            stringify!(ListEntry)
        )
    );
}
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type HAL_SHUTDOWN_REGISTRATION = _HAL_SHUTDOWN_REGISTRATION;
#[doc = " Describes a shutdown notification, containing a function pointer and a priority"]
pub type PHAL_SHUTDOWN_REGISTRATION = *mut _HAL_SHUTDOWN_REGISTRATION;
pub type pfXcSHAInit = ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR)>;
pub type pfXcSHAUpdate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG),
>;
pub type pfXcSHAFinal =
    ::core::option::Option<unsafe extern "stdcall" fn(pbSHAContext: PUCHAR, pbDigest: PUCHAR)>;
pub type pfXcRC4Key = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR),
>;
pub type pfXcRC4Crypt = ::core::option::Option<
    unsafe extern "stdcall" fn(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR),
>;
pub type pfXcHMAC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    ),
>;
pub type pfXcPKEncPublic = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKDecPrivate = ::core::option::Option<
    unsafe extern "stdcall" fn(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG,
>;
pub type pfXcPKGetKeyLen =
    ::core::option::Option<unsafe extern "stdcall" fn(pbPubKey: PUCHAR) -> ULONG>;
pub type pfXcVerifyPKCS1Signature = ::core::option::Option<
    unsafe extern "stdcall" fn(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN,
>;
pub type pfXcModExp = ::core::option::Option<
    unsafe extern "stdcall" fn(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG,
>;
pub type pfXcDESKeyParity =
    ::core::option::Option<unsafe extern "stdcall" fn(pbKey: PUCHAR, dwKeyLength: ULONG)>;
pub type pfXcKeyTable = ::core::option::Option<
    unsafe extern "stdcall" fn(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR),
>;
pub type pfXcBlockCrypt = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    ),
>;
pub type pfXcBlockCryptCBC = ::core::option::Option<
    unsafe extern "stdcall" fn(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    ),
>;
pub type pfXcCryptService =
    ::core::option::Option<unsafe extern "stdcall" fn(dwOp: ULONG, pArgs: PVOID) -> ULONG>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CRYPTO_VECTOR {
    pub pXcSHAInit: pfXcSHAInit,
    pub pXcSHAUpdate: pfXcSHAUpdate,
    pub pXcSHAFinal: pfXcSHAFinal,
    pub pXcRC4Key: pfXcRC4Key,
    pub pXcRC4Crypt: pfXcRC4Crypt,
    pub pXcHMAC: pfXcHMAC,
    pub pXcPKEncPublic: pfXcPKEncPublic,
    pub pXcPKDecPrivate: pfXcPKDecPrivate,
    pub pXcPKGetKeyLen: pfXcPKGetKeyLen,
    pub pXcVerifyPKCS1Signature: pfXcVerifyPKCS1Signature,
    pub pXcModExp: pfXcModExp,
    pub pXcDESKeyParity: pfXcDESKeyParity,
    pub pXcKeyTable: pfXcKeyTable,
    pub pXcBlockCrypt: pfXcBlockCrypt,
    pub pXcBlockCryptCBC: pfXcBlockCryptCBC,
    pub pXcCryptService: pfXcCryptService,
}
#[test]
fn bindgen_test_layout_CRYPTO_VECTOR() {
    const UNINIT: ::core::mem::MaybeUninit<CRYPTO_VECTOR> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<CRYPTO_VECTOR>(),
        64usize,
        concat!("Size of: ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        ::core::mem::align_of::<CRYPTO_VECTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(CRYPTO_VECTOR))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAInit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAInit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAUpdate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAUpdate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcSHAFinal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcSHAFinal)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Key) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcRC4Crypt) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcRC4Crypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcHMAC) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcHMAC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKEncPublic) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKEncPublic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKDecPrivate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKDecPrivate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcPKGetKeyLen) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcPKGetKeyLen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcVerifyPKCS1Signature) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcVerifyPKCS1Signature)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcModExp) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcModExp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcDESKeyParity) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcDESKeyParity)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcKeyTable) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcKeyTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCrypt) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCrypt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcBlockCryptCBC) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcBlockCryptCBC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pXcCryptService) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(CRYPTO_VECTOR),
            "::",
            stringify!(pXcCryptService)
        )
    );
}
pub type PCRYPTO_VECTOR = *mut CRYPTO_VECTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_HANDLE_TABLE {
    pub HandleCount: LONG,
    pub FirstFreeTableEntry: LONG_PTR,
    pub NextHandleNeedingPool: HANDLE,
    pub RootTable: *mut *mut PVOID,
    pub BuiltinRootTable: [*mut PVOID; 8usize],
}
#[test]
fn bindgen_test_layout__OBJECT_HANDLE_TABLE() {
    const UNINIT: ::core::mem::MaybeUninit<_OBJECT_HANDLE_TABLE> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_OBJECT_HANDLE_TABLE>(),
        48usize,
        concat!("Size of: ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        ::core::mem::align_of::<_OBJECT_HANDLE_TABLE>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECT_HANDLE_TABLE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HandleCount) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(HandleCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstFreeTableEntry) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(FirstFreeTableEntry)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).NextHandleNeedingPool) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(NextHandleNeedingPool)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RootTable) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(RootTable)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BuiltinRootTable) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_HANDLE_TABLE),
            "::",
            stringify!(BuiltinRootTable)
        )
    );
}
pub type OBJECT_HANDLE_TABLE = _OBJECT_HANDLE_TABLE;
pub type POBJECT_HANDLE_TABLE = *mut _OBJECT_HANDLE_TABLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNFREE {
    pub PackedPfnFlink: USHORT,
    pub PackedPfnBlink: USHORT,
}
#[test]
fn bindgen_test_layout__MMPFNFREE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNFREE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNFREE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNFREE>(),
        2usize,
        concat!("Alignment of ", stringify!(_MMPFNFREE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnFlink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnFlink)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PackedPfnBlink) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNFREE),
            "::",
            stringify!(PackedPfnBlink)
        )
    );
}
pub type MMPFNFREE = _MMPFNFREE;
pub type PMMPFNFREE = *mut _MMPFNFREE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPFNREGION {
    pub FreePagesByColor: [MMPFNFREE; 32usize],
    pub AvailablePages: PFN_COUNT,
}
#[test]
fn bindgen_test_layout__MMPFNREGION() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPFNREGION> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPFNREGION>(),
        132usize,
        concat!("Size of: ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPFNREGION>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPFNREGION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FreePagesByColor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(FreePagesByColor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPFNREGION),
            "::",
            stringify!(AvailablePages)
        )
    );
}
pub type MMPFNREGION = _MMPFNREGION;
pub type PMMPFNREGION = *mut _MMPFNREGION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTE {
    pub __bindgen_anon_1: _MMPTE__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _MMPTE__bindgen_ty_1 {
    pub Long: ULONG,
    pub Hard: HARDWARE_PTE,
    pub List: _MMPTE__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_MMPTE__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _MMPTE__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Valid(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Valid(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OneEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OneEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONG {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONG) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Valid: ULONG,
        OneEntry: ULONG,
        NextEntry: ULONG,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Valid: u32 = unsafe { ::core::mem::transmute(Valid) };
            Valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let OneEntry: u32 = unsafe { ::core::mem::transmute(OneEntry) };
            OneEntry as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let NextEntry: u32 = unsafe { ::core::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__MMPTE__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTE__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Long) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Long)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hard) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(Hard)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).List) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTE__bindgen_ty_1),
            "::",
            stringify!(List)
        )
    );
}
#[test]
fn bindgen_test_layout__MMPTE() {
    assert_eq!(
        ::core::mem::size_of::<_MMPTE>(),
        4usize,
        concat!("Size of: ", stringify!(_MMPTE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTE))
    );
}
pub type MMPTE = _MMPTE;
pub type PMMPTE = *mut _MMPTE;
pub const _MMPFN_BUSY_TYPE_MmUnknownUsage: _MMPFN_BUSY_TYPE = 0;
pub const _MMPFN_BUSY_TYPE_MmStackUsage: _MMPFN_BUSY_TYPE = 1;
pub const _MMPFN_BUSY_TYPE_MmVirtualPageTableUsage: _MMPFN_BUSY_TYPE = 2;
pub const _MMPFN_BUSY_TYPE_MmSystemPageTableUsage: _MMPFN_BUSY_TYPE = 3;
pub const _MMPFN_BUSY_TYPE_MmPoolUsage: _MMPFN_BUSY_TYPE = 4;
pub const _MMPFN_BUSY_TYPE_MmVirtualMemoryUsage: _MMPFN_BUSY_TYPE = 5;
pub const _MMPFN_BUSY_TYPE_MmSystemMemoryUsage: _MMPFN_BUSY_TYPE = 6;
pub const _MMPFN_BUSY_TYPE_MmImageUsage: _MMPFN_BUSY_TYPE = 7;
pub const _MMPFN_BUSY_TYPE_MmFsCacheUsage: _MMPFN_BUSY_TYPE = 8;
pub const _MMPFN_BUSY_TYPE_MmContiguousUsage: _MMPFN_BUSY_TYPE = 9;
pub const _MMPFN_BUSY_TYPE_MmDebuggerUsage: _MMPFN_BUSY_TYPE = 10;
pub const _MMPFN_BUSY_TYPE_MmMaximumUsage: _MMPFN_BUSY_TYPE = 11;
pub type _MMPFN_BUSY_TYPE = libc::c_int;
pub use self::_MMPFN_BUSY_TYPE as MMPFN_BUSY_TYPE;
pub type PMMREMOVE_PAGE_ROUTINE = ::core::option::Option<
    unsafe extern "fastcall" fn(BusyType: MMPFN_BUSY_TYPE, TargetPte: PMMPTE) -> PFN_NUMBER,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _MMPTERANGE {
    pub HeadPte: MMPTE,
    pub FirstCommittedPte: PMMPTE,
    pub LastCommittedPte: PMMPTE,
    pub LastReservedPte: PMMPTE,
    pub AvailablePages: *mut PFN_COUNT,
    pub RemovePageRoutine: PMMREMOVE_PAGE_ROUTINE,
}
#[test]
fn bindgen_test_layout__MMPTERANGE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMPTERANGE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMPTERANGE>(),
        24usize,
        concat!("Size of: ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMPTERANGE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMPTERANGE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HeadPte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(HeadPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FirstCommittedPte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(FirstCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastCommittedPte) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastCommittedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LastReservedPte) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(LastReservedPte)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RemovePageRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMPTERANGE),
            "::",
            stringify!(RemovePageRoutine)
        )
    );
}
pub type MMPTERANGE = _MMPTERANGE;
pub type PMMPTERANGE = *mut _MMPTERANGE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMADDRESS_NODE {
    pub StartingVpn: ULONG_PTR,
    pub EndingVpn: ULONG_PTR,
    pub Parent: *mut _MMADDRESS_NODE,
    pub LeftChild: *mut _MMADDRESS_NODE,
    pub RightChild: *mut _MMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMADDRESS_NODE() {
    const UNINIT: ::core::mem::MaybeUninit<_MMADDRESS_NODE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMADDRESS_NODE>(),
        20usize,
        concat!("Size of: ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMADDRESS_NODE>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMADDRESS_NODE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingVpn) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(StartingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).EndingVpn) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(EndingVpn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Parent) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(Parent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).LeftChild) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(LeftChild)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RightChild) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMADDRESS_NODE),
            "::",
            stringify!(RightChild)
        )
    );
}
pub type MMADDRESS_NODE = _MMADDRESS_NODE;
pub type PMMADDRESS_NODE = *mut _MMADDRESS_NODE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MMGLOBALDATA {
    pub RetailPfnRegion: PMMPFNREGION,
    pub SystemPteRange: PMMPTERANGE,
    pub AvailablePages: PULONG,
    pub AllocatedPagesByUsage: *mut PFN_COUNT,
    pub AddressSpaceLock: PRTL_CRITICAL_SECTION,
    pub VadRoot: *mut PMMADDRESS_NODE,
    pub VadHint: *mut PMMADDRESS_NODE,
    pub VadFreeHint: *mut PMMADDRESS_NODE,
}
#[test]
fn bindgen_test_layout__MMGLOBALDATA() {
    const UNINIT: ::core::mem::MaybeUninit<_MMGLOBALDATA> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_MMGLOBALDATA>(),
        32usize,
        concat!("Size of: ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        ::core::mem::align_of::<_MMGLOBALDATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_MMGLOBALDATA))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RetailPfnRegion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(RetailPfnRegion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SystemPteRange) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(SystemPteRange)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AvailablePages) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AvailablePages)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AllocatedPagesByUsage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AllocatedPagesByUsage)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).AddressSpaceLock) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(AddressSpaceLock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadRoot) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadRoot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadHint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadHint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).VadFreeHint) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_MMGLOBALDATA),
            "::",
            stringify!(VadFreeHint)
        )
    );
}
pub type MMGLOBALDATA = _MMGLOBALDATA;
pub type PMMGLOBALDATA = *mut _MMGLOBALDATA;
pub type PIDE_INTERRUPT_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_FINISHIO_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_POLL_RESET_COMPLETE_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn() -> BOOLEAN>;
pub type PIDE_TIMEOUT_EXPIRED_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
pub type PIDE_START_PACKET_ROUTINE =
    ::core::option::Option<unsafe extern "stdcall" fn(DeviceObject: PDEVICE_OBJECT, Irp: PIRP)>;
pub type PIDE_START_NEXT_PACKET_ROUTINE = ::core::option::Option<unsafe extern "stdcall" fn()>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IDE_CHANNEL_OBJECT {
    pub InterruptRoutine: PIDE_INTERRUPT_ROUTINE,
    pub FinishIoRoutine: PIDE_FINISHIO_ROUTINE,
    pub PollResetCompleteRoutine: PIDE_POLL_RESET_COMPLETE_ROUTINE,
    pub TimeoutExpiredRoutine: PIDE_TIMEOUT_EXPIRED_ROUTINE,
    pub StartPacketRoutine: PIDE_START_PACKET_ROUTINE,
    pub StartNextPacketRoutine: PIDE_START_NEXT_PACKET_ROUTINE,
    pub InterruptIrql: KIRQL,
    pub ExpectingBusMasterInterrupt: BOOLEAN,
    pub StartPacketBusy: BOOLEAN,
    pub StartPacketRequested: BOOLEAN,
    pub Timeout: UCHAR,
    pub IoRetries: UCHAR,
    pub MaximumIoRetries: UCHAR,
    pub CurrentIrp: PIRP,
    pub DeviceQueue: KDEVICE_QUEUE,
    pub PhysicalRegionDescriptorTablePhysical: ULONG,
    pub TimerDpc: KDPC,
    pub FinishDpc: KDPC,
    pub Timer: KTIMER,
    pub InterruptObject: KINTERRUPT,
}
#[test]
fn bindgen_test_layout__IDE_CHANNEL_OBJECT() {
    const UNINIT: ::core::mem::MaybeUninit<_IDE_CHANNEL_OBJECT> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_IDE_CHANNEL_OBJECT>(),
        264usize,
        concat!("Size of: ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        ::core::mem::align_of::<_IDE_CHANNEL_OBJECT>(),
        8usize,
        concat!("Alignment of ", stringify!(_IDE_CHANNEL_OBJECT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptRoutine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishIoRoutine) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishIoRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PollResetCompleteRoutine) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PollResetCompleteRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimeoutExpiredRoutine) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimeoutExpiredRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRoutine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartNextPacketRoutine) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartNextPacketRoutine)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptIrql) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptIrql)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).ExpectingBusMasterInterrupt) as usize - ptr as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(ExpectingBusMasterInterrupt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketBusy) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketBusy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartPacketRequested) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(StartPacketRequested)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timeout) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).IoRetries) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(IoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MaximumIoRetries) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(MaximumIoRetries)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).CurrentIrp) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(CurrentIrp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).DeviceQueue) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(DeviceQueue)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).PhysicalRegionDescriptorTablePhysical) as usize
                - ptr as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(PhysicalRegionDescriptorTablePhysical)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TimerDpc) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(TimerDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).FinishDpc) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(FinishDpc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Timer) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(Timer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).InterruptObject) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IDE_CHANNEL_OBJECT),
            "::",
            stringify!(InterruptObject)
        )
    );
}
pub type IDE_CHANNEL_OBJECT = _IDE_CHANNEL_OBJECT;
pub type PIDE_CHANNEL_OBJECT = *mut _IDE_CHANNEL_OBJECT;
pub type PKSYSTEM_ROUTINE = ::core::option::Option<
    unsafe extern "stdcall" fn(StartRoutine: PKSTART_ROUTINE, StartContext: PVOID),
>;
extern "stdcall" {
    #[doc = " Decrements the reference count of the section and unloads it if the reference count reaches zero.\n @param Section The section to be unloaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeUnloadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XePublicKeyData: [UCHAR; 284usize];
}
extern "stdcall" {
    #[doc = " Loads the supplied section into memory or increases its reference count if it's already loaded.\n @param Section The section to be loaded.\n @return STATUS_SUCCESS or the error."]
    pub fn XeLoadSection(Section: PXBE_SECTION_HEADER) -> NTSTATUS;
}
extern "C" {
    pub static mut XeImageFileName: [ANSI_STRING; 1usize];
}
extern "stdcall" {
    pub fn XcVerifyPKCS1Signature(pbSig: PUCHAR, pbPubKey: PUCHAR, pbDigest: PUCHAR) -> BOOLEAN;
}
extern "stdcall" {
    pub fn XcUpdateCrypto(pNewVector: PCRYPTO_VECTOR, pROMVector: PCRYPTO_VECTOR);
}
extern "stdcall" {
    #[doc = " Updates the internal state of the SHA-1 algorithm by hashing some input data.\n @param pbSHAContext A pointer to the buffer holding the internal state of the algorithm\n @param pbInput A pointer to the bytes which are to get hashed\n @oaram dwInputLength The number of bytes in the buffer given in the pbInput parameter"]
    pub fn XcSHAUpdate(pbSHAContext: PUCHAR, pbInput: PUCHAR, dwInputLength: ULONG);
}
extern "stdcall" {
    #[doc = " Initializes a buffer which will get used to generate a SHA-1 hash.\n @param pbSHAContext A pointer to a 116-byte buffer to be used as storage for the internal state of the algorithm"]
    pub fn XcSHAInit(pbSHAContext: PUCHAR);
}
extern "stdcall" {
    #[doc = " Extracts the final SHA-1 hash from the buffer used to calculate the hash.\n @param pbSHAContext A pointer to the buffer used to hold the internal state of the algorithm\n @param pbDigest A pointer to a 20-byte buffer in which the hash will be stored"]
    pub fn XcSHAFinal(pbSHAContext: PUCHAR, pbDigest: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Key(pbKeyStruct: PUCHAR, dwKeyLength: ULONG, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcRC4Crypt(pbKeyStruct: PUCHAR, dwInputLength: ULONG, pbInput: PUCHAR);
}
extern "stdcall" {
    pub fn XcPKGetKeyLen(pbPubKey: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKEncPublic(pbPubKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcPKDecPrivate(pbPrvKey: PUCHAR, pbInput: PUCHAR, pbOutput: PUCHAR) -> ULONG;
}
extern "stdcall" {
    pub fn XcModExp(pA: PULONG, pB: PULONG, pC: PULONG, pD: PULONG, dwN: ULONG) -> ULONG;
}
extern "stdcall" {
    pub fn XcKeyTable(dwCipher: ULONG, pbKeyTable: PUCHAR, pbKey: PUCHAR);
}
extern "stdcall" {
    pub fn XcHMAC(
        pbKey: PUCHAR,
        dwKeyLength: ULONG,
        pbInput: PUCHAR,
        dwInputLength: ULONG,
        pbInput2: PUCHAR,
        dwInputLength2: ULONG,
        pbDigest: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcDESKeyParity(pbKey: PUCHAR, dwKeyLength: ULONG);
}
extern "stdcall" {
    pub fn XcCryptService(dwOp: ULONG, pArgs: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn XcBlockCryptCBC(
        dwCipher: ULONG,
        dwInputLength: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
        pbFeedback: PUCHAR,
    );
}
extern "stdcall" {
    pub fn XcBlockCrypt(
        dwCipher: ULONG,
        pbOutput: PUCHAR,
        pbInput: PUCHAR,
        pbKeyTable: PUCHAR,
        dwOp: ULONG,
    );
}
extern "C" {
    pub static mut XboxSignatureKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxLANKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxKrnlVersion: XBOX_KRNL_VERSION;
}
extern "C" {
    pub static mut XboxHardwareInfo: XBOX_HARDWARE_INFO;
}
extern "C" {
    pub static mut XboxHDKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxEEPROMKey: XBOX_KEY_DATA;
}
extern "C" {
    pub static mut XboxAlternateSignatureKeys: [XBOX_KEY_DATA; 0usize];
}
extern "stdcall" {
    #[doc = " Writes a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Writes a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer containing the values to be written.\n @param Count Specifies the number of values to be written to the port."]
    pub fn WRITE_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with zeroes\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled"]
    pub fn RtlZeroMemory(Destination: *mut VOID, Length: SIZE_T);
}
extern "stdcall" {
    pub fn RtlWalkFrameChain(Callers: *mut PVOID, Count: ULONG, Flags: ULONG) -> ULONG;
}
extern "C" {
    pub fn RtlVsprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlVsnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlUpperString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Returns the uppercased equivalent of a single character\n @param Character The character which will be converted\n @return The uppercased character"]
    pub fn RtlUpperChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUpcaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    #[doc = " Initiates an unwind of procedure call frames\n THIS FUNCTION IS NOT SAFE TO CALL FROM C CODE! It does not follow the stdcall convention and trashes registers that are supposed to be callee-saved.\n @param TargetFrame A pointer to the call frame that is the target of the unwind. If this parameter is NULL, the function performs an exit unwind.\n @param TargetIp The continuation address of the unwind. If NULL, the function will return normally. This parameter is ignored if TargetFrame is NULL.\n @param ExceptionRecord A pointer to an EXCEPTION_RECORD structure.\n @param ReturnValue A value to be placed in the integer function return register before continuing execution."]
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteSize(
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlUnicodeToMultiByteN(
        MultiByteString: PCHAR,
        MaxBytesInMultiByteString: ULONG,
        BytesInMultiByteString: PULONG,
        UnicodeString: PWSTR,
        BytesInUnicodeString: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn RtlUnicodeStringToInteger(
        String: PUNICODE_STRING,
        Base: ULONG,
        Value: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified Unicode source string into an ANSI string.\n @param DestinationString A pointer to an ANSI_STRING structure to hold the converted ANSI string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the UNICODE_STRING structure that contains the source string to be converted to ANSI.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeAnsiString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlUnicodeStringToAnsiString(
        DestinationString: PSTRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Attempts to enter a critical section without blocking. If the call is successful, the calling thread takes ownership of the critical section.\n @param CriticalSection A pointer to the critical section object.\n @return If the critical section is successfully entered or the current thread already owns the critical section, the return value is nonzero. If another thread already owns the critical section, the return value is zero."]
    pub fn RtlTryEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " The RtlTimeToTimeFields routine converts system time into a TIME_FIELDS structure\n @param Time Pointer to a buffer containing the absolute system time as a large integer, accurate to 100-nanosecond resolution\n @param TimeFields Pointer to a caller-allocated buffer, which must be at least sizeof(TIME_FIELDS), to contain the returned information"]
    pub fn RtlTimeToTimeFields(Time: PLARGE_INTEGER, TimeFields: PTIME_FIELDS);
}
extern "stdcall" {
    pub fn RtlTimeFieldsToTime(TimeFields: PTIME_FIELDS, Time: PLARGE_INTEGER) -> BOOLEAN;
}
extern "C" {
    pub fn RtlSprintf(arg1: *mut CHAR, arg2: *const CHAR, ...);
}
extern "C" {
    pub fn RtlSnprintf(arg1: *mut CHAR, arg2: SIZE_T, arg3: *const CHAR, ...);
}
extern "stdcall" {
    pub fn RtlRip(ApiName: PVOID, Expression: PVOID, Message: PVOID);
}
extern "stdcall" {
    pub fn RtlRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn RtlRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    pub fn RtlNtStatusToDosError(Status: NTSTATUS) -> ULONG;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeSize(
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMultiByteToUnicodeN(
        UnicodeString: PWSTR,
        MaxBytesInUnicodeString: ULONG,
        BytesInUnicodeString: PULONG,
        MultiByteString: PCHAR,
        BytesInMultiByteString: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlMoveMemory(Destination: PVOID, Source: *const PVOID, Length: ULONG);
}
extern "stdcall" {
    pub fn RtlMapGenericMask(AccessMask: PACCESS_MASK, GenericMapping: PGENERIC_MAPPING);
}
extern "stdcall" {
    #[doc = " Returns the lowercase equivalent of a single character\n @param Character The character which will be converted\n @return The lowercased character"]
    pub fn RtlLowerChar(Character: CHAR) -> CHAR;
}
extern "stdcall" {
    pub fn RtlLeaveCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Releases ownership of the specified critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlLeaveCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlIntegerToUnicodeString(
        Value: ULONG,
        Base: ULONG,
        String: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlIntegerToChar(Value: ULONG, Base: ULONG, OutputLength: LONG, String: PSZ)
        -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initializes a critical section object.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlInitializeCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of Unicode characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the UNICODE_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PCWSTR);
}
extern "stdcall" {
    #[doc = " Initializes a counted string of ANSI characters. SourceString is used as the buffer, no memory is allocated.\n @param DestinationString A pointer to the ANSI_STRING structure to be initialized.\n @param SourceString A pointer to a null-terminated character string which is used to initialize the counted string structure pointed to by DestinationString."]
    pub fn RtlInitAnsiString(DestinationString: PANSI_STRING, SourceString: PCSZ);
}
extern "stdcall" {
    pub fn RtlGetCallersAddress(CallersAddress: *mut PVOID, CallersCaller: *mut PVOID);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlAnsiStringToUnicodeString.\n @param UnicodeString A pointer to a Unicode string whose buffer was previously allocated by RtlAnsiStringToUnicodeString."]
    pub fn RtlFreeUnicodeString(UnicodeString: PUNICODE_STRING);
}
extern "stdcall" {
    #[doc = " Frees the string buffer allocated by RtlUnicodeStringToAnsiString.\n @param AnsiString A pointer to an ANSI string whose buffer was previously allocated by RtlUnicodeStringToAnsiString."]
    pub fn RtlFreeAnsiString(AnsiString: PANSI_STRING);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with repetitions of a ULONG value\n @param Destination A pointer to the (ULONG-aligned) memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Pattern The ULONG-value with which the memory block will be filled"]
    pub fn RtlFillMemoryUlong(Destination: PVOID, Length: SIZE_T, Pattern: ULONG);
}
extern "stdcall" {
    #[doc = " Fills a specified memory area with a specified value\n @param Destination A pointer to the memory block which is to be filled\n @param Length The length of the memory block which is to be filled\n @param Fill The byte-value with which the memory block will be filled"]
    pub fn RtlFillMemory(Destination: PVOID, Length: ULONG, Fill: UCHAR);
}
extern "stdcall" {
    pub fn RtlExtendedMagicDivide(
        Dividend: LARGE_INTEGER,
        MagicDivisor: LARGE_INTEGER,
        ShiftCount: CCHAR,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedLargeIntegerDivide(
        Dividend: LARGE_INTEGER,
        Divisor: ULONG,
        Remainder: PULONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn RtlExtendedIntegerMultiply(
        Multiplicand: LARGE_INTEGER,
        Multiplier: LONG,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first unicode string\n @param String2 Pointer to the second unicode string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!) for equality\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return TRUE if the strings are equal, FALSE if not"]
    pub fn RtlEqualString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlEnterCriticalSectionAndRegion(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    #[doc = " Waits for ownership of the specified critical section object. The function returns when the calling thread is granted ownership.\n @param CriticalSection A pointer to the critical section object."]
    pub fn RtlEnterCriticalSection(CriticalSection: PRTL_CRITICAL_SECTION);
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PUNICODE_STRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlDowncaseUnicodeChar(SourceCharacter: WCHAR) -> WCHAR;
}
extern "stdcall" {
    pub fn RtlCreateUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PCWSTR,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn RtlCopyUnicodeString(DestinationString: PUNICODE_STRING, SourceString: PUNICODE_STRING);
}
extern "stdcall" {
    pub fn RtlCopyString(DestinationString: PSTRING, SourceString: PSTRING);
}
extern "stdcall" {
    #[doc = " Compares two counted unicode strings (UNICODE_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareUnicodeString(
        String1: PUNICODE_STRING,
        String2: PUNICODE_STRING,
        CaseInSensitive: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    #[doc = " Compares two counted strings (ANSI_STRING objects, NOT C-style strings!)\n @param String1 Pointer to the first string\n @param String2 Pointer to the second string\n @param CaseInSensitive Whether to ignore the case of the strings or not\n @return Zero if the strings are equal, less than zero if String1 is less than String2, greater than zero if String1 is greater than String2"]
    pub fn RtlCompareString(String1: PSTRING, String2: PSTRING, CaseInSensitive: BOOLEAN) -> LONG;
}
extern "stdcall" {
    #[doc = " Returns how many bytes in a block of memory match a specified pattern.\n @param Source Pointer to a block of memory. Must be aligned on a ULONG boundary.\n @param Length Number of bytes over which the comparison should be done. Must be a multiple of sizeof(ULONG).\n @param Pattern Pattern to be compared byte by byte, repeatedly, through the specified memory range.\n @return The number of bytes that were compared and found to be equal. If all bytes compare as equal, the \"Length\"-value is returned. If \"Source\" is not ULONG-aligned or if \"Length\" is not a multiple of sizeof(ULONG), zero is returned."]
    pub fn RtlCompareMemoryUlong(Source: PVOID, Length: SIZE_T, Pattern: ULONG) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Compares two blocks of memory and returns the number of bytes that match.\n @param Source1 A pointer to the first block of memory.\n @param Source2 A pointer to the second block of memory.\n @param Length The number of bytes to compare.\n @return The number of bytes in the two blocks that match. If all bytes match, the \"Length\"-value is returned."]
    pub fn RtlCompareMemory(Source1: *const VOID, Source2: *const VOID, Length: SIZE_T) -> SIZE_T;
}
extern "stdcall" {
    #[doc = " Converts a single-byte character string (C-style string, NOT an ANSI_STRING object!) to an integer value\n @param String Pointer to a null-terminated single-byte string\n @param Base Specifies the base (decimal, binary, octal, hexadecimal). If not given, the routine looks for prefixes in the given string (0x, 0o, 0b), default is decimal.\n @param Value Pointer to a ULONG variable where the converted value will be stored\n @return STATUS_SUCCESS if the string was successfully converted, STATUS_INVALID_PARAMETER otherwise"]
    pub fn RtlCharToInteger(String: PCSZ, Base: ULONG, Value: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: ULONG,
        FramesToCapture: ULONG,
        BackTrace: *mut PVOID,
        BackTraceHash: PULONG,
    ) -> USHORT;
}
extern "stdcall" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "stdcall" {
    #[doc = " Reports a failed assertion to an attached debugger.\n @param FailedAssertion A string containing the expression that made the assertion fail\n @param FileName A string containing the name of the file containing the assertion\n @param LineNumber The linenumber containing the assertion\n @param Message An optional message (will also be shown by the debugger)"]
    pub fn RtlAssert(FailedAssertion: PVOID, FileName: PVOID, LineNumber: ULONG, Message: PCHAR);
}
extern "stdcall" {
    pub fn RtlAppendUnicodeToString(Destination: PUNICODE_STRING, Source: PCWSTR) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendUnicodeStringToString(
        Destination: PUNICODE_STRING,
        Source: PUNICODE_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn RtlAppendStringToString(Destination: PSTRING, Source: PSTRING) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Converts the specified ANSI source string into a Unicode string.\n @param DestinationString A pointer to a UNICODE_STRING structure to hold the converted Unicode string. If AllocateDestinationString is TRUE, the routine allocates a new buffer to hold the string data and updates the Buffer member of DestinationString to point to the new buffer. Otherwise, the routine uses the currently specified buffer to hold the string.\n @param SourceString Pointer to the ANSI_STRING structure that contains the source string to be converted to Unicode.\n @param AllocateDestinationString If TRUE, this function allocates a buffer for the destination string which must be deallocated by using RtlFreeUnicodeString. If FALSE, the buffer specified in DestinationString will be used instead.\n @return STATUS_SUCCESS if the conversion was successfull, otherwise an NTSTATUS error code."]
    pub fn RtlAnsiStringToUnicodeString(
        DestinationString: PUNICODE_STRING,
        SourceString: PSTRING,
        AllocateDestinationString: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Reads a number of USHORT values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUSHORT)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_USHORT(Port: PUSHORT, Buffer: PUSHORT, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of ULONG values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PULONG)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_ULONG(Port: PULONG, Buffer: PULONG, Count: ULONG);
}
extern "stdcall" {
    #[doc = " Reads a number of UCHAR values from the specified port address into a buffer.\n @param Port The memory mapped I/O address of the port. E.g., `(PUCHAR)0x0cf8` for port 0x0CF8.\n @param Buffer Pointer to a buffer into which the array of values will be written.\n @param Count Specifies the number of values to be read from the port and written into the buffer."]
    pub fn READ_PORT_BUFFER_UCHAR(Port: PUCHAR, Buffer: PUCHAR, Count: ULONG);
}
extern "C" {
    pub static mut PsThreadObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn PsTerminateSystemThread(ExitStatus: NTSTATUS) -> !;
}
extern "stdcall" {
    pub fn PsSetCreateThreadNotifyRoutine(NotifyRoutine: PCREATE_THREAD_NOTIFY_ROUTINE)
        -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsQueryStatistics(ProcessStatistics: PPS_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThreadEx(
        ThreadHandle: PHANDLE,
        ThreadExtensionSize: SIZE_T,
        KernelStackSize: SIZE_T,
        TlsDataSize: SIZE_T,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        CreateSuspended: BOOLEAN,
        DebuggerThread: BOOLEAN,
        SystemRoutine: PKSYSTEM_ROUTINE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn PsCreateSystemThread(
        ThreadHandle: PHANDLE,
        ThreadId: PHANDLE,
        StartRoutine: PKSTART_ROUTINE,
        StartContext: PVOID,
        DebuggerThread: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Initialize the ethernet PHY\n @param forceReset Whether to force a reset\n @param param Optional parameters (seemingly unused)\n @return Status code (zero on success)"]
    pub fn PhyInitialize(forceReset: BOOLEAN, param: PVOID) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Returns link status information either from NIC registers or from the last value cached by the kernel\n @param update If FALSE, the kernel returns the cached value, otherwise the hardware is polled and the cached value updated\n @return Flags describing the status of the NIC. See XNET_ETHERNET_LINK bit masks."]
    pub fn PhyGetLinkState(update: BOOLEAN) -> DWORD;
}
extern "C" {
    pub static mut ObpObjectHandleTable: OBJECT_HANDLE_TABLE;
}
extern "C" {
    pub static mut ObSymbolicLinkObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObReferenceObjectByPointer(Object: PVOID, ObjectType: POBJECT_TYPE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByName(
        ObjectName: POBJECT_STRING,
        Attributes: ULONG,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObReferenceObjectByHandle(
        Handle: HANDLE,
        ObjectType: POBJECT_TYPE,
        ReturnedObject: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByPointer(
        Object: PVOID,
        ObjectType: POBJECT_TYPE,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObOpenObjectByName(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectType: POBJECT_TYPE,
        ParseContext: PVOID,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ObMakeTemporaryObject(Object: PVOID);
}
extern "stdcall" {
    pub fn ObInsertObject(
        Object: PVOID,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectPointerBias: ULONG,
        Handle: PHANDLE,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ObDirectoryObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ObCreateObject(
        ObjectType: POBJECT_TYPE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        ObjectBodySize: ULONG,
        Object: *mut PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " yields execution of the current thread for one timeslice"]
    pub fn NtYieldExecution() -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtWriteFileGather(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtWriteFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". Also see NtWaitForSingleObject.\n @param Handle The handle to the wait object.\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObjectEx(
        Handle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified object attains a state of \"signaled\". When used with a semaphore, the semaphore gets decremented and the threaad continues, or the thread waits until the semaphore-count becomes non-zero and then decrements the seamphore count and continues.\n @param Handle The handle to the wait object.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. Can be STATUS_SUCCESS (specified object satisifed the wait), STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForSingleObject(
        Handle: HANDLE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Waits until the specified objects attain a state of \"signaled\". The wait can be specified to either wait until all objects are signaled or until one of the objects is signaled. Also see NtWaitForSingleObject.\n @param Count Specifies the number of objects that are to be waited on.\n @param Handles An array of handles to wait objects.\n @param WaitType Specifies the type of wait to perform (WaitAll or WaitAny)\n @param WaitMode Specifies the processor mode in which the wait is to occur.\n @param Alertable Specifies whether an alert can be delivered when the object is waiting (watch out for the STATUS_ALERTED return value).\n @param Timeout An optional (set to NULL when not used) pointer to an absolute or relative time over which the wait is to occur. If an explicit timeout value of zero is specified, then no wait occurs if the wait cannot be satisfied immediately.\n @return The wait completion status. The index of the object in the array that satisfied the wait is returned. Can also be STATUS_TIMEOUT (a timeout occured), STATUS_ALERTED (the wait was aborted to deliver an alert to the current thread) or STATUS_USER_APC (the wait was aborted to deliver a user APC to the current thread)."]
    pub fn NtWaitForMultipleObjectsEx(
        Count: ULONG,
        Handles: *const HANDLE,
        WaitType: WAIT_TYPE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtUserIoApcDispatcher(
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Reserved: ULONG,
    );
}
extern "stdcall" {
    #[doc = " Suspends the target thread and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to suspend.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtSuspendThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSignalAndWaitForSingleObjectEx(
        SignalHandle: HANDLE,
        WaitHandle: HANDLE,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetTimerEx(
        TimerHandle: HANDLE,
        DueTime: PLARGE_INTEGER,
        TimerApcRoutine: PTIMER_APC_ROUTINE,
        ApcMode: KPROCESSOR_MODE,
        TimerContext: PVOID,
        ResumeTimer: BOOLEAN,
        Period: LONG,
        PreviousState: PBOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets the current system time and optionally returns the old system time.\n @param SystemTime A pointer to the new value for the system time.\n @param PreviousTime An optional pointer to a variable that receives the previous system time.\n @return The status of the operation. STATUS_SUCCESS when successfull, STATUS_ACCESS_VIOLATION if the input parameter cannot be read or the output cannot be written, STATUS_INVALID_PARAMETER if the input time is negative."]
    pub fn NtSetSystemTime(SystemTime: PLARGE_INTEGER, PreviousTime: PLARGE_INTEGER) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtSetInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state.\n @param EventHandle A HANDLE to the event object to be set.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtSetEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resumes the target thread (see NtSuspendThread) and optionally returns the previous suspend count.\n @param ThreadHandle The handle of the thread object to resume.\n @param PreviousSuspendCount Optional pointer to a variable that receives the thread's previous suspend count.\n @return The status of the operation."]
    pub fn NtResumeThread(ThreadHandle: HANDLE, PreviousSuspendCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtRemoveIoCompletion(
        IoCompletionHandle: HANDLE,
        KeyContext: *mut PVOID,
        ApcContext: *mut PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a semaphore object. When the semaphore is released, the current count of the semaphore is incremented by \"ReleaseCount\". Any threads that are waiting for the semaphore are examined to see if the current semaphore value is sufficient to satisfy their wait. If the value specified by \"ReleaseCount\" would cause the maximum count for the semaphore to be exceeded, then the count for the semaphore is not affected and an error status is returned.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param ReleaseCount The release count for the semaphore. The count must be greater than zero and less than the maximum value specified for the semaphore.\n @param PreviousCount An optional pointer to a variable that receives the previous count for the semaphore.\n @return The status of the release operation, STATUS_SUCCESS on success."]
    pub fn NtReleaseSemaphore(
        SemaphoreHandle: HANDLE,
        ReleaseCount: LONG,
        PreviousCount: PLONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Releases a mutant object (mutex).\n @param MutantHandle The handle to the mutant object.\n @param PreviousCount An optional pointer to a variable that receives the previous mutant count.\n @return The status of the operation."]
    pub fn NtReleaseMutant(MutantHandle: HANDLE, PreviousCount: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFileScatter(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        SegmentArray: PFILE_SEGMENT_ELEMENT,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtReadFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        Length: ULONG,
        ByteOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueueApcThread(
        ThreadHandle: HANDLE,
        ApcRoutine: PPS_APC_ROUTINE,
        ApcArgument1: PVOID,
        ApcArgument2: PVOID,
        ApcArgument3: PVOID,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVolumeInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsInformation: PVOID,
        Length: ULONG,
        FsInformationClass: FS_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryVirtualMemory(
        BaseAddress: PVOID,
        MemoryInformation: PMEMORY_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryTimer(
        TimerHandle: HANDLE,
        TimerInformation: PTIMER_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQuerySymbolicLinkObject(
        LinkHandle: HANDLE,
        LinkTarget: POBJECT_STRING,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a semaphore object.\n @param SemaphoreHandle An open handle to a semaphore object.\n @param SemaphoreInformation A pointer to a buffer (SEMAPHORE_BASIC_INFORMATION-structure) that receives the queried information.\n @return The status code of the query operation, STATUS_SUCCESS on success."]
    pub fn NtQuerySemaphore(
        SemaphoreHandle: HANDLE,
        SemaphoreInformation: PSEMAPHORE_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Queries the state of a mutant object.\n @param MutantHandle A handle to a mutant object.\n @param MutantInformation A pointer to a MUTANT_BASIC_INFORMATION-structure that receives the requested information.\n @return The status of the operation."]
    pub fn NtQueryMutant(
        MutantHandle: HANDLE,
        MutantInformation: PMUTANT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryIoCompletion(
        IoCompletionHandle: HANDLE,
        IoCompletionInformation: PIO_COMPLETION_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryInformationFile(
        FileHandle: HANDLE,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryFullAttributesFile(
        ObjectAttributes: POBJECT_ATTRIBUTES,
        FileInformation: PFILE_NETWORK_OPEN_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryEvent(
        EventHandle: HANDLE,
        EventInformation: PEVENT_BASIC_INFORMATION,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryObject(
        DirectoryHandle: HANDLE,
        Buffer: PVOID,
        Length: ULONG,
        RestartScan: BOOLEAN,
        Context: PULONG,
        ReturnLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtQueryDirectoryFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FileInformation: PVOID,
        Length: ULONG,
        FileInformationClass: FILE_INFORMATION_CLASS,
        FileName: POBJECT_STRING,
        RestartScan: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Sets an event to the signaled state, and immediately resets it to the non-signaled state after waking all waiting threads.\n @param EventHandle A HANDLE to the event object to be pulsed.\n @param PreviousState An optional pointer to a variable that will get set to the previous state of the event object.\n @return STATUS_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtPulseEvent(EventHandle: HANDLE, PreviousState: PLONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtProtectVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        NewProtect: ULONG,
        OldProtect: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenSymbolicLinkObject(
        LinkHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        ShareAccess: ULONG,
        OpenOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtOpenDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFsControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        FsControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFreeVirtualMemory(
        BaseAddress: *mut PVOID,
        RegionSize: PSIZE_T,
        FreeType: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtFlushBuffersFile(FileHandle: HANDLE, IoStatusBlock: PIO_STATUS_BLOCK) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDuplicateObject(
        SourceHandle: HANDLE,
        TargetHandle: PHANDLE,
        Options: ULONG,
    ) -> NTSTATUS;
}
pub const _MEDIA_TYPE_Unknown: _MEDIA_TYPE = 0;
pub const _MEDIA_TYPE_F5_1Pt2_512: _MEDIA_TYPE = 1;
pub const _MEDIA_TYPE_F3_1Pt44_512: _MEDIA_TYPE = 2;
pub const _MEDIA_TYPE_F3_2Pt88_512: _MEDIA_TYPE = 3;
pub const _MEDIA_TYPE_F3_20Pt8_512: _MEDIA_TYPE = 4;
pub const _MEDIA_TYPE_F3_720_512: _MEDIA_TYPE = 5;
pub const _MEDIA_TYPE_F5_360_512: _MEDIA_TYPE = 6;
pub const _MEDIA_TYPE_F5_320_512: _MEDIA_TYPE = 7;
pub const _MEDIA_TYPE_F5_320_1024: _MEDIA_TYPE = 8;
pub const _MEDIA_TYPE_F5_180_512: _MEDIA_TYPE = 9;
pub const _MEDIA_TYPE_F5_160_512: _MEDIA_TYPE = 10;
pub const _MEDIA_TYPE_RemovableMedia: _MEDIA_TYPE = 11;
pub const _MEDIA_TYPE_FixedMedia: _MEDIA_TYPE = 12;
pub const _MEDIA_TYPE_F3_120M_512: _MEDIA_TYPE = 13;
pub const _MEDIA_TYPE_F3_640_512: _MEDIA_TYPE = 14;
pub const _MEDIA_TYPE_F5_640_512: _MEDIA_TYPE = 15;
pub const _MEDIA_TYPE_F5_720_512: _MEDIA_TYPE = 16;
pub const _MEDIA_TYPE_F3_1Pt2_512: _MEDIA_TYPE = 17;
pub const _MEDIA_TYPE_F3_1Pt23_1024: _MEDIA_TYPE = 18;
pub const _MEDIA_TYPE_F5_1Pt23_1024: _MEDIA_TYPE = 19;
pub const _MEDIA_TYPE_F3_128Mb_512: _MEDIA_TYPE = 20;
pub const _MEDIA_TYPE_F3_230Mb_512: _MEDIA_TYPE = 21;
pub const _MEDIA_TYPE_F8_256_128: _MEDIA_TYPE = 22;
pub const _MEDIA_TYPE_F3_200Mb_512: _MEDIA_TYPE = 23;
pub const _MEDIA_TYPE_F3_240M_512: _MEDIA_TYPE = 24;
pub const _MEDIA_TYPE_F3_32M_512: _MEDIA_TYPE = 25;
pub type _MEDIA_TYPE = libc::c_int;
pub use self::_MEDIA_TYPE as MEDIA_TYPE;
pub type PMEDIA_TYPE = *mut _MEDIA_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _DISK_GEOMETRY {
    pub Cylinders: LARGE_INTEGER,
    pub MediaType: MEDIA_TYPE,
    pub TracksPerCylinder: DWORD,
    pub SectorsPerTrack: DWORD,
    pub BytesPerSector: DWORD,
}
#[test]
fn bindgen_test_layout__DISK_GEOMETRY() {
    const UNINIT: ::core::mem::MaybeUninit<_DISK_GEOMETRY> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_DISK_GEOMETRY>(),
        24usize,
        concat!("Size of: ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        ::core::mem::align_of::<_DISK_GEOMETRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISK_GEOMETRY))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Cylinders) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(Cylinders)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).MediaType) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(MediaType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).TracksPerCylinder) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(TracksPerCylinder)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).SectorsPerTrack) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(SectorsPerTrack)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerSector) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISK_GEOMETRY),
            "::",
            stringify!(BytesPerSector)
        )
    );
}
pub type DISK_GEOMETRY = _DISK_GEOMETRY;
pub type PDISK_GEOMETRY = *mut _DISK_GEOMETRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PARTITION_INFORMATION {
    pub StartingOffset: LARGE_INTEGER,
    pub PartitionLength: LARGE_INTEGER,
    pub HiddenSectors: DWORD,
    pub PartitionNumber: DWORD,
    pub PartitionType: BYTE,
    pub BootIndicator: BOOLEAN,
    pub RecognizedPartition: BOOLEAN,
    pub RewritePartition: BOOLEAN,
}
#[test]
fn bindgen_test_layout__PARTITION_INFORMATION() {
    const UNINIT: ::core::mem::MaybeUninit<_PARTITION_INFORMATION> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PARTITION_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        ::core::mem::align_of::<_PARTITION_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_PARTITION_INFORMATION))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).StartingOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(StartingOffset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionLength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionLength)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).HiddenSectors) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(HiddenSectors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionNumber) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionNumber)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).PartitionType) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(PartitionType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BootIndicator) as usize - ptr as usize },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(BootIndicator)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RecognizedPartition) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RecognizedPartition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).RewritePartition) as usize - ptr as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(_PARTITION_INFORMATION),
            "::",
            stringify!(RewritePartition)
        )
    );
}
pub type PARTITION_INFORMATION = _PARTITION_INFORMATION;
pub type PPARTITION_INFORMATION = *mut _PARTITION_INFORMATION;
extern "stdcall" {
    pub fn NtDeviceIoControlFile(
        FileHandle: HANDLE,
        Event: HANDLE,
        ApcRoutine: PIO_APC_ROUTINE,
        ApcContext: PVOID,
        IoStatusBlock: PIO_STATUS_BLOCK,
        IoControlCode: ULONG,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtDeleteFile(ObjectAttributes: POBJECT_ATTRIBUTES) -> BOOLEAN;
}
extern "stdcall" {
    pub fn NtCreateTimer(
        TimerHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        TimerType: TIMER_TYPE,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Create a semaphore object with the specified initial and maximum count.\n @param SemaphoreHandle A pointer to a variable that receives the value of the semaphore object handle.\n @param ObjectAttributes An optional pointer to a structure that specifies the object's attributes.\n @param InitialCount The initial count for the semaphore, this value must be positive and less than or equal to the maximum count.\n @param MaximumCount The maximum count for the semaphore, this value must be greater than zero.\n @return STATUS_SUCCESS on success or error code."]
    pub fn NtCreateSemaphore(
        SemaphoreHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialCount: LONG,
        MaximumCount: LONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates a mutant object (mutex), sets its initial count to one (which means \"signaled\"), and opens a handle to the object.\n @param MutantHandle A pointer to a variable that receives the mutant object handle.\n @param ObjectAttributes A pointer to a OBJECT_ATTRIBUTES-structure that specifies object attributes.\n @pararm InitialOwner A boolean value that specifies whether the creator of the mutant object wants immediate ownership.\n @return The status of the operation."]
    pub fn NtCreateMutant(
        MutantHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        InitialOwner: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateIoCompletion(
        IoCompletionHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        Count: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        CreateDisposition: ULONG,
        CreateOptions: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Creates an event object, sets the initial state of the event to the specified value, and opens a handle to the object.\n @param EventHandle A pointer to a variable that will receive the event object handle.\n @param ObjectAttributes A pointer to the object attributes structure supplied by the caller to be used for the specified object.\n @param EventType The type of the event, which can be SynchronizationEvent or a NotificationEvent.\n @param InitialState The initial state of the event object. Set to TRUE to initialize the event object to the Signaled state. Set to FALSE to initialize the event object to the not-Signaled state.\n @return STATUS_SUCCESS when the call is successfull, otherwise an NTSTATUS error code. STATUS_OBJECT_NAME_EXISTS if an event object of the same name already exists and was opened instead of creating a new one."]
    pub fn NtCreateEvent(
        EventHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        EventType: EVENT_TYPE,
        InitialState: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCreateDirectoryObject(
        DirectoryHandle: PHANDLE,
        ObjectAttributes: POBJECT_ATTRIBUTES,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Closes an object handle.\n @param Handle Handle to an object\n @return STATE_SUCCESS on success, error code (e.g. STATUS_INVALID_HANDLE, STATUS_HANDLE_NOT_CLOSABLE) otherwise"]
    pub fn NtClose(Handle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Resets an even object to the non-signaled state.\n @param EventHandle A HANDLE to the event object that is to be reset.\n @return STATE_SUCCESS on success, an NTSTATUS error code otherwise."]
    pub fn NtClearEvent(EventHandle: HANDLE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtCancelTimer(TimerHandle: HANDLE, CurrentState: PBOOLEAN) -> NTSTATUS;
}
extern "stdcall" {
    pub fn NtAllocateVirtualMemory(
        BaseAddress: *mut PVOID,
        ZeroBits: ULONG_PTR,
        RegionSize: PSIZE_T,
        AllocationType: ULONG,
        Protect: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmUnmapIoSpace(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn MmSetAddressProtect(BaseAddress: PVOID, NumberOfBytes: ULONG, NewProtect: ULONG);
}
extern "stdcall" {
    pub fn MmQueryStatistics(MemoryStatistics: PMM_STATISTICS) -> NTSTATUS;
}
extern "stdcall" {
    pub fn MmQueryAllocationSize(BaseAddress: PVOID) -> SIZE_T;
}
extern "stdcall" {
    pub fn MmQueryAddressProtect(VirtualAddress: PVOID) -> ULONG;
}
extern "stdcall" {
    #[doc = " Marks a contiguous area of memory to be preserved across a quick reboot.\n @param BaseAddress The virtual address of the memory area.\n @param NumberOfBytes The number of bytes to be preserved.\n @param Persist TRUE if the memory should be persistent, else FALSE."]
    pub fn MmPersistContiguousMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T, Persist: BOOLEAN);
}
extern "stdcall" {
    pub fn MmMapIoSpace(PhysicalAddress: ULONG_PTR, NumberOfBytes: SIZE_T, Protect: ULONG)
        -> PVOID;
}
extern "stdcall" {
    pub fn MmLockUnlockPhysicalPage(PhysicalAddress: ULONG_PTR, UnlockPage: BOOLEAN);
}
extern "stdcall" {
    pub fn MmLockUnlockBufferPages(BaseAddress: PVOID, NumberOfBytes: SIZE_T, UnlockPages: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Checks whether a page fault would occur for a read operation on a specified address.\n @param VirtualAddress The virtual address to be checked.\n @return TRUE if a page fault would occur, FALSE if not."]
    pub fn MmIsAddressValid(VirtualAddress: PVOID) -> BOOLEAN;
}
extern "C" {
    pub static mut MmGlobalData: MMGLOBALDATA;
}
extern "stdcall" {
    #[doc = " Returns the physical address for a virtual address.\n @param BaseAddress A valid virtual address for which the physical address is to be returned.\n @return The corresponding physical address."]
    pub fn MmGetPhysicalAddress(BaseAddress: PVOID) -> ULONG_PTR;
}
extern "stdcall" {
    pub fn MmFreeSystemMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmFreeContiguousMemory(BaseAddress: PVOID);
}
extern "stdcall" {
    pub fn MmDeleteKernelStack(KernelStackBase: PVOID, KernelStackLimit: PVOID);
}
extern "stdcall" {
    pub fn MmDbgWriteCheck(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE) -> PVOID;
}
extern "stdcall" {
    pub fn MmDbgReleaseAddress(VirtualAddress: PVOID, Opaque: PHARDWARE_PTE);
}
extern "stdcall" {
    pub fn MmDbgQueryAvailablePages() -> PFN_COUNT;
}
extern "stdcall" {
    pub fn MmDbgFreeMemory(BaseAddress: PVOID, NumberOfBytes: SIZE_T) -> ULONG;
}
extern "stdcall" {
    pub fn MmDbgAllocateMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmCreateKernelStack(NumberOfBytes: SIZE_T, DebuggerThread: BOOLEAN) -> PVOID;
}
extern "stdcall" {
    pub fn MmClaimGpuInstanceMemory(
        NumberOfBytes: SIZE_T,
        NumberOfPaddingBytes: *mut SIZE_T,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateSystemMemory(NumberOfBytes: SIZE_T, Protect: ULONG) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemoryEx(
        NumberOfBytes: SIZE_T,
        LowestAcceptableAddress: ULONG_PTR,
        HighestAcceptableAddress: ULONG_PTR,
        Alignment: ULONG_PTR,
        Protect: ULONG,
    ) -> PVOID;
}
extern "stdcall" {
    pub fn MmAllocateContiguousMemory(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "C" {
    pub static mut LaunchDataPage: PLAUNCH_DATA_PAGE;
}
extern "C" {
    pub static mut KiBugCheckData: [ULONG; 0usize];
}
extern "stdcall" {
    pub fn KeWaitForSingleObject(
        Object: PVOID,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeWaitForMultipleObjects(
        Count: ULONG,
        Object: *mut PVOID,
        WaitType: WAIT_TYPE,
        WaitReason: KWAIT_REASON,
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Timeout: PLARGE_INTEGER,
        WaitBlockArray: PKWAIT_BLOCK,
    ) -> NTSTATUS;
}
extern "C" {
    pub static KeTimeIncrement: ULONG;
}
extern "C" {
    #[doc = " Contains the number of milliseconds elapsed since the system was started."]
    pub static mut KeTickCount: DWORD;
}
extern "stdcall" {
    pub fn KeTestAlertThread(ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "C" {
    pub static mut KeSystemTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeSynchronizeExecution(
        Interrupt: PKINTERRUPT,
        SynchronizeRoutine: PKSYNCHRONIZE_ROUTINE,
        SynchronizeContext: PVOID,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSuspendThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    #[doc = " Stalls the caller on the current processor for a specified time Interval.\n @param MicroSeconds Specifies the number of microseconds to stall."]
    pub fn KeStallExecutionProcessor(MicroSeconds: ULONG);
}
extern "stdcall" {
    pub fn KeSetTimerEx(
        Timer: PKTIMER,
        DueTime: LARGE_INTEGER,
        Period: LONG,
        Dpc: PKDPC,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeSetTimer(Timer: PKTIMER, DueTime: LARGE_INTEGER, Dpc: PKDPC) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Sets the run-time priority of a thread.\n @param Thread Pointer to the thread.\n @param Priority Specifies the priority of the thread, usually to the real-time priority value, LOW_REALTIME_PRIORITY. The value LOW_PRIORITY is reserved for system use.\n @return Returns the old priority of the thread."]
    pub fn KeSetPriorityThread(Thread: PKTHREAD, Priority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetPriorityProcess(Process: PKPROCESS, BasePriority: KPRIORITY) -> KPRIORITY;
}
extern "stdcall" {
    pub fn KeSetEventBoostPriority(Event: PRKEVENT, Thread: *mut PRKTHREAD);
}
extern "stdcall" {
    pub fn KeSetEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeSetDisableBoostThread(Thread: PKTHREAD, Disable: LOGICAL) -> LOGICAL;
}
extern "stdcall" {
    pub fn KeSetBasePriorityThread(Thread: PKTHREAD, Increment: LONG) -> LONG;
}
extern "stdcall" {
    pub fn KeSaveFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeRundownQueue(Queue: PRKQUEUE) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "stdcall" {
    pub fn KeRestoreFloatingPointState(FloatSave: PKFLOATING_SAVE) -> NTSTATUS;
}
extern "stdcall" {
    pub fn KeResetEvent(Event: PRKEVENT) -> LONG;
}
extern "stdcall" {
    #[doc = " Removes a DPC object from the deferred procedure call queue\n @param Dpc A pointer to the DPC object"]
    pub fn KeRemoveQueueDpc(Dpc: PRKDPC) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveQueue(
        Queue: PRKQUEUE,
        WaitMode: KPROCESSOR_MODE,
        Timeout: PLARGE_INTEGER,
    ) -> PLIST_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveEntryDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeRemoveDeviceQueue(DeviceQueue: PKDEVICE_QUEUE) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeRemoveByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        SortKey: ULONG,
    ) -> PKDEVICE_QUEUE_ENTRY;
}
extern "stdcall" {
    pub fn KeReleaseSemaphore(
        Semaphore: PRKSEMAPHORE,
        Increment: KPRIORITY,
        Adjustment: LONG,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeReleaseMutant(
        Mutant: PRKMUTANT,
        Increment: KPRIORITY,
        Abandoned: BOOLEAN,
        Wait: BOOLEAN,
    ) -> LONG;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToSynchLevel() -> KIRQL;
}
extern "stdcall" {
    pub fn KeRaiseIrqlToDpcLevel() -> KIRQL;
}
extern "stdcall" {
    #[doc = " Obtains the current system time.\n @param CurrentTime The system time in 100-nanosecond intervals since January 1, 1601, in GMT."]
    pub fn KeQuerySystemTime(CurrentTime: PLARGE_INTEGER);
}
extern "stdcall" {
    pub fn KeQueryPerformanceFrequency() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryPerformanceCounter() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryInterruptTime() -> ULONGLONG;
}
extern "stdcall" {
    pub fn KeQueryBasePriorityThread(Thread: PKTHREAD) -> LONG;
}
extern "stdcall" {
    pub fn KePulseEvent(Event: PRKEVENT, Increment: KPRIORITY, Wait: BOOLEAN) -> LONG;
}
extern "stdcall" {
    pub fn KeLeaveCriticalRegion();
}
extern "stdcall" {
    #[doc = " Checks whether the code is executed in a DPC context\n @return TRUE if the code is running in a DPC context, FALSE otherwise"]
    pub fn KeIsExecutingDpc() -> BOOLEAN;
}
extern "C" {
    pub static mut KeInterruptTime: KSYSTEM_TIME;
}
extern "stdcall" {
    pub fn KeInsertQueueDpc(Dpc: PRKDPC, SystemArgument1: PVOID, SystemArgument2: PVOID)
        -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueueApc(
        Apc: PRKAPC,
        SystemArgument1: PVOID,
        SystemArgument2: PVOID,
        Increment: KPRIORITY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertHeadQueue(Queue: PRKQUEUE, Entry: PLIST_ENTRY) -> LONG;
}
extern "stdcall" {
    pub fn KeInsertDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInsertByKeyDeviceQueue(
        DeviceQueue: PKDEVICE_QUEUE,
        DeviceQueueEntry: PKDEVICE_QUEUE_ENTRY,
        SortKey: ULONG,
    ) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeInitializeTimerEx(Timer: PKTIMER, Type: TIMER_TYPE);
}
extern "stdcall" {
    pub fn KeInitializeSemaphore(Semaphore: PRKSEMAPHORE, Count: LONG, Limit: LONG);
}
extern "stdcall" {
    pub fn KeInitializeQueue(Queue: PRKQUEUE, Count: ULONG);
}
extern "stdcall" {
    pub fn KeInitializeMutant(Mutant: PRKMUTANT, InitialOwner: BOOLEAN);
}
extern "stdcall" {
    pub fn KeInitializeInterrupt(
        Interrupt: PKINTERRUPT,
        ServiceRoutine: PKSERVICE_ROUTINE,
        ServiceContext: PVOID,
        Vector: ULONG,
        Irql: KIRQL,
        InterruptMode: KINTERRUPT_MODE,
        ShareVector: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn KeInitializeEvent(Event: PRKEVENT, Type: EVENT_TYPE, State: BOOLEAN);
}
extern "stdcall" {
    #[doc = " Initializes a DPC object describing the parameters for a deferred procedure\n call\n @param Dpc Pointer to a DPC struct that gets initialized\n @param DeferredRoutine Pointer to the function that gets called by the DPC\n @param DeferredContext An arbitrary user-defined pointer that gets passed to the procedure when called"]
    pub fn KeInitializeDpc(
        Dpc: *mut KDPC,
        DeferredRoutine: PKDEFERRED_ROUTINE,
        DeferredContext: PVOID,
    );
}
extern "stdcall" {
    pub fn KeInitializeDeviceQueue(DeviceQueue: PKDEVICE_QUEUE);
}
extern "stdcall" {
    pub fn KeInitializeApc(
        Apc: PRKAPC,
        Thread: PRKTHREAD,
        KernelRoutine: PKKERNEL_ROUTINE,
        RundownRoutine: PKRUNDOWN_ROUTINE,
        NormalRoutine: PKNORMAL_ROUTINE,
        ProcessorMode: KPROCESSOR_MODE,
        NormalContext: PVOID,
    );
}
extern "stdcall" {
    #[doc = " Returns a pointer to the thread object belonging to the current thread.\n @return A pointer to an opaque thread object."]
    pub fn KeGetCurrentThread() -> PKTHREAD;
}
extern "stdcall" {
    pub fn KeGetCurrentIrql() -> KIRQL;
}
extern "stdcall" {
    pub fn KeEnterCriticalRegion();
}
extern "stdcall" {
    pub fn KeDisconnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Puts the current thread into an alertable or nonalertable wait state for a specified interval\n @param WaitMode Specifies the processor mode in which the caller is waiting, which can be either KernelMode or UserMode.\n @param Alertable TRUE if the wait is alertable.\n @param Interval Specifies the absolute or relative time, in units of 100 nanoseconds, for which the wait is to occur. A negative value indicates relative time. Absolute expiration times track any changes in system time, relative expiration times are not affected by system time changes.\n @return STATUS_SUCCESS (the delay completed because the specified interval elapsed), STATUS_ALERTED (the delay completed because the thread was alerted) or STATUS_USER_APC (a user-mode APC was delivered before the specified interval expired)."]
    pub fn KeDelayExecutionThread(
        WaitMode: KPROCESSOR_MODE,
        Alertable: BOOLEAN,
        Interval: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Connects an interrupt object, allowing it to receive interrupts\n @return FALSE if the interrupt is already connected or cannot be connected, TRUE if it was conected successfully"]
    pub fn KeConnectInterrupt(Interrupt: PKINTERRUPT) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeCancelTimer(Timer: PKTIMER) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeBugCheckEx(
        BugCheckCode: ULONG,
        BugCheckParameter1: ULONG_PTR,
        BugCheckParameter2: ULONG_PTR,
        BugCheckParameter3: ULONG_PTR,
        BugCheckParameter4: ULONG_PTR,
    ) -> !;
}
extern "stdcall" {
    pub fn KeBugCheck(BugCheckCode: ULONG) -> !;
}
extern "stdcall" {
    pub fn KeBoostPriorityThread(Thread: PKTHREAD, Increment: KPRIORITY);
}
extern "stdcall" {
    pub fn KeAlertThread(Thread: PKTHREAD, ProcessorMode: KPROCESSOR_MODE) -> BOOLEAN;
}
extern "stdcall" {
    pub fn KeAlertResumeThread(Thread: PKTHREAD) -> ULONG;
}
extern "C" {
    pub static mut KdDebuggerNotPresent: BOOLEAN;
}
extern "C" {
    pub static mut KdDebuggerEnabled: BOOLEAN;
}
extern "stdcall" {
    pub fn IoSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoSynchronousDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        ReturnedOutputBufferLength: PULONG,
        InternalDeviceIoControl: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoStartPacket(DeviceObject: PDEVICE_OBJECT, Irp: PIRP, Key: PULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacketByKey(DeviceObject: PDEVICE_OBJECT, Key: ULONG);
}
extern "stdcall" {
    pub fn IoStartNextPacket(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoSetShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
    );
}
extern "stdcall" {
    pub fn IoSetIoCompletion(
        IoCompletion: PVOID,
        KeyContext: PVOID,
        ApcContext: PVOID,
        IoStatus: NTSTATUS,
        IoStatusInformation: ULONG_PTR,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoRemoveShareAccess(FileObject: PFILE_OBJECT, ShareAccess: PSHARE_ACCESS);
}
extern "stdcall" {
    pub fn IoQueueThreadIrp(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoQueryVolumeInformation(
        FileObject: PFILE_OBJECT,
        FsInformationClass: FS_INFORMATION_CLASS,
        Length: ULONG,
        FsInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoQueryFileInformation(
        FileObject: PFILE_OBJECT,
        FileInformationClass: FILE_INFORMATION_CLASS,
        Length: ULONG,
        FileInformation: PVOID,
        ReturnedLength: PULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoMarkIrpMustComplete(Irp: PIRP);
}
extern "stdcall" {
    pub fn IoInvalidDeviceRequest(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoInitializeIrp(Irp: PIRP, PacketSize: USHORT, StackSize: CCHAR);
}
extern "stdcall" {
    pub fn IoFreeIrp(Irp: PIRP);
}
extern "C" {
    pub static mut IoFileObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDismountVolumeByName(DeviceName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDismountVolume(DeviceObject: PDEVICE_OBJECT) -> NTSTATUS;
}
extern "C" {
    pub static mut IoDeviceObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoDeleteSymbolicLink(SymbolicLinkName: POBJECT_STRING) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoDeleteDevice(DeviceObject: PDEVICE_OBJECT);
}
extern "stdcall" {
    pub fn IoCreateSymbolicLink(
        SymbolicLinkName: POBJECT_STRING,
        DeviceName: POBJECT_STRING,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateFile(
        FileHandle: PHANDLE,
        DesiredAccess: ACCESS_MASK,
        ObjectAttributes: POBJECT_ATTRIBUTES,
        IoStatusBlock: PIO_STATUS_BLOCK,
        AllocationSize: PLARGE_INTEGER,
        FileAttributes: ULONG,
        ShareAccess: ULONG,
        Disposition: ULONG,
        CreateOptions: ULONG,
        Options: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoCreateDevice(
        DriverObject: PDRIVER_OBJECT,
        DeviceExtensionSize: ULONG,
        DeviceName: POBJECT_STRING,
        DeviceType: DEVICE_TYPE,
        Exclusive: BOOLEAN,
        DeviceObject: *mut PDEVICE_OBJECT,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut IoCompletionObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn IoCheckShareAccess(
        DesiredAccess: ACCESS_MASK,
        DesiredShareAccess: ULONG,
        FileObject: PFILE_OBJECT,
        ShareAccess: PSHARE_ACCESS,
        Update: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn IoBuildSynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildDeviceIoControlRequest(
        IoControlCode: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        InputBuffer: PVOID,
        InputBufferLength: ULONG,
        OutputBuffer: PVOID,
        OutputBufferLength: ULONG,
        InternalDeviceIoControl: BOOLEAN,
        Event: PKEVENT,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoBuildAsynchronousFsdRequest(
        MajorFunction: ULONG,
        DeviceObject: PDEVICE_OBJECT,
        Buffer: PVOID,
        Length: ULONG,
        StartingOffset: PLARGE_INTEGER,
        IoStatusBlock: PIO_STATUS_BLOCK,
    ) -> PIRP;
}
extern "stdcall" {
    pub fn IoAllocateIrp(StackSize: CCHAR) -> PIRP;
}
extern "C" {
    pub static mut IdexChannelObject: IDE_CHANNEL_OBJECT;
}
extern "stdcall" {
    pub fn HalWriteSMCScratchRegister(ScratchRegister: ULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalWriteSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        WriteWordValue: BOOLEAN,
        DataValue: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReturnToFirmware(Routine: FIRMWARE_REENTRY) -> !;
}
extern "stdcall" {
    #[doc = " Registers or unregisters a shutdown notification which contains a function\n pointer that will be called on shutdown\n @param ShutdownRegistration Pointer to a HAL_SHUTDOWN_REGISTRATION describing the notification settings\n @param Register TRUE to register the notification, FALSE to unregister"]
    pub fn HalRegisterShutdownNotification(
        ShutdownRegistration: PHAL_SHUTDOWN_REGISTRATION,
        Register: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadWritePCISpace(
        BusNumber: ULONG,
        SlotNumber: ULONG,
        RegisterNumber: ULONG,
        Buffer: PVOID,
        Length: ULONG,
        WritePCISpace: BOOLEAN,
    );
}
extern "stdcall" {
    pub fn HalReadSMCTrayState(TrayState: PULONG, TrayStateChangeCount: PULONG) -> NTSTATUS;
}
extern "stdcall" {
    pub fn HalReadSMBusValue(
        SlaveAddress: UCHAR,
        CommandCode: UCHAR,
        ReadWordValue: BOOLEAN,
        DataValue: *mut ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    #[doc = " Checks whether the console is in the middle of a reset or shutdown sequence.\n @return TRUE if the console is in the middle of a reset or shutdown sequence, else FALSE."]
    pub fn HalIsResetOrShutdownPending() -> BOOLEAN;
}
extern "stdcall" {
    #[doc = " Initiates a shutdown. May return if the SMBus-lock is already owned, the shutdown will start as soon as the lock is available."]
    pub fn HalInitiateShutdown();
}
extern "stdcall" {
    pub fn HalGetInterruptVector(BusInterruptLevel: ULONG, Irql: PKIRQL) -> ULONG;
}
extern "stdcall" {
    pub fn HalEnableSystemInterrupt(BusInterruptLevel: ULONG, InterruptMode: KINTERRUPT_MODE);
}
extern "stdcall" {
    #[doc = " Switches the console to secure mode, where a tray eject or tray open interrupt causes the console to reboot. After the console is switched into secure mode, it cannot switch back."]
    pub fn HalEnableSecureTrayEject();
}
extern "C" {
    pub static mut HalDiskSerialNumber: STRING;
}
extern "C" {
    pub static mut HalDiskModelNumber: STRING;
}
extern "C" {
    pub static mut HalDiskCachePartitionCount: ULONG;
}
extern "stdcall" {
    pub fn HalDisableSystemInterrupt(BusInterruptLevel: ULONG);
}
extern "C" {
    pub static mut HalBootSMCVideoMode: DWORD;
}
extern "stdcall" {
    pub fn FscSetCacheSize(NumberOfCachePages: PFN_COUNT) -> NTSTATUS;
}
extern "stdcall" {
    pub fn FscInvalidateIdleBlocks();
}
extern "stdcall" {
    pub fn FscGetCacheSize() -> PFN_COUNT;
}
extern "C" {
    pub static mut ExTimerObjectType: OBJECT_TYPE;
}
extern "C" {
    pub static mut ExSemaphoreObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExSaveNonVolatileSetting(
        ValueIndex: ULONG,
        Type: ULONG,
        Value: PVOID,
        ValueLength: ULONG,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExReleaseReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExReadWriteRefurbInfo(
        RefurbInfo: *mut XBOX_REFURB_INFO,
        ValueLength: ULONG,
        DoWrite: BOOLEAN,
    ) -> NTSTATUS;
}
extern "stdcall" {
    pub fn ExRaiseStatus(Status: NTSTATUS);
}
extern "stdcall" {
    pub fn ExRaiseException(ExceptionRecord: PEXCEPTION_RECORD);
}
extern "stdcall" {
    #[doc = " Returns the size of the pool block.\n @param PoolBlock The address of the pool block.\n @return The size of the pool block."]
    pub fn ExQueryPoolBlockSize(PoolBlock: PVOID) -> ULONG;
}
extern "stdcall" {
    pub fn ExQueryNonVolatileSetting(
        ValueIndex: ULONG,
        Type: PULONG,
        Value: PVOID,
        ValueLength: ULONG,
        ResultLength: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    pub static mut ExMutantObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    pub fn ExInterlockedAddLargeInteger(
        Addend: PLARGE_INTEGER,
        Increment: LARGE_INTEGER,
    ) -> LARGE_INTEGER;
}
extern "stdcall" {
    pub fn ExInitializeReadWriteLock(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    #[doc = " Deallocates a block of pool memory.\n @param P Specifies the address of the block of pool memory being deallocated."]
    pub fn ExFreePool(P: PVOID);
}
extern "C" {
    pub static mut ExEventObjectType: OBJECT_TYPE;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @param Tag The pool tag to use for the allocated memory. Specify the pool tag as a character literal of up to four characters delimited by single quotation marks (for example, 'Tag1'). The string is usually specified in reverse order (for example, '1gaT'). Each ASCII character in the tag must be a value in the range 0x20 (space) to 0x126 (tilde). Each allocation code path should use a unique pool tag to help debuggers and verifiers identify the code path.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePoolWithTag(NumberOfBytes: SIZE_T, Tag: ULONG) -> PVOID;
}
extern "stdcall" {
    #[doc = " Allocates pool memory and returns a pointer to the allocated block.\n @oaram NumberOfBytes The number of bytes to allocate.\n @return NULL if there is insufficient memory in the free pool to satisfy the request. Otherwise, the routine returns a pointer to the allocated memory."]
    pub fn ExAllocatePool(NumberOfBytes: SIZE_T) -> PVOID;
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockShared(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn ExAcquireReadWriteLockExclusive(ReadWriteLock: PERWLOCK);
}
extern "stdcall" {
    pub fn DbgUnLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    #[doc = " WARNING: This function crashes my XBox, so probably don't use.\n Displays a prompt-string on the debugging console, then reads a line of text from the debugging console.\n @param Prompt The string that gets output on the debugging console.\n @param Response Specifies where to store the response string read from the debugging console.\n @param MaximumResponseLength Maximum number of characters that fit into the response-buffer.\n @return Number of characters stored into the response buffer, including newline."]
    pub fn DbgPrompt(Prompt: PCH, Response: PCH, MaximumResponseLength: ULONG) -> ULONG;
}
extern "C" {
    #[doc = " \"printf\"-style output function for the kernel debugger.\n @param Format \"printf\"-style format string\n @param ... Arguments matching the format string.\n @return A status-code."]
    pub fn DbgPrint(Format: PCSTR, ...) -> ULONG;
}
extern "stdcall" {
    pub fn DbgLoadImageSymbols(FileName: PSTRING, ImageBase: PVOID, ProcessId: ULONG_PTR);
}
extern "stdcall" {
    pub fn DbgBreakPointWithStatus(Status: ULONG);
}
extern "stdcall" {
    pub fn DbgBreakPoint();
}
extern "stdcall" {
    pub fn AvSetSavedDataAddress(Address: PVOID);
}
extern "stdcall" {
    pub fn AvSetDisplayMode(
        RegisterBase: PVOID,
        Step: ULONG,
        DisplayMode: ULONG,
        SourceColorFormat: ULONG,
        Pitch: ULONG,
        FrameBuffer: ULONG,
    ) -> ULONG;
}
extern "stdcall" {
    pub fn AvSendTVEncoderOption(RegisterBase: PVOID, Option: ULONG, Param: ULONG, Result: PULONG);
}
extern "stdcall" {
    pub fn AvGetSavedDataAddress() -> PVOID;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a USHORT\n @param Source The USHORT-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUshortByteSwap(Source: USHORT) -> USHORT;
}
extern "fastcall" {
    #[doc = " Performs a byte-swap (big-endian <-> little-endian) conversion of a ULONG\n @param Source The ULONG-value which is to be swapped\n @return The byte-swapped value"]
    pub fn RtlUlongByteSwap(Source: ULONG) -> ULONG;
}
extern "fastcall" {
    pub fn ObfReferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn ObfDereferenceObject(Object: PVOID);
}
extern "fastcall" {
    pub fn KiUnlockDispatcherDatabase(OldIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Raises the hardware priority to the specified IRQL value, thereby masking off interrupts of equivalent or lower IRQL on the current processor.\n @param NewIrql Specifies the new IRQL to which the hardware priority is to be raised.\n @return The original IRQL value to be used in a subsequent call to KfLowerIrql."]
    pub fn KfRaiseIrql(NewIrql: KIRQL) -> KIRQL;
}
extern "fastcall" {
    #[doc = " Restores the IRQL on the current processor to its original value.\n @param NewIrql Specifies the IRQL that was returned from KfRaiseIrql."]
    pub fn KfLowerIrql(NewIrql: KIRQL);
}
extern "fastcall" {
    pub fn IofCompleteRequest(Irp: PIRP, PriorityBoost: CCHAR);
}
extern "fastcall" {
    pub fn IofCallDriver(DeviceObject: PDEVICE_OBJECT, Irp: PIRP) -> NTSTATUS;
}
extern "fastcall" {
    pub fn InterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSINGLE_LIST_ENTRY,
    ) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically increments a LONG-value\n @param Addend Pointer to the LONG-variable which is to be incremented\n @return The resulting incremented value (also stored at 'Addend')"]
    pub fn InterlockedIncrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSINGLE_LIST_ENTRY;
}
extern "fastcall" {
    pub fn InterlockedExchangeAdd(Addend: *mut LONG, Increment: LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedExchange(Target: *mut LONG, Value: LONG) -> LONG;
}
extern "fastcall" {
    #[doc = " Atomically decrements a LONG-value\n @param Addend Pointer to the LONG-variable which is to be decremented\n @return The resulting decremented value (also stored at 'Addend')"]
    pub fn InterlockedDecrement(Addend: *mut LONG) -> LONG;
}
extern "fastcall" {
    pub fn InterlockedCompareExchange(
        Destination: *mut LONG,
        ExChange: LONG,
        Comparand: LONG,
    ) -> LONG;
}
extern "fastcall" {
    #[doc = " Requests a software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalRequestSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Clears a possible pending software interrupt.\n @param RequestIrql The request IRQL value."]
    pub fn HalClearSoftwareInterrupt(RequestIrql: KIRQL);
}
extern "fastcall" {
    #[doc = " Atomically removes an entry from the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @return A pointer to the LIST_ENTRY which was removed from the list (NULL if the list was empty)."]
    pub fn ExfInterlockedRemoveHeadList(ListHead: PLIST_ENTRY) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the end of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the last list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertTailList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Atomically inserts an entry at the beginning of a doubly linked list (of LIST_ENTRY structs).\n @param ListHead Pointer to the LIST_ENTRY that serves as the list's head\n @param ListEntry Pointer to the LIST_ENTRY that is to be inserted\n @return A pointer to the first list entry before the new entry was inserted (NULL if the list was empty)."]
    pub fn ExfInterlockedInsertHeadList(
        ListHead: PLIST_ENTRY,
        ListEntry: PLIST_ENTRY,
    ) -> PLIST_ENTRY;
}
extern "fastcall" {
    #[doc = " Compares one integer variable to another and, if they're equal, sets the first variable to a caller-supplied value.\n @param Destination A pointer to an integer that will be compared and possibly replaced.\n @param Exchange A pointer to an integer that will replace the one at Destination if the comparison results in equality.\n @param Comparand A pointer to an integer with which the value at Destination will be compared.\n @return The inital value of the variable at Destination when the call occured."]
    pub fn ExInterlockedCompareExchange64(
        Destination: *mut LONGLONG,
        Exchange: PLONGLONG,
        Comparand: PLONGLONG,
    ) -> LONGLONG;
}
extern "fastcall" {
    #[doc = " Performs an interlocked addition of a ULONG increment value to a LARGE_INTEGER variable.\n @param Addend A pointer to the LARGE_INTEGER variable that is incremented by the value of Increment.\n @param Increment Specifies a ULONG value that is added to the variable that Addend points to."]
    pub fn ExInterlockedAddLargeStatistic(Addend: PLARGE_INTEGER, Increment: ULONG);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout__PDCLIB_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_imaxdiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type _PDCLIB_va_list = __builtin_va_list;
pub type _PDCLIB_fd_t = *mut libc::c_void;
pub type _PDCLIB_thrd_t = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_cnd_t {
    pub eventHandles: [*mut libc::c_void; 2usize],
    pub waitCount: u32,
}
#[test]
fn bindgen_test_layout___PDCLIB_cnd_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_cnd_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_cnd_t>(),
        12usize,
        concat!("Size of: ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_cnd_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventHandles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(eventHandles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(waitCount)
        )
    );
}
pub type _PDCLIB_cnd_t = __PDCLIB_cnd_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_mtx_t {
    pub handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___PDCLIB_mtx_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_mtx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Size of: ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_mtx_t),
            "::",
            stringify!(handle)
        )
    );
}
pub type _PDCLIB_mtx_t = __PDCLIB_mtx_t;
pub type _PDCLIB_tss_t = libc::c_uint;
pub type _PDCLIB_once_flag = libc::c_int;
pub type _PDCLIB_int8_t = libc::c_schar;
pub type _PDCLIB_uint8_t = libc::c_uchar;
pub type _PDCLIB_int16_t = libc::c_short;
pub type _PDCLIB_uint16_t = libc::c_ushort;
pub type _PDCLIB_int32_t = libc::c_int;
pub type _PDCLIB_uint32_t = libc::c_uint;
pub type _PDCLIB_int64_t = libc::c_longlong;
pub type _PDCLIB_uint64_t = libc::c_ulonglong;
pub type _PDCLIB_int_fast8_t = libc::c_int;
pub type _PDCLIB_uint_fast8_t = libc::c_uint;
pub type _PDCLIB_int_fast16_t = libc::c_int;
pub type _PDCLIB_uint_fast16_t = libc::c_uint;
pub type _PDCLIB_int_fast32_t = libc::c_int;
pub type _PDCLIB_uint_fast32_t = libc::c_uint;
pub type _PDCLIB_int_fast64_t = libc::c_long;
pub type _PDCLIB_uint_fast64_t = libc::c_ulong;
pub type _PDCLIB_ptrdiff_t = libc::c_int;
pub type _PDCLIB_size_t = libc::c_uint;
pub type _PDCLIB_wchar_t = libc::c_ushort;
pub type _PDCLIB_wint_t = libc::c_ushort;
pub type _PDCLIB_intptr_t = libc::c_long;
pub type _PDCLIB_uintptr_t = libc::c_ulong;
pub type _PDCLIB_intmax_t = libc::c_longlong;
pub type _PDCLIB_uintmax_t = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_fpos_t {
    pub offset: _PDCLIB_uint64_t,
    pub status: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_file_t {
    pub handle: _PDCLIB_fd_t,
    pub buffer: *mut libc::c_char,
    pub bufsize: _PDCLIB_size_t,
    pub bufidx: _PDCLIB_size_t,
    pub bufend: _PDCLIB_size_t,
    pub pos: _PDCLIB_fpos_t,
    pub ungetidx: _PDCLIB_size_t,
    pub ungetbuf: *mut libc::c_uchar,
    pub status: libc::c_uint,
    pub filename: *mut libc::c_char,
    pub next: *mut _PDCLIB_file_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_file_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_file_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_file_t>(),
        64usize,
        concat!("Size of: ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufidx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetidx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetbuf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(next)
        )
    );
}
pub type _PDCLIB_time_t = libc::c_long;
pub type _PDCLIB_clock_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_exitfunc_t {
    pub next: *mut _PDCLIB_exitfunc_t,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__PDCLIB_exitfunc_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_exitfunc_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_exitfunc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_exitfunc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_status_t {
    pub base: libc::c_int,
    pub flags: _PDCLIB_int_fast32_t,
    pub n: _PDCLIB_size_t,
    pub i: _PDCLIB_size_t,
    pub current: _PDCLIB_size_t,
    pub s: *mut libc::c_char,
    pub width: _PDCLIB_size_t,
    pub prec: libc::c_int,
    pub stream: *mut _PDCLIB_file_t,
    pub arg: _PDCLIB_va_list,
}
#[test]
fn bindgen_test_layout__PDCLIB_status_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_status_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_status_t>(),
        40usize,
        concat!("Size of: ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn _PDCLIB_atomax(s: *const libc::c_char) -> _PDCLIB_intmax_t;
}
extern "C" {
    pub fn _PDCLIB_strtox_prelim(
        p: *const libc::c_char,
        sign: *mut libc::c_char,
        base: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_strtox_main(
        p: *mut *const libc::c_char,
        base: libc::c_uint,
        error: _PDCLIB_uintmax_t,
        limval: _PDCLIB_uintmax_t,
        limdigit: libc::c_int,
        sign: *mut libc::c_char,
    ) -> _PDCLIB_uintmax_t;
}
extern "C" {
    pub static _PDCLIB_digits: [libc::c_char; 0usize];
}
extern "C" {
    pub static _PDCLIB_Xdigits: [libc::c_char; 0usize];
}
extern "C" {
    pub fn _PDCLIB_print(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_scan(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_filemode(mode: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn _PDCLIB_prepread(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_prepwrite(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_closeall();
}
extern "C" {
    pub fn _PDCLIB_is_leap(year_offset: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_load_lines(
        stream: *mut _PDCLIB_file_t,
        lines: _PDCLIB_size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_getstream(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_setstream(stream: *mut _PDCLIB_file_t);
}
extern "C" {
    pub fn _PDCLIB_strtok(
        s1: *mut libc::c_char,
        s1max: *mut _PDCLIB_size_t,
        s2: *const libc::c_char,
        ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_errno_func() -> *mut libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_numeric_t {
    pub decimal_point: *mut libc::c_char,
    pub thousands_sep: *mut libc::c_char,
    pub grouping: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_numeric_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_numeric_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_numeric_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_numeric_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(grouping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_monetary_t {
    pub mon_decimal_point: *mut libc::c_char,
    pub mon_thousands_sep: *mut libc::c_char,
    pub mon_grouping: *mut libc::c_char,
    pub positive_sign: *mut libc::c_char,
    pub negative_sign: *mut libc::c_char,
    pub currency_symbol: *mut libc::c_char,
    pub int_curr_symbol: *mut libc::c_char,
    pub frac_digits: libc::c_char,
    pub p_cs_precedes: libc::c_char,
    pub n_cs_precedes: libc::c_char,
    pub p_sep_by_space: libc::c_char,
    pub n_sep_by_space: libc::c_char,
    pub p_sign_posn: libc::c_char,
    pub n_sign_posn: libc::c_char,
    pub int_frac_digits: libc::c_char,
    pub int_p_cs_precedes: libc::c_char,
    pub int_n_cs_precedes: libc::c_char,
    pub int_p_sep_by_space: libc::c_char,
    pub int_n_sep_by_space: libc::c_char,
    pub int_p_sign_posn: libc::c_char,
    pub int_n_sign_posn: libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_monetary_t>(),
        44usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_numeric_monetary_t {
    pub lconv: *mut lconv,
    pub numeric_alloced: libc::c_int,
    pub monetary_alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_numeric_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_numeric_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_numeric_monetary_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_numeric_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lconv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numeric_alloced) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(numeric_alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).monetary_alloced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(monetary_alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_numeric_monetary: _PDCLIB_lc_numeric_monetary_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_collate_t {
    pub alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_collate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_collate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_collate_t),
            "::",
            stringify!(alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_collate: _PDCLIB_lc_collate_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_entry_t {
    pub flags: _PDCLIB_uint16_t,
    pub upper: libc::c_uchar,
    pub lower: libc::c_uchar,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_entry_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_entry_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_entry_t>(),
        2usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(lower)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_t {
    pub alloced: libc::c_int,
    pub digits_low: libc::c_int,
    pub digits_high: libc::c_int,
    pub Xdigits_low: libc::c_int,
    pub Xdigits_high: libc::c_int,
    pub xdigits_low: libc::c_int,
    pub xdigits_high: libc::c_int,
    pub entry: *mut _PDCLIB_lc_ctype_entry_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_t>(),
        32usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_low) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_high) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_low) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_high) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_ctype: _PDCLIB_lc_ctype_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_messages_t {
    pub alloced: libc::c_int,
    pub errno_texts: [*mut libc::c_char; 141usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_messages_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_messages_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_messages_t>(),
        568usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_messages_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errno_texts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(errno_texts)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_messages: _PDCLIB_lc_messages_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_time_t {
    pub alloced: libc::c_int,
    pub month_name_abbr: [*mut libc::c_char; 12usize],
    pub month_name_full: [*mut libc::c_char; 12usize],
    pub day_name_abbr: [*mut libc::c_char; 7usize],
    pub day_name_full: [*mut libc::c_char; 7usize],
    pub date_time_format: *mut libc::c_char,
    pub time_format_12h: *mut libc::c_char,
    pub date_format: *mut libc::c_char,
    pub time_format: *mut libc::c_char,
    pub am_pm: [*mut libc::c_char; 2usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_time_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_time_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_time_t>(),
        180usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_time_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_abbr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_full) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_abbr) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_full) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_time_format) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format_12h) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format_12h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_format) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).am_pm) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(am_pm)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_time: _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_numeric(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_numeric_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_monetary(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_monetary_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_collate(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_collate_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_ctype(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_ctype_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_time(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_messages(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_messages_t;
}
pub const _PDCLIB_assert_568: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = libc::c_int;
pub const _PDCLIB_assert_569: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = libc::c_int;
pub const _PDCLIB_assert_570: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = libc::c_int;
pub const _PDCLIB_assert_571: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = libc::c_int;
pub const _PDCLIB_assert_574: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = libc::c_int;
pub const _PDCLIB_assert_577: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = libc::c_int;
pub const _PDCLIB_assert_580: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = libc::c_int;
pub const _PDCLIB_assert_586: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = libc::c_int;
pub const _PDCLIB_assert_589: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = libc::c_int;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = _PDCLIB_int_fast8_t;
pub type int_fast16_t = _PDCLIB_int_fast16_t;
pub type int_fast32_t = _PDCLIB_int_fast32_t;
pub type int_fast64_t = _PDCLIB_int_fast64_t;
pub type uint_fast8_t = _PDCLIB_uint_fast8_t;
pub type uint_fast16_t = _PDCLIB_uint_fast16_t;
pub type uint_fast32_t = _PDCLIB_uint_fast32_t;
pub type uint_fast64_t = _PDCLIB_uint_fast64_t;
pub type intmax_t = _PDCLIB_intmax_t;
pub type uintmax_t = _PDCLIB_uintmax_t;
extern "C" {
    pub fn pb_show_front_screen();
}
extern "C" {
    pub fn pb_show_debug_screen();
}
extern "C" {
    pub fn pb_show_depth_screen();
}
extern "C" {
    pub fn pb_get_vbl_counter() -> DWORD;
}
extern "C" {
    pub fn pb_wait_for_vbl() -> DWORD;
}
extern "C" {
    pub fn pb_erase_depth_stencil_buffer(
        x: libc::c_int,
        y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
    );
}
extern "C" {
    pub fn pb_reset();
}
extern "C" {
    pub fn pb_finished() -> libc::c_int;
}
extern "C" {
    pub fn pb_wait_until_gr_not_busy();
}
extern "C" {
    pub fn pb_wait_until_tiles_not_busy() -> DWORD;
}
extern "C" {
    pub fn pb_begin() -> *mut u32;
}
extern "C" {
    pub fn pb_push_to(subchannel: DWORD, p: *mut u32, command: DWORD, nparam: DWORD);
}
extern "C" {
    pub fn pb_push1_to(subchannel: DWORD, p: *mut u32, command: DWORD, param1: DWORD) -> *mut u32;
}
extern "C" {
    pub fn pb_push2_to(
        subchannel: DWORD,
        p: *mut u32,
        command: DWORD,
        param1: DWORD,
        param2: DWORD,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push3_to(
        subchannel: DWORD,
        p: *mut u32,
        command: DWORD,
        param1: DWORD,
        param2: DWORD,
        param3: DWORD,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push4_to(
        subchannel: DWORD,
        p: *mut u32,
        command: DWORD,
        param1: DWORD,
        param2: DWORD,
        param3: DWORD,
        param4: DWORD,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push4f_to(
        subchannel: DWORD,
        p: *mut u32,
        command: DWORD,
        param1: f32,
        param2: f32,
        param3: f32,
        param4: f32,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push(p: *mut u32, command: DWORD, nparam: DWORD);
}
extern "C" {
    pub fn pb_push1(p: *mut u32, command: DWORD, param1: DWORD) -> *mut u32;
}
extern "C" {
    pub fn pb_push2(p: *mut u32, command: DWORD, param1: DWORD, param2: DWORD) -> *mut u32;
}
extern "C" {
    pub fn pb_push3(
        p: *mut u32,
        command: DWORD,
        param1: DWORD,
        param2: DWORD,
        param3: DWORD,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push4(
        p: *mut u32,
        command: DWORD,
        param1: DWORD,
        param2: DWORD,
        param3: DWORD,
        param4: DWORD,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push4f(
        p: *mut u32,
        command: DWORD,
        param1: f32,
        param2: f32,
        param3: f32,
        param4: f32,
    ) -> *mut u32;
}
extern "C" {
    pub fn pb_push_transposed_matrix(p: *mut u32, command: DWORD, m: *mut f32) -> *mut u32;
}
extern "C" {
    pub fn pb_end(pEnd: *mut u32);
}
extern "C" {
    pub fn pb_extra_buffers(n: libc::c_int);
}
extern "C" {
    pub fn pb_size(size: DWORD);
}
extern "C" {
    pub fn pb_set_color_format(fmt: libc::c_uint, swizzled: bool);
}
extern "C" {
    pub fn pb_init() -> libc::c_int;
}
extern "C" {
    pub fn pb_kill();
}
extern "C" {
    pub fn pb_print(format: *const libc::c_char, ...);
}
extern "C" {
    pub fn pb_printat(row: libc::c_int, col: libc::c_int, format: *mut libc::c_char, ...);
}
extern "C" {
    pub fn pb_erase_text_screen();
}
extern "C" {
    pub fn pb_draw_text_screen();
}
extern "C" {
    pub fn pb_target_extra_buffer(n: libc::c_int);
}
extern "C" {
    pub fn pb_target_back_buffer();
}
extern "C" {
    pub fn pb_extra_buffer(n: libc::c_int) -> *mut DWORD;
}
extern "C" {
    pub fn pb_back_buffer() -> *mut DWORD;
}
extern "C" {
    pub fn pb_back_buffer_width() -> DWORD;
}
extern "C" {
    pub fn pb_back_buffer_height() -> DWORD;
}
extern "C" {
    pub fn pb_back_buffer_pitch() -> DWORD;
}
extern "C" {
    pub fn pb_fill(x: libc::c_int, y: libc::c_int, w: libc::c_int, h: libc::c_int, color: DWORD);
}
extern "C" {
    pub fn pb_set_viewport(
        dwx: libc::c_int,
        dwy: libc::c_int,
        width: libc::c_int,
        height: libc::c_int,
        zmin: f32,
        zmax: f32,
    );
}
extern "C" {
    pub fn pb_busy() -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_STATUS_LOCATION {
    pub _address: u8,
}
pub type __builtin_va_list = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
