/* automatically generated by rust-bindgen 0.69.5 */

pub const XBOX: u32 = 1;
pub const __XBOX__: u32 = 1;
pub const HAVE_WINAPIFAMILY_H: u32 = 1;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY: u32 = 100;
pub const __WINDOWS__: u32 = 1;
pub const __WIN32__: u32 = 1;
pub const HAVE_LIBC: u32 = 1;
pub const STDC_HEADERS: u32 = 1;
pub const HAVE_STDIO_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STDDEF_H: u32 = 1;
pub const HAVE_STDARG_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_CTYPE_H: u32 = 1;
pub const HAVE_MATH_H: u32 = 1;
pub const HAVE_MALLOC: u32 = 1;
pub const HAVE_CALLOC: u32 = 1;
pub const HAVE_REALLOC: u32 = 1;
pub const HAVE_FREE: u32 = 1;
pub const HAVE_GETENV: u32 = 1;
pub const HAVE_QSORT: u32 = 1;
pub const HAVE_ABS: u32 = 1;
pub const HAVE_MEMSET: u32 = 1;
pub const HAVE_MEMCPY: u32 = 1;
pub const HAVE_MEMMOVE: u32 = 1;
pub const HAVE_MEMCMP: u32 = 1;
pub const HAVE_STRLEN: u32 = 1;
pub const HAVE_STRCHR: u32 = 1;
pub const HAVE_STRRCHR: u32 = 1;
pub const HAVE_STRSTR: u32 = 1;
pub const HAVE_STRTOL: u32 = 1;
pub const HAVE_STRTOUL: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_ATOI: u32 = 1;
pub const HAVE_STRCMP: u32 = 1;
pub const HAVE_STRNCMP: u32 = 1;
pub const HAVE_SSCANF: u32 = 1;
pub const HAVE_SNPRINTF: u32 = 1;
pub const HAVE_VSNPRINTF: u32 = 1;
pub const HAVE__EXIT: u32 = 1;
pub const HAVE_ACOS: u32 = 1;
pub const HAVE_ACOSF: u32 = 1;
pub const HAVE_ASIN: u32 = 1;
pub const HAVE_ASINF: u32 = 1;
pub const HAVE_ATAN: u32 = 1;
pub const HAVE_ATANF: u32 = 1;
pub const HAVE_ATAN2: u32 = 1;
pub const HAVE_ATAN2F: u32 = 1;
pub const HAVE_CEILF: u32 = 1;
pub const HAVE_COS: u32 = 1;
pub const HAVE_COSF: u32 = 1;
pub const HAVE_EXP: u32 = 1;
pub const HAVE_EXPF: u32 = 1;
pub const HAVE_FABS: u32 = 1;
pub const HAVE_FABSF: u32 = 1;
pub const HAVE_FMOD: u32 = 1;
pub const HAVE_FMODF: u32 = 1;
pub const HAVE_LOG: u32 = 1;
pub const HAVE_LOGF: u32 = 1;
pub const HAVE_LOG10: u32 = 1;
pub const HAVE_LOG10F: u32 = 1;
pub const HAVE_POW: u32 = 1;
pub const HAVE_POWF: u32 = 1;
pub const HAVE_SIN: u32 = 1;
pub const HAVE_SINF: u32 = 1;
pub const HAVE_SQRT: u32 = 1;
pub const HAVE_SQRTF: u32 = 1;
pub const HAVE_TAN: u32 = 1;
pub const HAVE_TANF: u32 = 1;
pub const SDL_AUDIO_DRIVER_XBOX: u32 = 1;
pub const SDL_JOYSTICK_XBOX: u32 = 1;
pub const SDL_HAPTIC_DISABLED: u32 = 1;
pub const SDL_LOADSO_DISABLED: u32 = 1;
pub const SDL_SENSOR_DISABLED: u32 = 1;
pub const SDL_THREAD_WINDOWS: u32 = 1;
pub const SDL_TIMER_WINDOWS: u32 = 1;
pub const SDL_VIDEO_DRIVER_XBOX: u32 = 1;
pub const SDL_FILESYSTEM_DUMMY: u32 = 1;
pub const __STDC_WANT_LIB_EXT1_PREVIOUS__: i32 = -1;
pub const _PDCLIB_endl: &[u8; 2] = b"\n\0";
pub const _PDCLIB_SUCCESS: u32 = 0;
pub const _PDCLIB_FAILURE: i32 = -1;
pub const _PDCLIB_CHAR_SIGNED: u32 = 1;
pub const _PDCLIB_SHRT_BYTES: u32 = 2;
pub const _PDCLIB_INT_BYTES: u32 = 4;
pub const _PDCLIB_LONG_BYTES: u32 = 4;
pub const _PDCLIB_LLONG_BYTES: u32 = 8;
pub const _PDCLIB_CLOCKS_PER_SEC: u32 = 1000;
pub const _PDCLIB_TIME_UTC: u32 = 1;
pub const _PDCLIB_FLT_ROUNDS: i32 = -1;
pub const _PDCLIB_FLT_EVAL_METHOD: i32 = -1;
pub const _PDCLIB_DECIMAL_DIG: u32 = 17;
pub const _PDCLIB_PAGESIZE: u32 = 4096;
pub const _PDCLIB_MINALLOC: u32 = 8;
pub const _PDCLIB_BUFSIZ: u32 = 1024;
pub const _PDCLIB_FOPEN_MAX: u32 = 8;
pub const _PDCLIB_FILENAME_MAX: u32 = 128;
pub const _PDCLIB_L_tmpnam: u32 = 46;
pub const _PDCLIB_TMP_MAX: u32 = 50;
pub const _PDCLIB_SEEK_SET: u32 = 0;
pub const _PDCLIB_SEEK_CUR: u32 = 1;
pub const _PDCLIB_SEEK_END: u32 = 2;
pub const _PDCLIB_UNGETCBUFSIZE: u32 = 1;
pub const _PDCLIB_ATEXIT_SLOTS: u32 = 40;
pub const _PDCLIB_E2BIG: u32 = 7;
pub const _PDCLIB_EACCES: u32 = 13;
pub const _PDCLIB_EADDRINUSE: u32 = 100;
pub const _PDCLIB_EADDRNOTAVAIL: u32 = 101;
pub const _PDCLIB_EAFNOSUPPORT: u32 = 102;
pub const _PDCLIB_EAGAIN: u32 = 11;
pub const _PDCLIB_EALREADY: u32 = 103;
pub const _PDCLIB_EBADF: u32 = 9;
pub const _PDCLIB_EBADMSG: u32 = 104;
pub const _PDCLIB_EBUSY: u32 = 16;
pub const _PDCLIB_ECANCELED: u32 = 105;
pub const _PDCLIB_ECHILD: u32 = 10;
pub const _PDCLIB_ECONNABORTED: u32 = 106;
pub const _PDCLIB_ECONNREFUSED: u32 = 107;
pub const _PDCLIB_ECONNRESET: u32 = 108;
pub const _PDCLIB_EDEADLK: u32 = 36;
pub const _PDCLIB_EDESTADDRREQ: u32 = 109;
pub const _PDCLIB_EDOM: u32 = 33;
pub const _PDCLIB_EEXIST: u32 = 17;
pub const _PDCLIB_EFAULT: u32 = 14;
pub const _PDCLIB_EFBIG: u32 = 27;
pub const _PDCLIB_EHOSTUNREACH: u32 = 110;
pub const _PDCLIB_EIDRM: u32 = 111;
pub const _PDCLIB_EILSEQ: u32 = 42;
pub const _PDCLIB_EINPROGRESS: u32 = 112;
pub const _PDCLIB_EINTR: u32 = 4;
pub const _PDCLIB_EINVAL: u32 = 22;
pub const _PDCLIB_EIO: u32 = 5;
pub const _PDCLIB_EISCONN: u32 = 113;
pub const _PDCLIB_EISDIR: u32 = 21;
pub const _PDCLIB_ELOOP: u32 = 114;
pub const _PDCLIB_EMFILE: u32 = 24;
pub const _PDCLIB_EMLINK: u32 = 31;
pub const _PDCLIB_EMSGSIZE: u32 = 115;
pub const _PDCLIB_ENAMETOOLONG: u32 = 38;
pub const _PDCLIB_ENETDOWN: u32 = 116;
pub const _PDCLIB_ENETRESET: u32 = 117;
pub const _PDCLIB_ENETUNREACH: u32 = 118;
pub const _PDCLIB_ENFILE: u32 = 23;
pub const _PDCLIB_ENOBUFS: u32 = 119;
pub const _PDCLIB_ENODATA: u32 = 120;
pub const _PDCLIB_ENODEV: u32 = 19;
pub const _PDCLIB_ENOENT: u32 = 2;
pub const _PDCLIB_ENOEXEC: u32 = 8;
pub const _PDCLIB_ENOLCK: u32 = 39;
pub const _PDCLIB_ENOLINK: u32 = 121;
pub const _PDCLIB_ENOMEM: u32 = 12;
pub const _PDCLIB_ENOMSG: u32 = 122;
pub const _PDCLIB_ENOPROTOOPT: u32 = 123;
pub const _PDCLIB_ENOSPC: u32 = 28;
pub const _PDCLIB_ENOSR: u32 = 124;
pub const _PDCLIB_ENOSTR: u32 = 125;
pub const _PDCLIB_ENOSYS: u32 = 40;
pub const _PDCLIB_ENOTCONN: u32 = 126;
pub const _PDCLIB_ENOTDIR: u32 = 20;
pub const _PDCLIB_ENOTEMPTY: u32 = 41;
pub const _PDCLIB_ENOTRECOVERABLE: u32 = 127;
pub const _PDCLIB_ENOTSOCK: u32 = 128;
pub const _PDCLIB_ENOTSUP: u32 = 129;
pub const _PDCLIB_ENOTTY: u32 = 25;
pub const _PDCLIB_ENXIO: u32 = 6;
pub const _PDCLIB_EOPNOTSUPP: u32 = 130;
pub const _PDCLIB_EOVERFLOW: u32 = 132;
pub const _PDCLIB_EOWNERDEAD: u32 = 133;
pub const _PDCLIB_EPERM: u32 = 1;
pub const _PDCLIB_EPIPE: u32 = 32;
pub const _PDCLIB_EPROTO: u32 = 134;
pub const _PDCLIB_EPROTONOSUPPORT: u32 = 135;
pub const _PDCLIB_EPROTOTYPE: u32 = 136;
pub const _PDCLIB_ERANGE: u32 = 34;
pub const _PDCLIB_EROFS: u32 = 30;
pub const _PDCLIB_ESPIPE: u32 = 29;
pub const _PDCLIB_ESRCH: u32 = 3;
pub const _PDCLIB_ETIME: u32 = 137;
pub const _PDCLIB_ETIMEDOUT: u32 = 138;
pub const _PDCLIB_ETXTBSY: u32 = 139;
pub const _PDCLIB_EWOULDBLOCK: u32 = 140;
pub const _PDCLIB_EXDEV: u32 = 18;
pub const _PDCLIB_ERRNO_MAX: u32 = 141;
pub const _PDCLIB_LOCALE_PATH: &[u8; 23] = b"/usr/share/pdclib/i18n\0";
pub const _PDCLIB_ONCE_FLAG_INIT: u32 = 0;
pub const _PDCLIB_TSS_DTOR_ITERATIONS: u32 = 4;
pub const _PDCLIB_HOSTED: u32 = 1;
pub const _PDCLIB_NULL: u32 = 0;
pub const _PDCLIB_CHAR_BIT: u32 = 8;
pub const _PDCLIB_UCHAR_MIN: u32 = 0;
pub const _PDCLIB_UCHAR_MAX: u32 = 255;
pub const _PDCLIB_SCHAR_MIN: i32 = -128;
pub const _PDCLIB_SCHAR_MAX: u32 = 127;
pub const _PDCLIB_CHAR_MIN: i32 = -128;
pub const _PDCLIB_CHAR_MAX: u32 = 127;
pub const _PDCLIB_SHRT_MAX: u32 = 32767;
pub const _PDCLIB_SHRT_MIN: i32 = -32768;
pub const _PDCLIB_USHRT_MAX: u32 = 65535;
pub const _PDCLIB_USHRT_MIN: u32 = 0;
pub const _PDCLIB_INT_MAX: u32 = 2147483647;
pub const _PDCLIB_INT_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT_MAX: u32 = 4294967295;
pub const _PDCLIB_UINT_MIN: u32 = 0;
pub const _PDCLIB_LONG_MAX: u32 = 2147483647;
pub const _PDCLIB_LONG_MIN: i32 = -2147483648;
pub const _PDCLIB_ULONG_MAX: u32 = 4294967295;
pub const _PDCLIB_ULONG_MIN: u32 = 0;
pub const _PDCLIB_LLONG_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_LLONG_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_ULLONG_MAX: i32 = -1;
pub const _PDCLIB_ULLONG_MIN: u32 = 0;
pub const _PDCLIB_INT8_MAX: u32 = 127;
pub const _PDCLIB_INT8_MIN: i32 = -128;
pub const _PDCLIB_UINT8_MAX: u32 = 255;
pub const _PDCLIB_INT16_MAX: u32 = 32767;
pub const _PDCLIB_INT16_MIN: i32 = -32768;
pub const _PDCLIB_UINT16_MAX: u32 = 65535;
pub const _PDCLIB_INT32_MAX: u32 = 2147483647;
pub const _PDCLIB_INT32_MIN: i32 = -2147483648;
pub const _PDCLIB_UINT32_MAX: u32 = 4294967295;
pub const _PDCLIB_INT64_MAX: u64 = 9223372036854775807;
pub const _PDCLIB_INT64_MIN: i64 = -9223372036854775808;
pub const _PDCLIB_UINT64_MAX: i32 = -1;
pub const _PDCLIB_FREAD: u32 = 8;
pub const _PDCLIB_FWRITE: u32 = 16;
pub const _PDCLIB_FAPPEND: u32 = 32;
pub const _PDCLIB_FRW: u32 = 64;
pub const _PDCLIB_FBIN: u32 = 128;
pub const _PDCLIB_FREEBUFFER: u32 = 256;
pub const _PDCLIB_ERRORFLAG: u32 = 512;
pub const _PDCLIB_EOFFLAG: u32 = 1024;
pub const _PDCLIB_WIDESTREAM: u32 = 2048;
pub const _PDCLIB_BYTESTREAM: u32 = 4096;
pub const _PDCLIB_DELONCLOSE: u32 = 8192;
pub const _PDCLIB_STATIC: u32 = 16384;
pub const _PDCLIB_FREENAME: u32 = 32768;
pub const _PDCLIB_LC_ALL: u32 = 0;
pub const _PDCLIB_LC_COLLATE: u32 = 1;
pub const _PDCLIB_LC_CTYPE: u32 = 2;
pub const _PDCLIB_LC_MONETARY: u32 = 3;
pub const _PDCLIB_LC_NUMERIC: u32 = 4;
pub const _PDCLIB_LC_TIME: u32 = 5;
pub const _PDCLIB_LC_MESSAGES: u32 = 6;
pub const _PDCLIB_LC_COUNT: u32 = 7;
pub const _PDCLIB_CTYPE_ALPHA: u32 = 1;
pub const _PDCLIB_CTYPE_BLANK: u32 = 2;
pub const _PDCLIB_CTYPE_CNTRL: u32 = 4;
pub const _PDCLIB_CTYPE_GRAPH: u32 = 8;
pub const _PDCLIB_CTYPE_PUNCT: u32 = 16;
pub const _PDCLIB_CTYPE_SPACE: u32 = 32;
pub const _PDCLIB_CTYPE_LOWER: u32 = 64;
pub const _PDCLIB_CTYPE_UPPER: u32 = 128;
pub const _PDCLIB_CHARSET_SIZE: u32 = 256;
pub const NULL: u32 = 0;
pub const _IOFBF: u32 = 1;
pub const _IOLBF: u32 = 2;
pub const _IONBF: u32 = 4;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 8;
pub const FILENAME_MAX: u32 = 128;
pub const L_tmpnam: u32 = 46;
pub const TMP_MAX: u32 = 50;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_SET: u32 = 0;
pub const RAND_MAX: u32 = 32767;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: i32 = -1;
pub const _sys_nerr: u32 = 141;
pub const INT8_MIN: i32 = -128;
pub const INT8_MAX: u32 = 127;
pub const UINT8_MAX: u32 = 255;
pub const INT16_MIN: i32 = -32768;
pub const INT16_MAX: u32 = 32767;
pub const UINT16_MAX: u32 = 65535;
pub const INT32_MIN: i32 = -2147483648;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST8_MAX: u32 = 127;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const MB_CUR_MAX: u32 = 2;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _ALPHA: u32 = 259;
pub const FP_NAN: u32 = 256;
pub const FP_NORMAL: u32 = 1024;
pub const FP_INFINITE: u32 = 1280;
pub const FP_ZERO: u32 = 16384;
pub const FP_SUBNORMAL: u32 = 17408;
pub const FP_FAST_FMAF: u32 = 1;
pub const FP_FAST_FMA: u32 = 1;
pub const FP_FAST_FMAL: u32 = 1;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const SDL_PRIs64: &[u8; 5] = b"I64d\0";
pub const M_PI: f64 = 3.141592653589793;
pub const SDL_ASSERT_LEVEL: u32 = 1;
pub const SDL_LIL_ENDIAN: u32 = 1234;
pub const SDL_BIG_ENDIAN: u32 = 4321;
pub const SDL_BYTEORDER: u32 = 1234;
pub const SDL_MUTEX_TIMEDOUT: u32 = 1;
pub const SDL_RWOPS_UNKNOWN: u32 = 0;
pub const SDL_RWOPS_WINFILE: u32 = 1;
pub const SDL_RWOPS_STDFILE: u32 = 2;
pub const SDL_RWOPS_JNIFILE: u32 = 3;
pub const SDL_RWOPS_MEMORY: u32 = 4;
pub const SDL_RWOPS_MEMORY_RO: u32 = 5;
pub const RW_SEEK_SET: u32 = 0;
pub const RW_SEEK_CUR: u32 = 1;
pub const RW_SEEK_END: u32 = 2;
pub const SDL_AUDIO_MASK_BITSIZE: u32 = 255;
pub const SDL_AUDIO_MASK_DATATYPE: u32 = 256;
pub const SDL_AUDIO_MASK_ENDIAN: u32 = 4096;
pub const SDL_AUDIO_MASK_SIGNED: u32 = 32768;
pub const AUDIO_U8: u32 = 8;
pub const AUDIO_S8: u32 = 32776;
pub const AUDIO_U16LSB: u32 = 16;
pub const AUDIO_S16LSB: u32 = 32784;
pub const AUDIO_U16MSB: u32 = 4112;
pub const AUDIO_S16MSB: u32 = 36880;
pub const AUDIO_U16: u32 = 16;
pub const AUDIO_S16: u32 = 32784;
pub const AUDIO_S32LSB: u32 = 32800;
pub const AUDIO_S32MSB: u32 = 36896;
pub const AUDIO_S32: u32 = 32800;
pub const AUDIO_F32LSB: u32 = 33056;
pub const AUDIO_F32MSB: u32 = 37152;
pub const AUDIO_F32: u32 = 33056;
pub const AUDIO_U16SYS: u32 = 16;
pub const AUDIO_S16SYS: u32 = 32784;
pub const AUDIO_S32SYS: u32 = 32800;
pub const AUDIO_F32SYS: u32 = 33056;
pub const SDL_AUDIO_ALLOW_FREQUENCY_CHANGE: u32 = 1;
pub const SDL_AUDIO_ALLOW_FORMAT_CHANGE: u32 = 2;
pub const SDL_AUDIO_ALLOW_CHANNELS_CHANGE: u32 = 4;
pub const SDL_AUDIO_ALLOW_SAMPLES_CHANGE: u32 = 8;
pub const SDL_AUDIO_ALLOW_ANY_CHANGE: u32 = 15;
pub const SDL_AUDIOCVT_MAX_FILTERS: u32 = 9;
pub const SDL_MIX_MAXVOLUME: u32 = 128;
pub const SDL_CACHELINE_SIZE: u32 = 128;
pub const SDL_ALPHA_OPAQUE: u32 = 255;
pub const SDL_ALPHA_TRANSPARENT: u32 = 0;
pub const SDL_SWSURFACE: u32 = 0;
pub const SDL_PREALLOC: u32 = 1;
pub const SDL_RLEACCEL: u32 = 2;
pub const SDL_DONTFREE: u32 = 4;
pub const SDL_SIMD_ALIGNED: u32 = 8;
pub const SDL_WINDOWPOS_UNDEFINED_MASK: u32 = 536805376;
pub const SDL_WINDOWPOS_CENTERED_MASK: u32 = 805240832;
pub const SDLK_SCANCODE_MASK: u32 = 1073741824;
pub const SDL_BUTTON_LEFT: u32 = 1;
pub const SDL_BUTTON_MIDDLE: u32 = 2;
pub const SDL_BUTTON_RIGHT: u32 = 3;
pub const SDL_BUTTON_X1: u32 = 4;
pub const SDL_BUTTON_X2: u32 = 5;
pub const SDL_JOYSTICK_AXIS_MAX: u32 = 32767;
pub const SDL_JOYSTICK_AXIS_MIN: i32 = -32768;
pub const SDL_HAT_CENTERED: u32 = 0;
pub const SDL_HAT_UP: u32 = 1;
pub const SDL_HAT_RIGHT: u32 = 2;
pub const SDL_HAT_DOWN: u32 = 4;
pub const SDL_HAT_LEFT: u32 = 8;
pub const SDL_HAT_RIGHTUP: u32 = 3;
pub const SDL_HAT_RIGHTDOWN: u32 = 6;
pub const SDL_HAT_LEFTUP: u32 = 9;
pub const SDL_HAT_LEFTDOWN: u32 = 12;
pub const SDL_RELEASED: u32 = 0;
pub const SDL_PRESSED: u32 = 1;
pub const SDL_TEXTEDITINGEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_TEXTINPUTEVENT_TEXT_SIZE: u32 = 32;
pub const SDL_QUERY: i32 = -1;
pub const SDL_IGNORE: u32 = 0;
pub const SDL_DISABLE: u32 = 0;
pub const SDL_ENABLE: u32 = 1;
pub const SDL_HAPTIC_CONSTANT: u32 = 1;
pub const SDL_HAPTIC_SINE: u32 = 2;
pub const SDL_HAPTIC_LEFTRIGHT: u32 = 4;
pub const SDL_HAPTIC_TRIANGLE: u32 = 8;
pub const SDL_HAPTIC_SAWTOOTHUP: u32 = 16;
pub const SDL_HAPTIC_SAWTOOTHDOWN: u32 = 32;
pub const SDL_HAPTIC_RAMP: u32 = 64;
pub const SDL_HAPTIC_SPRING: u32 = 128;
pub const SDL_HAPTIC_DAMPER: u32 = 256;
pub const SDL_HAPTIC_INERTIA: u32 = 512;
pub const SDL_HAPTIC_FRICTION: u32 = 1024;
pub const SDL_HAPTIC_CUSTOM: u32 = 2048;
pub const SDL_HAPTIC_GAIN: u32 = 4096;
pub const SDL_HAPTIC_AUTOCENTER: u32 = 8192;
pub const SDL_HAPTIC_STATUS: u32 = 16384;
pub const SDL_HAPTIC_PAUSE: u32 = 32768;
pub const SDL_HAPTIC_POLAR: u32 = 0;
pub const SDL_HAPTIC_CARTESIAN: u32 = 1;
pub const SDL_HAPTIC_SPHERICAL: u32 = 2;
pub const SDL_HAPTIC_INFINITY: u32 = 4294967295;
pub const SDL_HINT_FRAMEBUFFER_ACCELERATION: &[u8; 29] = b"SDL_FRAMEBUFFER_ACCELERATION\0";
pub const SDL_HINT_RENDER_DRIVER: &[u8; 18] = b"SDL_RENDER_DRIVER\0";
pub const SDL_HINT_RENDER_OPENGL_SHADERS: &[u8; 26] = b"SDL_RENDER_OPENGL_SHADERS\0";
pub const SDL_HINT_RENDER_DIRECT3D_THREADSAFE: &[u8; 31] = b"SDL_RENDER_DIRECT3D_THREADSAFE\0";
pub const SDL_HINT_RENDER_DIRECT3D11_DEBUG: &[u8; 28] = b"SDL_RENDER_DIRECT3D11_DEBUG\0";
pub const SDL_HINT_RENDER_LOGICAL_SIZE_MODE: &[u8; 29] = b"SDL_RENDER_LOGICAL_SIZE_MODE\0";
pub const SDL_HINT_RENDER_SCALE_QUALITY: &[u8; 25] = b"SDL_RENDER_SCALE_QUALITY\0";
pub const SDL_HINT_RENDER_VSYNC: &[u8; 17] = b"SDL_RENDER_VSYNC\0";
pub const SDL_HINT_VIDEO_ALLOW_SCREENSAVER: &[u8; 28] = b"SDL_VIDEO_ALLOW_SCREENSAVER\0";
pub const SDL_HINT_VIDEO_X11_XVIDMODE: &[u8; 23] = b"SDL_VIDEO_X11_XVIDMODE\0";
pub const SDL_HINT_VIDEO_X11_XINERAMA: &[u8; 23] = b"SDL_VIDEO_X11_XINERAMA\0";
pub const SDL_HINT_VIDEO_X11_XRANDR: &[u8; 21] = b"SDL_VIDEO_X11_XRANDR\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_PING: &[u8; 26] = b"SDL_VIDEO_X11_NET_WM_PING\0";
pub const SDL_HINT_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR: &[u8; 39] =
    b"SDL_VIDEO_X11_NET_WM_BYPASS_COMPOSITOR\0";
pub const SDL_HINT_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN: &[u8; 44] =
    b"SDL_WINDOW_FRAME_USABLE_WHILE_CURSOR_HIDDEN\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON: &[u8; 29] = b"SDL_WINDOWS_INTRESOURCE_ICON\0";
pub const SDL_HINT_WINDOWS_INTRESOURCE_ICON_SMALL: &[u8; 35] =
    b"SDL_WINDOWS_INTRESOURCE_ICON_SMALL\0";
pub const SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP: &[u8; 31] = b"SDL_WINDOWS_ENABLE_MESSAGELOOP\0";
pub const SDL_HINT_GRAB_KEYBOARD: &[u8; 18] = b"SDL_GRAB_KEYBOARD\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_TIME: &[u8; 28] = b"SDL_MOUSE_DOUBLE_CLICK_TIME\0";
pub const SDL_HINT_MOUSE_DOUBLE_CLICK_RADIUS: &[u8; 30] = b"SDL_MOUSE_DOUBLE_CLICK_RADIUS\0";
pub const SDL_HINT_MOUSE_NORMAL_SPEED_SCALE: &[u8; 29] = b"SDL_MOUSE_NORMAL_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_SPEED_SCALE: &[u8; 31] = b"SDL_MOUSE_RELATIVE_SPEED_SCALE\0";
pub const SDL_HINT_MOUSE_RELATIVE_MODE_WARP: &[u8; 29] = b"SDL_MOUSE_RELATIVE_MODE_WARP\0";
pub const SDL_HINT_MOUSE_FOCUS_CLICKTHROUGH: &[u8; 29] = b"SDL_MOUSE_FOCUS_CLICKTHROUGH\0";
pub const SDL_HINT_TOUCH_MOUSE_EVENTS: &[u8; 23] = b"SDL_TOUCH_MOUSE_EVENTS\0";
pub const SDL_HINT_MOUSE_TOUCH_EVENTS: &[u8; 23] = b"SDL_MOUSE_TOUCH_EVENTS\0";
pub const SDL_HINT_VIDEO_MINIMIZE_ON_FOCUS_LOSS: &[u8; 33] = b"SDL_VIDEO_MINIMIZE_ON_FOCUS_LOSS\0";
pub const SDL_HINT_IDLE_TIMER_DISABLED: &[u8; 28] = b"SDL_IOS_IDLE_TIMER_DISABLED\0";
pub const SDL_HINT_ORIENTATIONS: &[u8; 21] = b"SDL_IOS_ORIENTATIONS\0";
pub const SDL_HINT_APPLE_TV_CONTROLLER_UI_EVENTS: &[u8; 34] =
    b"SDL_APPLE_TV_CONTROLLER_UI_EVENTS\0";
pub const SDL_HINT_APPLE_TV_REMOTE_ALLOW_ROTATION: &[u8; 35] =
    b"SDL_APPLE_TV_REMOTE_ALLOW_ROTATION\0";
pub const SDL_HINT_IOS_HIDE_HOME_INDICATOR: &[u8; 28] = b"SDL_IOS_HIDE_HOME_INDICATOR\0";
pub const SDL_HINT_ACCELEROMETER_AS_JOYSTICK: &[u8; 30] = b"SDL_ACCELEROMETER_AS_JOYSTICK\0";
pub const SDL_HINT_TV_REMOTE_AS_JOYSTICK: &[u8; 26] = b"SDL_TV_REMOTE_AS_JOYSTICK\0";
pub const SDL_HINT_XINPUT_ENABLED: &[u8; 19] = b"SDL_XINPUT_ENABLED\0";
pub const SDL_HINT_XINPUT_USE_OLD_JOYSTICK_MAPPING: &[u8; 36] =
    b"SDL_XINPUT_USE_OLD_JOYSTICK_MAPPING\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG: &[u8; 25] = b"SDL_GAMECONTROLLERCONFIG\0";
pub const SDL_HINT_GAMECONTROLLERCONFIG_FILE: &[u8; 30] = b"SDL_GAMECONTROLLERCONFIG_FILE\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES: &[u8; 34] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES\0";
pub const SDL_HINT_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT: &[u8; 41] =
    b"SDL_GAMECONTROLLER_IGNORE_DEVICES_EXCEPT\0";
pub const SDL_HINT_JOYSTICK_ALLOW_BACKGROUND_EVENTS: &[u8; 37] =
    b"SDL_JOYSTICK_ALLOW_BACKGROUND_EVENTS\0";
pub const SDL_HINT_JOYSTICK_HIDAPI: &[u8; 20] = b"SDL_JOYSTICK_HIDAPI\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4: &[u8; 24] = b"SDL_JOYSTICK_HIDAPI_PS4\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_PS4_RUMBLE: &[u8; 31] = b"SDL_JOYSTICK_HIDAPI_PS4_RUMBLE\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_STEAM: &[u8; 26] = b"SDL_JOYSTICK_HIDAPI_STEAM\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_SWITCH: &[u8; 27] = b"SDL_JOYSTICK_HIDAPI_SWITCH\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_XBOX: &[u8; 25] = b"SDL_JOYSTICK_HIDAPI_XBOX\0";
pub const SDL_HINT_JOYSTICK_HIDAPI_GAMECUBE: &[u8; 29] = b"SDL_JOYSTICK_HIDAPI_GAMECUBE\0";
pub const SDL_HINT_ENABLE_STEAM_CONTROLLERS: &[u8; 29] = b"SDL_ENABLE_STEAM_CONTROLLERS\0";
pub const SDL_HINT_ALLOW_TOPMOST: &[u8; 18] = b"SDL_ALLOW_TOPMOST\0";
pub const SDL_HINT_TIMER_RESOLUTION: &[u8; 21] = b"SDL_TIMER_RESOLUTION\0";
pub const SDL_HINT_QTWAYLAND_CONTENT_ORIENTATION: &[u8; 34] =
    b"SDL_QTWAYLAND_CONTENT_ORIENTATION\0";
pub const SDL_HINT_QTWAYLAND_WINDOW_FLAGS: &[u8; 27] = b"SDL_QTWAYLAND_WINDOW_FLAGS\0";
pub const SDL_HINT_THREAD_STACK_SIZE: &[u8; 22] = b"SDL_THREAD_STACK_SIZE\0";
pub const SDL_HINT_VIDEO_HIGHDPI_DISABLED: &[u8; 27] = b"SDL_VIDEO_HIGHDPI_DISABLED\0";
pub const SDL_HINT_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK: &[u8; 39] =
    b"SDL_MAC_CTRL_CLICK_EMULATE_RIGHT_CLICK\0";
pub const SDL_HINT_VIDEO_WIN_D3DCOMPILER: &[u8; 26] = b"SDL_VIDEO_WIN_D3DCOMPILER\0";
pub const SDL_HINT_VIDEO_WINDOW_SHARE_PIXEL_FORMAT: &[u8; 36] =
    b"SDL_VIDEO_WINDOW_SHARE_PIXEL_FORMAT\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_URL: &[u8; 29] = b"SDL_WINRT_PRIVACY_POLICY_URL\0";
pub const SDL_HINT_WINRT_PRIVACY_POLICY_LABEL: &[u8; 31] = b"SDL_WINRT_PRIVACY_POLICY_LABEL\0";
pub const SDL_HINT_WINRT_HANDLE_BACK_BUTTON: &[u8; 29] = b"SDL_WINRT_HANDLE_BACK_BUTTON\0";
pub const SDL_HINT_VIDEO_MAC_FULLSCREEN_SPACES: &[u8; 32] = b"SDL_VIDEO_MAC_FULLSCREEN_SPACES\0";
pub const SDL_HINT_MAC_BACKGROUND_APP: &[u8; 23] = b"SDL_MAC_BACKGROUND_APP\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION: &[u8; 44] =
    b"SDL_ANDROID_APK_EXPANSION_MAIN_FILE_VERSION\0";
pub const SDL_HINT_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION: &[u8; 45] =
    b"SDL_ANDROID_APK_EXPANSION_PATCH_FILE_VERSION\0";
pub const SDL_HINT_IME_INTERNAL_EDITING: &[u8; 25] = b"SDL_IME_INTERNAL_EDITING\0";
pub const SDL_HINT_ANDROID_TRAP_BACK_BUTTON: &[u8; 29] = b"SDL_ANDROID_TRAP_BACK_BUTTON\0";
pub const SDL_HINT_ANDROID_BLOCK_ON_PAUSE: &[u8; 27] = b"SDL_ANDROID_BLOCK_ON_PAUSE\0";
pub const SDL_HINT_RETURN_KEY_HIDES_IME: &[u8; 25] = b"SDL_RETURN_KEY_HIDES_IME\0";
pub const SDL_HINT_EMSCRIPTEN_KEYBOARD_ELEMENT: &[u8; 32] = b"SDL_EMSCRIPTEN_KEYBOARD_ELEMENT\0";
pub const SDL_HINT_NO_SIGNAL_HANDLERS: &[u8; 23] = b"SDL_NO_SIGNAL_HANDLERS\0";
pub const SDL_HINT_WINDOWS_NO_CLOSE_ON_ALT_F4: &[u8; 31] = b"SDL_WINDOWS_NO_CLOSE_ON_ALT_F4\0";
pub const SDL_HINT_BMP_SAVE_LEGACY_FORMAT: &[u8; 27] = b"SDL_BMP_SAVE_LEGACY_FORMAT\0";
pub const SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING: &[u8; 34] =
    b"SDL_WINDOWS_DISABLE_THREAD_NAMING\0";
pub const SDL_HINT_RPI_VIDEO_LAYER: &[u8; 20] = b"SDL_RPI_VIDEO_LAYER\0";
pub const SDL_HINT_VIDEO_DOUBLE_BUFFER: &[u8; 24] = b"SDL_VIDEO_DOUBLE_BUFFER\0";
pub const SDL_HINT_OPENGL_ES_DRIVER: &[u8; 21] = b"SDL_OPENGL_ES_DRIVER\0";
pub const SDL_HINT_AUDIO_RESAMPLING_MODE: &[u8; 26] = b"SDL_AUDIO_RESAMPLING_MODE\0";
pub const SDL_HINT_AUDIO_CATEGORY: &[u8; 19] = b"SDL_AUDIO_CATEGORY\0";
pub const SDL_HINT_RENDER_BATCHING: &[u8; 20] = b"SDL_RENDER_BATCHING\0";
pub const SDL_HINT_EVENT_LOGGING: &[u8; 18] = b"SDL_EVENT_LOGGING\0";
pub const SDL_MAX_LOG_MESSAGE: u32 = 4096;
pub const SDL_STANDARD_GRAVITY: f64 = 9.80665;
pub const SDL_NONSHAPEABLE_WINDOW: i32 = -1;
pub const SDL_INVALID_SHAPE_ARGUMENT: i32 = -2;
pub const SDL_WINDOW_LACKS_SHAPE: i32 = -3;
pub const SDL_MAJOR_VERSION: u32 = 2;
pub const SDL_MINOR_VERSION: u32 = 0;
pub const SDL_PATCHLEVEL: u32 = 9;
pub const SDL_INIT_TIMER: u32 = 1;
pub const SDL_INIT_AUDIO: u32 = 16;
pub const SDL_INIT_VIDEO: u32 = 32;
pub const SDL_INIT_JOYSTICK: u32 = 512;
pub const SDL_INIT_HAPTIC: u32 = 4096;
pub const SDL_INIT_GAMECONTROLLER: u32 = 8192;
pub const SDL_INIT_EVENTS: u32 = 16384;
pub const SDL_INIT_SENSOR: u32 = 32768;
pub const SDL_INIT_NOPARACHUTE: u32 = 1048576;
pub const SDL_INIT_EVERYTHING: u32 = 62001;
extern "C" {
    #[doc = "  \\brief Gets the name of the platform."]
    pub fn SDL_GetPlatform() -> *const libc::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_div_t {
    pub quot: libc::c_int,
    pub rem: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_div_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_div_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_div_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_ldiv_t {
    pub quot: libc::c_long,
    pub rem: libc::c_long,
}
#[test]
fn bindgen_test_layout__PDCLIB_ldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_ldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_ldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lldiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_lldiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lldiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lldiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_imaxdiv_t {
    pub quot: libc::c_longlong,
    pub rem: libc::c_longlong,
}
#[test]
fn bindgen_test_layout__PDCLIB_imaxdiv_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_imaxdiv_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type _PDCLIB_va_list = __builtin_va_list;
pub type _PDCLIB_fd_t = *mut libc::c_void;
pub type _PDCLIB_thrd_t = *mut libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_cnd_t {
    pub eventHandles: [*mut libc::c_void; 2usize],
    pub waitCount: u32,
}
#[test]
fn bindgen_test_layout___PDCLIB_cnd_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_cnd_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_cnd_t>(),
        12usize,
        concat!("Size of: ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_cnd_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_cnd_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).eventHandles) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(eventHandles)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).waitCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_cnd_t),
            "::",
            stringify!(waitCount)
        )
    );
}
pub type _PDCLIB_cnd_t = __PDCLIB_cnd_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __PDCLIB_mtx_t {
    pub handle: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout___PDCLIB_mtx_t() {
    const UNINIT: ::core::mem::MaybeUninit<__PDCLIB_mtx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Size of: ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__PDCLIB_mtx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__PDCLIB_mtx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__PDCLIB_mtx_t),
            "::",
            stringify!(handle)
        )
    );
}
pub type _PDCLIB_mtx_t = __PDCLIB_mtx_t;
pub type _PDCLIB_tss_t = libc::c_uint;
pub type _PDCLIB_once_flag = libc::c_int;
pub type _PDCLIB_int8_t = libc::c_schar;
pub type _PDCLIB_uint8_t = libc::c_uchar;
pub type _PDCLIB_int16_t = libc::c_short;
pub type _PDCLIB_uint16_t = libc::c_ushort;
pub type _PDCLIB_int32_t = libc::c_int;
pub type _PDCLIB_uint32_t = libc::c_uint;
pub type _PDCLIB_int64_t = libc::c_longlong;
pub type _PDCLIB_uint64_t = libc::c_ulonglong;
pub type _PDCLIB_int_fast8_t = libc::c_int;
pub type _PDCLIB_uint_fast8_t = libc::c_uint;
pub type _PDCLIB_int_fast16_t = libc::c_int;
pub type _PDCLIB_uint_fast16_t = libc::c_uint;
pub type _PDCLIB_int_fast32_t = libc::c_int;
pub type _PDCLIB_uint_fast32_t = libc::c_uint;
pub type _PDCLIB_int_fast64_t = libc::c_long;
pub type _PDCLIB_uint_fast64_t = libc::c_ulong;
pub type _PDCLIB_ptrdiff_t = libc::c_int;
pub type _PDCLIB_size_t = libc::c_uint;
pub type _PDCLIB_wchar_t = libc::c_ushort;
pub type _PDCLIB_wint_t = libc::c_ushort;
pub type _PDCLIB_intptr_t = libc::c_long;
pub type _PDCLIB_uintptr_t = libc::c_ulong;
pub type _PDCLIB_intmax_t = libc::c_longlong;
pub type _PDCLIB_uintmax_t = libc::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_fpos_t {
    pub offset: _PDCLIB_uint64_t,
    pub status: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_fpos_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_fpos_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_fpos_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_fpos_t),
            "::",
            stringify!(status)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_file_t {
    pub handle: _PDCLIB_fd_t,
    pub buffer: *mut libc::c_char,
    pub bufsize: _PDCLIB_size_t,
    pub bufidx: _PDCLIB_size_t,
    pub bufend: _PDCLIB_size_t,
    pub pos: _PDCLIB_fpos_t,
    pub ungetidx: _PDCLIB_size_t,
    pub ungetbuf: *mut libc::c_uchar,
    pub status: libc::c_uint,
    pub filename: *mut libc::c_char,
    pub next: *mut _PDCLIB_file_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_file_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_file_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_file_t>(),
        64usize,
        concat!("Size of: ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_file_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_PDCLIB_file_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufsize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufidx) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bufend) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(bufend)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pos) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(pos)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetidx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetidx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ungetbuf) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(ungetbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_file_t),
            "::",
            stringify!(next)
        )
    );
}
pub type _PDCLIB_time_t = libc::c_long;
pub type _PDCLIB_clock_t = libc::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_exitfunc_t {
    pub next: *mut _PDCLIB_exitfunc_t,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
}
#[test]
fn bindgen_test_layout__PDCLIB_exitfunc_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_exitfunc_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_exitfunc_t>(),
        8usize,
        concat!("Size of: ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_exitfunc_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_exitfunc_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_exitfunc_t),
            "::",
            stringify!(func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_status_t {
    pub base: libc::c_int,
    pub flags: _PDCLIB_int_fast32_t,
    pub n: _PDCLIB_size_t,
    pub i: _PDCLIB_size_t,
    pub current: _PDCLIB_size_t,
    pub s: *mut libc::c_char,
    pub width: _PDCLIB_size_t,
    pub prec: libc::c_int,
    pub stream: *mut _PDCLIB_file_t,
    pub arg: _PDCLIB_va_list,
}
#[test]
fn bindgen_test_layout__PDCLIB_status_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_status_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_status_t>(),
        40usize,
        concat!("Size of: ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_status_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_status_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(i)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).prec) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(prec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stream) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(stream)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).arg) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_status_t),
            "::",
            stringify!(arg)
        )
    );
}
extern "C" {
    pub fn _PDCLIB_atomax(s: *const libc::c_char) -> _PDCLIB_intmax_t;
}
extern "C" {
    pub fn _PDCLIB_strtox_prelim(
        p: *const libc::c_char,
        sign: *mut libc::c_char,
        base: *mut libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_strtox_main(
        p: *mut *const libc::c_char,
        base: libc::c_uint,
        error: _PDCLIB_uintmax_t,
        limval: _PDCLIB_uintmax_t,
        limdigit: libc::c_int,
        sign: *mut libc::c_char,
    ) -> _PDCLIB_uintmax_t;
}
extern "C" {
    pub static _PDCLIB_digits: [libc::c_char; 0usize];
}
extern "C" {
    pub static _PDCLIB_Xdigits: [libc::c_char; 0usize];
}
extern "C" {
    pub fn _PDCLIB_print(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_scan(
        spec: *const libc::c_char,
        status: *mut _PDCLIB_status_t,
    ) -> *const libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_filemode(mode: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn _PDCLIB_prepread(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_prepwrite(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_closeall();
}
extern "C" {
    pub fn _PDCLIB_is_leap(year_offset: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_load_lines(
        stream: *mut _PDCLIB_file_t,
        lines: _PDCLIB_size_t,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_getstream(stream: *mut _PDCLIB_file_t) -> libc::c_int;
}
extern "C" {
    pub fn _PDCLIB_setstream(stream: *mut _PDCLIB_file_t);
}
extern "C" {
    pub fn _PDCLIB_strtok(
        s1: *mut libc::c_char,
        s1max: *mut _PDCLIB_size_t,
        s2: *const libc::c_char,
        ptr: *mut *mut libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn _PDCLIB_errno_func() -> *mut libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_numeric_t {
    pub decimal_point: *mut libc::c_char,
    pub thousands_sep: *mut libc::c_char,
    pub grouping: *mut libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_numeric_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_numeric_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_numeric_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_numeric_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_numeric_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_numeric_t),
            "::",
            stringify!(grouping)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_lconv_monetary_t {
    pub mon_decimal_point: *mut libc::c_char,
    pub mon_thousands_sep: *mut libc::c_char,
    pub mon_grouping: *mut libc::c_char,
    pub positive_sign: *mut libc::c_char,
    pub negative_sign: *mut libc::c_char,
    pub currency_symbol: *mut libc::c_char,
    pub int_curr_symbol: *mut libc::c_char,
    pub frac_digits: libc::c_char,
    pub p_cs_precedes: libc::c_char,
    pub n_cs_precedes: libc::c_char,
    pub p_sep_by_space: libc::c_char,
    pub n_sep_by_space: libc::c_char,
    pub p_sign_posn: libc::c_char,
    pub n_sign_posn: libc::c_char,
    pub int_frac_digits: libc::c_char,
    pub int_p_cs_precedes: libc::c_char,
    pub int_n_cs_precedes: libc::c_char,
    pub int_p_sep_by_space: libc::c_char,
    pub int_n_sep_by_space: libc::c_char,
    pub int_p_sign_posn: libc::c_char,
    pub int_n_sign_posn: libc::c_char,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_lconv_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_lconv_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_lconv_monetary_t>(),
        44usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_lconv_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_lconv_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_lconv_monetary_t),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_numeric_monetary_t {
    pub lconv: *mut lconv,
    pub numeric_alloced: libc::c_int,
    pub monetary_alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_numeric_monetary_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_numeric_monetary_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_numeric_monetary_t>(),
        12usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_numeric_monetary_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_numeric_monetary_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lconv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numeric_alloced) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(numeric_alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).monetary_alloced) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_numeric_monetary_t),
            "::",
            stringify!(monetary_alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_numeric_monetary: _PDCLIB_lc_numeric_monetary_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_collate_t {
    pub alloced: libc::c_int,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_collate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_collate_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_collate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_collate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_collate_t),
            "::",
            stringify!(alloced)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_collate: _PDCLIB_lc_collate_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_entry_t {
    pub flags: _PDCLIB_uint16_t,
    pub upper: libc::c_uchar,
    pub lower: libc::c_uchar,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_entry_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_entry_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_entry_t>(),
        4usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_entry_t>(),
        2usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_entry_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(upper)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_entry_t),
            "::",
            stringify!(lower)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_ctype_t {
    pub alloced: libc::c_int,
    pub digits_low: libc::c_int,
    pub digits_high: libc::c_int,
    pub Xdigits_low: libc::c_int,
    pub Xdigits_high: libc::c_int,
    pub xdigits_low: libc::c_int,
    pub xdigits_high: libc::c_int,
    pub entry: *mut _PDCLIB_lc_ctype_entry_t,
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_ctype_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_ctype_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_ctype_t>(),
        32usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_ctype_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_ctype_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_low) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).digits_high) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(digits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_low) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Xdigits_high) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(Xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_low) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_low)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xdigits_high) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(xdigits_high)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).entry) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_ctype_t),
            "::",
            stringify!(entry)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_ctype: _PDCLIB_lc_ctype_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_messages_t {
    pub alloced: libc::c_int,
    pub errno_texts: [*mut libc::c_char; 141usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_messages_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_messages_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_messages_t>(),
        568usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_messages_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_messages_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).errno_texts) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_messages_t),
            "::",
            stringify!(errno_texts)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_messages: _PDCLIB_lc_messages_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PDCLIB_lc_time_t {
    pub alloced: libc::c_int,
    pub month_name_abbr: [*mut libc::c_char; 12usize],
    pub month_name_full: [*mut libc::c_char; 12usize],
    pub day_name_abbr: [*mut libc::c_char; 7usize],
    pub day_name_full: [*mut libc::c_char; 7usize],
    pub date_time_format: *mut libc::c_char,
    pub time_format_12h: *mut libc::c_char,
    pub date_format: *mut libc::c_char,
    pub time_format: *mut libc::c_char,
    pub am_pm: [*mut libc::c_char; 2usize],
}
#[test]
fn bindgen_test_layout__PDCLIB_lc_time_t() {
    const UNINIT: ::core::mem::MaybeUninit<_PDCLIB_lc_time_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_PDCLIB_lc_time_t>(),
        180usize,
        concat!("Size of: ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_PDCLIB_lc_time_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_PDCLIB_lc_time_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).alloced) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(alloced)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_abbr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).month_name_full) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(month_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_abbr) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_abbr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).day_name_full) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(day_name_full)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_time_format) as usize - ptr as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format_12h) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format_12h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).date_format) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(date_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).time_format) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(time_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).am_pm) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_PDCLIB_lc_time_t),
            "::",
            stringify!(am_pm)
        )
    );
}
extern "C" {
    pub static mut _PDCLIB_lc_time: _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_numeric(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_numeric_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_monetary(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_lconv_monetary_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_collate(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_collate_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_ctype(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_ctype_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_time(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_time_t;
}
extern "C" {
    pub fn _PDCLIB_load_lc_messages(
        path: *const libc::c_char,
        locale: *const libc::c_char,
    ) -> *mut _PDCLIB_lc_messages_t;
}
pub const _PDCLIB_assert_568: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = libc::c_int;
pub const _PDCLIB_assert_569: _bindgen_ty_2 = 1;
pub type _bindgen_ty_2 = libc::c_int;
pub const _PDCLIB_assert_570: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = libc::c_int;
pub const _PDCLIB_assert_571: _bindgen_ty_4 = 1;
pub type _bindgen_ty_4 = libc::c_int;
pub const _PDCLIB_assert_574: _bindgen_ty_5 = 1;
pub type _bindgen_ty_5 = libc::c_int;
pub const _PDCLIB_assert_577: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = libc::c_int;
pub const _PDCLIB_assert_580: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = libc::c_int;
pub const _PDCLIB_assert_586: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = libc::c_int;
pub const _PDCLIB_assert_589: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = libc::c_int;
pub type fpos_t = _PDCLIB_fpos_t;
pub type FILE = _PDCLIB_file_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(filename: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn rename(oldpath: *const libc::c_char, newpath: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(s: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn fclose(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fflush(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fopen(filename: *const libc::c_char, mode: *const libc::c_char) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        filename: *const libc::c_char,
        mode: *const libc::c_char,
        stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(stream: *mut FILE, buf: *mut libc::c_char);
}
extern "C" {
    pub fn setvbuf(
        stream: *mut FILE,
        buf: *mut libc::c_char,
        mode: libc::c_int,
        size: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fprintf(stream: *mut FILE, format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn fscanf(stream: *mut FILE, format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn printf(format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn scanf(format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn snprintf(
        s: *mut libc::c_char,
        n: libc::c_uint,
        format: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn sprintf(s: *mut libc::c_char, format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn sscanf(s: *const libc::c_char, format: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn vfprintf(
        stream: *mut FILE,
        format: *const libc::c_char,
        arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vfscanf(
        stream: *mut FILE,
        format: *const libc::c_char,
        arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vprintf(format: *const libc::c_char, arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vscanf(format: *const libc::c_char, arg: __builtin_va_list) -> libc::c_int;
}
extern "C" {
    pub fn vsnprintf(
        s: *mut libc::c_char,
        n: libc::c_uint,
        format: *const libc::c_char,
        arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsprintf(
        s: *mut libc::c_char,
        format: *const libc::c_char,
        arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn vsscanf(
        s: *const libc::c_char,
        format: *const libc::c_char,
        arg: __builtin_va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn fgetc(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fgets(s: *mut libc::c_char, n: libc::c_int, stream: *mut FILE) -> *mut libc::c_char;
}
extern "C" {
    pub fn fputc(c: libc::c_int, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fputs(s: *const libc::c_char, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getc(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn getchar() -> libc::c_int;
}
extern "C" {
    pub fn putc(c: libc::c_int, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn putchar(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn puts(s: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn ungetc(c: libc::c_int, stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn fread(
        ptr: *mut libc::c_void,
        size: libc::c_uint,
        nmemb: libc::c_uint,
        stream: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fwrite(
        ptr: *const libc::c_void,
        size: libc::c_uint,
        nmemb: libc::c_uint,
        stream: *mut FILE,
    ) -> libc::c_uint;
}
extern "C" {
    pub fn fgetpos(stream: *mut FILE, pos: *mut fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn fseek(stream: *mut FILE, offset: libc::c_long, whence: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn fsetpos(stream: *mut FILE, pos: *const fpos_t) -> libc::c_int;
}
extern "C" {
    pub fn ftell(stream: *mut FILE) -> libc::c_long;
}
extern "C" {
    pub fn rewind(stream: *mut FILE);
}
extern "C" {
    pub fn clearerr(stream: *mut FILE);
}
extern "C" {
    pub fn feof(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn ferror(stream: *mut FILE) -> libc::c_int;
}
extern "C" {
    pub fn perror(s: *const libc::c_char);
}
extern "C" {
    pub fn atof(nptr: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn strtod(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f32;
}
extern "C" {
    pub fn strtold(nptr: *const libc::c_char, endptr: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn strtoll(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn strtoul(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn strtoull(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn atoi(nptr: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn atol(nptr: *const libc::c_char) -> libc::c_long;
}
extern "C" {
    pub fn atoll(nptr: *const libc::c_char) -> libc::c_longlong;
}
extern "C" {
    pub static mut _PDCLIB_seed: libc::c_ulong;
}
extern "C" {
    pub fn rand() -> libc::c_int;
}
extern "C" {
    pub fn srand(seed: libc::c_uint);
}
extern "C" {
    pub fn malloc(size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn calloc(nmemb: libc::c_uint, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn aligned_alloc(alignment: libc::c_uint, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn free(ptr: *mut libc::c_void);
}
extern "C" {
    pub fn realloc(ptr: *mut libc::c_void, size: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn at_quick_exit(func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn atexit(func: ::core::option::Option<unsafe extern "C" fn()>) -> libc::c_int;
}
extern "C" {
    pub fn exit(status: libc::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(status: libc::c_int);
}
extern "C" {
    pub fn _Exit(status: libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn system(string: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn bsearch(
        key: *const libc::c_void,
        base: *const libc::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn qsort(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn abs(j: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn labs(j: libc::c_long) -> libc::c_long;
}
extern "C" {
    pub fn llabs(j: libc::c_longlong) -> libc::c_longlong;
}
pub type div_t = _PDCLIB_div_t;
pub type ldiv_t = _PDCLIB_ldiv_t;
pub type lldiv_t = _PDCLIB_lldiv_t;
extern "C" {
    pub fn div(numer: libc::c_int, denom: libc::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(numer: libc::c_long, denom: libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(numer: libc::c_longlong, denom: libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn _byteswap_ushort(val: libc::c_ushort) -> libc::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(val: libc::c_ulong) -> libc::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(val: libc::c_ulonglong) -> libc::c_ulonglong;
}
pub type _purecall_handler = ::core::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_purecall_handler(function: _purecall_handler) -> _purecall_handler;
}
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = _PDCLIB_int_fast8_t;
pub type int_fast16_t = _PDCLIB_int_fast16_t;
pub type int_fast32_t = _PDCLIB_int_fast32_t;
pub type int_fast64_t = _PDCLIB_int_fast64_t;
pub type uint_fast8_t = _PDCLIB_uint_fast8_t;
pub type uint_fast16_t = _PDCLIB_uint_fast16_t;
pub type uint_fast32_t = _PDCLIB_uint_fast32_t;
pub type uint_fast64_t = _PDCLIB_uint_fast64_t;
pub type intmax_t = _PDCLIB_intmax_t;
pub type uintmax_t = _PDCLIB_uintmax_t;
pub type wchar_t = _PDCLIB_wchar_t;
pub type wint_t = _PDCLIB_wint_t;
pub type wctrans_t = libc::c_int;
pub type wctype_t = libc::c_int;
extern "C" {
    pub fn iswalnum(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswalpha(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswblank(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswcntrl(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswdigit(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswgraph(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswlower(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswprint(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswpunct(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswspace(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswupper(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswxdigit(wc: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn iswctype(wc: wint_t, desc: wctype_t) -> libc::c_int;
}
extern "C" {
    pub fn wctype(property: *const libc::c_char) -> wctype_t;
}
extern "C" {
    pub fn towlower(wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towupper(wc: wint_t) -> wint_t;
}
extern "C" {
    pub fn towctrans(wc: wint_t, desc: wctrans_t) -> wint_t;
}
extern "C" {
    pub fn wctrans(property: *const libc::c_char) -> wctrans_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct XBOXRT_mbstate {
    pub __bindgen_anon_1: XBOXRT_mbstate__bindgen_ty_1,
    pub _Surrogate: u16,
    pub _PendState: libc::c_uchar,
    pub _PendChar: libc::c_char,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union XBOXRT_mbstate__bindgen_ty_1 {
    pub _St64: [u64; 15usize],
    pub _St32: [u32; 31usize],
    pub _St16: [u16; 62usize],
    pub _StUC: [libc::c_uchar; 124usize],
    pub _StSC: [libc::c_schar; 124usize],
    pub _StC: [libc::c_char; 124usize],
}
#[test]
fn bindgen_test_layout_XBOXRT_mbstate__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<XBOXRT_mbstate__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XBOXRT_mbstate__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(XBOXRT_mbstate__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<XBOXRT_mbstate__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(XBOXRT_mbstate__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St64)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St32)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._St16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_St16)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StUC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StUC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StSC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StSC)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._StC) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate__bindgen_ty_1),
            "::",
            stringify!(_StC)
        )
    );
}
#[test]
fn bindgen_test_layout_XBOXRT_mbstate() {
    const UNINIT: ::core::mem::MaybeUninit<XBOXRT_mbstate> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<XBOXRT_mbstate>(),
        136usize,
        concat!("Size of: ", stringify!(XBOXRT_mbstate))
    );
    assert_eq!(
        ::core::mem::align_of::<XBOXRT_mbstate>(),
        8usize,
        concat!("Alignment of ", stringify!(XBOXRT_mbstate))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._Surrogate) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_Surrogate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._PendState) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_PendState)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._PendChar) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(XBOXRT_mbstate),
            "::",
            stringify!(_PendChar)
        )
    );
}
pub type XBOXRT_mbstate_t = XBOXRT_mbstate;
pub type mbstate_t = XBOXRT_mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcscpy(s1: *mut wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncpy(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemcpy(
        s1: *mut libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wmemmove(
        s1: *mut libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcscat(s1: *mut wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncat(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(s1: *const libc::c_ushort, s2: *const libc::c_ushort) -> libc::c_int;
}
extern "C" {
    pub fn wcscoll(s1: *const wchar_t, s2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn wcsncmp(
        s1: *const libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcsxfrm(s1: *mut wchar_t, s2: *const wchar_t, n: usize) -> usize;
}
extern "C" {
    pub fn wmemcmp(
        s1: *const libc::c_ushort,
        s2: *const libc::c_ushort,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn wcschr(s: *const libc::c_ushort, c: libc::c_ushort) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcscspn(s1: *const wchar_t, s2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(s1: *const wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrchr(s: *const wchar_t, c: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(s1: *const wchar_t, s2: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcsstr(s1: *const wchar_t, s2: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstok(s1: *mut wchar_t, s2: *const wchar_t, ptr: *mut *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemchr(
        s: *const libc::c_ushort,
        c: libc::c_ushort,
        n: libc::c_uint,
    ) -> *mut libc::c_ushort;
}
extern "C" {
    pub fn wcslen(s: *const libc::c_ushort) -> libc::c_uint;
}
extern "C" {
    pub fn mbsinit(ps: *const mbstate_t) -> libc::c_int;
}
extern "C" {
    pub fn mbrtowc(
        pwc: *mut wchar_t,
        s: *const libc::c_char,
        n: usize,
        ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(s: *mut libc::c_char, wc: wchar_t, ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn wmemset(wcs: *mut wchar_t, wc: wchar_t, n: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstof(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn wcstold(nptr: *const wchar_t, endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn wcstol(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn wcstoll(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        nptr: *const wchar_t,
        endptr: *mut *mut wchar_t,
        base: libc::c_int,
    ) -> libc::c_ulonglong;
}
extern "C" {
    pub fn mbrlen(s: *const libc::c_char, n: usize, ps: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn btowc(c: libc::c_int) -> wint_t;
}
extern "C" {
    pub fn mbsrtowcs(
        dest: *mut wchar_t,
        src: *mut *const libc::c_char,
        len: usize,
        ps: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wctob(c: wint_t) -> libc::c_int;
}
extern "C" {
    pub fn wcrtomb_s(
        retval: *mut usize,
        s: *mut libc::c_char,
        ssz: usize,
        wc: wchar_t,
        ps: *mut mbstate_t,
    ) -> libc::c_int;
}
extern "C" {
    pub fn _snwprintf(
        buffer: *mut wchar_t,
        count: usize,
        format: *const wchar_t,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn mbtowc(pwc: *mut wchar_t, string: *const libc::c_char, n: usize) -> libc::c_int;
}
pub type va_list = _PDCLIB_va_list;
extern "C" {
    pub fn memcpy(
        s1: *mut libc::c_void,
        s2: *const libc::c_void,
        n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn memmove(
        s1: *mut libc::c_void,
        s2: *const libc::c_void,
        n: libc::c_uint,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn strcpy(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncpy(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcat(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strncat(
        s1: *mut libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn memcmp(s1: *const libc::c_void, s2: *const libc::c_void, n: libc::c_uint)
        -> libc::c_int;
}
extern "C" {
    pub fn strcmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strcoll(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn strncmp(
        s1: *const libc::c_char,
        s2: *const libc::c_char,
        n: libc::c_uint,
    ) -> libc::c_int;
}
extern "C" {
    pub fn strxfrm(s1: *mut libc::c_char, s2: *const libc::c_char, n: libc::c_uint)
        -> libc::c_uint;
}
extern "C" {
    pub fn memchr(s: *const libc::c_void, c: libc::c_int, n: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn strchr(s: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strcspn(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strpbrk(s1: *const libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strrchr(s: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strspn(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strstr(s1: *const libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn strtok(s1: *mut libc::c_char, s2: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn memset(s: *mut libc::c_void, c: libc::c_int, n: libc::c_uint) -> *mut libc::c_void;
}
extern "C" {
    pub fn strerror(errnum: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn strlen(s: *const libc::c_char) -> libc::c_uint;
}
extern "C" {
    pub fn strdup(s: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn _strnicmp(s1: *const libc::c_char, s2: *const libc::c_char, n: usize) -> libc::c_int;
}
extern "C" {
    pub fn _stricmp(s1: *const libc::c_char, s2: *const libc::c_char) -> libc::c_int;
}
pub type imaxdiv_t = _PDCLIB_imaxdiv_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(numer: intmax_t, denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        nptr: *const libc::c_char,
        endptr: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn isalnum(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isalpha(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isblank(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn iscntrl(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isdigit(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isgraph(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn islower(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isprint(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn ispunct(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isspace(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isupper(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn isxdigit(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn tolower(c: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn toupper(c: libc::c_int) -> libc::c_int;
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassifyf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassify(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __fpclassifyl(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn __signbit(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn __signbitl(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn acos(x: f64) -> f64;
}
extern "C" {
    pub fn acosf(x: f32) -> f32;
}
extern "C" {
    pub fn acosl(x: f64) -> f64;
}
extern "C" {
    pub fn asin(x: f64) -> f64;
}
extern "C" {
    pub fn asinf(x: f32) -> f32;
}
extern "C" {
    pub fn asinl(x: f64) -> f64;
}
extern "C" {
    pub fn atan(x: f64) -> f64;
}
extern "C" {
    pub fn atanf(x: f32) -> f32;
}
extern "C" {
    pub fn atanl(x: f64) -> f64;
}
extern "C" {
    pub fn atan2(y: f64, x: f64) -> f64;
}
extern "C" {
    pub fn atan2f(y: f32, x: f32) -> f32;
}
extern "C" {
    pub fn atan2l(y: f64, x: f64) -> f64;
}
extern "C" {
    pub fn cos(x: f64) -> f64;
}
extern "C" {
    pub fn cosf(x: f32) -> f32;
}
extern "C" {
    pub fn cosl(x: f64) -> f64;
}
extern "C" {
    pub fn sin(x: f64) -> f64;
}
extern "C" {
    pub fn sinf(x: f32) -> f32;
}
extern "C" {
    pub fn sinl(x: f64) -> f64;
}
extern "C" {
    pub fn tan(x: f64) -> f64;
}
extern "C" {
    pub fn tanf(x: f32) -> f32;
}
extern "C" {
    pub fn tanl(x: f64) -> f64;
}
extern "C" {
    pub fn acosh(x: f64) -> f64;
}
extern "C" {
    pub fn acoshf(x: f32) -> f32;
}
extern "C" {
    pub fn acoshl(x: f64) -> f64;
}
extern "C" {
    pub fn asinh(x: f64) -> f64;
}
extern "C" {
    pub fn asinhf(x: f32) -> f32;
}
extern "C" {
    pub fn asinhl(x: f64) -> f64;
}
extern "C" {
    pub fn atanh(x: f64) -> f64;
}
extern "C" {
    pub fn atanhf(x: f32) -> f32;
}
extern "C" {
    pub fn atanhl(x: f64) -> f64;
}
extern "C" {
    pub fn cosh(x: f64) -> f64;
}
extern "C" {
    pub fn coshf(x: f32) -> f32;
}
extern "C" {
    pub fn coshl(x: f64) -> f64;
}
extern "C" {
    pub fn sinh(x: f64) -> f64;
}
extern "C" {
    pub fn sinhf(x: f32) -> f32;
}
extern "C" {
    pub fn sinhl(x: f64) -> f64;
}
extern "C" {
    pub fn tanh(x: f64) -> f64;
}
extern "C" {
    pub fn tanhf(x: f32) -> f32;
}
extern "C" {
    pub fn tanhl(x: f64) -> f64;
}
extern "C" {
    pub fn exp(x: f64) -> f64;
}
extern "C" {
    pub fn expf(x: f32) -> f32;
}
extern "C" {
    pub fn expl(x: f64) -> f64;
}
extern "C" {
    pub fn exp2(x: f64) -> f64;
}
extern "C" {
    pub fn exp2f(x: f32) -> f32;
}
extern "C" {
    pub fn exp2l(x: f64) -> f64;
}
extern "C" {
    pub fn expm1(x: f64) -> f64;
}
extern "C" {
    pub fn expm1f(x: f32) -> f32;
}
extern "C" {
    pub fn expm1l(x: f64) -> f64;
}
extern "C" {
    pub fn frexp(value: f64, exp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn frexpf(value: f32, exp: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn frexpl(value: f64, exp: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn ilogbf(x: f32) -> libc::c_int;
}
extern "C" {
    pub fn ilogbl(x: f64) -> libc::c_int;
}
extern "C" {
    pub fn ldexp(x: f64, exp: libc::c_int) -> f64;
}
extern "C" {
    pub fn ldexpf(x: f32, exp: libc::c_int) -> f32;
}
extern "C" {
    pub fn ldexpl(x: f64, exp: libc::c_int) -> f64;
}
extern "C" {
    pub fn log(x: f64) -> f64;
}
extern "C" {
    pub fn logf(x: f32) -> f32;
}
extern "C" {
    pub fn logl(x: f64) -> f64;
}
extern "C" {
    pub fn log10(x: f64) -> f64;
}
extern "C" {
    pub fn log10f(x: f32) -> f32;
}
extern "C" {
    pub fn log10l(x: f64) -> f64;
}
extern "C" {
    pub fn log1p(x: f64) -> f64;
}
extern "C" {
    pub fn log1pf(x: f32) -> f32;
}
extern "C" {
    pub fn log1pl(x: f64) -> f64;
}
extern "C" {
    pub fn log2(x: f64) -> f64;
}
extern "C" {
    pub fn log2f(x: f32) -> f32;
}
extern "C" {
    pub fn log2l(x: f64) -> f64;
}
extern "C" {
    pub fn logb(x: f64) -> f64;
}
extern "C" {
    pub fn logbf(x: f32) -> f32;
}
extern "C" {
    pub fn logbl(x: f64) -> f64;
}
extern "C" {
    pub fn modf(value: f64, iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn modff(value: f32, iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn modfl(value: f64, iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
    pub fn scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
    pub fn scalbnl(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
    pub fn scalbln(x: f64, n: libc::c_long) -> f64;
}
extern "C" {
    pub fn scalblnf(x: f32, n: libc::c_long) -> f32;
}
extern "C" {
    pub fn scalblnl(x: f64, n: libc::c_long) -> f64;
}
extern "C" {
    pub fn cbrt(x: f64) -> f64;
}
extern "C" {
    pub fn cbrtf(x: f32) -> f32;
}
extern "C" {
    pub fn cbrtl(x: f64) -> f64;
}
extern "C" {
    pub fn fabs(x: f64) -> f64;
}
extern "C" {
    pub fn fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn fabsl(x: f64) -> f64;
}
extern "C" {
    pub fn hypot(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn hypotf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn hypotl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn powf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn powl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn sqrtl(x: f64) -> f64;
}
extern "C" {
    pub fn erf(x: f64) -> f64;
}
extern "C" {
    pub fn erff(x: f32) -> f32;
}
extern "C" {
    pub fn erfl(x: f64) -> f64;
}
extern "C" {
    pub fn erfc(x: f64) -> f64;
}
extern "C" {
    pub fn erfcf(x: f32) -> f32;
}
extern "C" {
    pub fn erfcl(x: f64) -> f64;
}
extern "C" {
    pub fn lgamma(x: f64) -> f64;
}
extern "C" {
    pub fn lgammaf(x: f32) -> f32;
}
extern "C" {
    pub fn lgammal(x: f64) -> f64;
}
extern "C" {
    pub fn tgamma(x: f64) -> f64;
}
extern "C" {
    pub fn tgammaf(x: f32) -> f32;
}
extern "C" {
    pub fn tgammal(x: f64) -> f64;
}
extern "C" {
    pub fn ceil(x: f64) -> f64;
}
extern "C" {
    pub fn ceilf(x: f32) -> f32;
}
extern "C" {
    pub fn ceill(x: f64) -> f64;
}
extern "C" {
    pub fn floor(x: f64) -> f64;
}
extern "C" {
    pub fn floorf(x: f32) -> f32;
}
extern "C" {
    pub fn floorl(x: f64) -> f64;
}
extern "C" {
    pub fn nearbyint(x: f64) -> f64;
}
extern "C" {
    pub fn nearbyintf(x: f32) -> f32;
}
extern "C" {
    pub fn nearbyintl(x: f64) -> f64;
}
extern "C" {
    pub fn rint(x: f64) -> f64;
}
extern "C" {
    pub fn rintf(x: f32) -> f32;
}
extern "C" {
    pub fn rintl(x: f64) -> f64;
}
extern "C" {
    pub fn lrint(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn lrintf(x: f32) -> libc::c_long;
}
extern "C" {
    pub fn lrintl(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llrint(x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn llrintf(x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn llrintl(x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn round(x: f64) -> f64;
}
extern "C" {
    pub fn roundf(x: f32) -> f32;
}
extern "C" {
    pub fn roundl(x: f64) -> f64;
}
extern "C" {
    pub fn lround(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn lroundf(x: f32) -> libc::c_long;
}
extern "C" {
    pub fn lroundl(x: f64) -> libc::c_long;
}
extern "C" {
    pub fn llround(x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn llroundf(x: f32) -> libc::c_longlong;
}
extern "C" {
    pub fn llroundl(x: f64) -> libc::c_longlong;
}
extern "C" {
    pub fn trunc(x: f64) -> f64;
}
extern "C" {
    pub fn truncf(x: f32) -> f32;
}
extern "C" {
    pub fn truncl(x: f64) -> f64;
}
extern "C" {
    pub fn fmod(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn fmodl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn remainder(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn remainderf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn remainderl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn remquo(x: f64, y: f64, quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn remquof(x: f32, y: f32, quo: *mut libc::c_int) -> f32;
}
extern "C" {
    pub fn remquol(x: f64, y: f64, quo: *mut libc::c_int) -> f64;
}
extern "C" {
    pub fn copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn copysignl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn nan(tagp: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn nanf(tagp: *const libc::c_char) -> f32;
}
extern "C" {
    pub fn nanl(tagp: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn nextafter(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn nextafterf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn nextafterl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn nexttowardf(x: f32, y: f64) -> f32;
}
extern "C" {
    pub fn nexttowardl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fdim(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fdimf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn fdiml(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fmax(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fmaxf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn fmaxl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fmin(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fminf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn fminl(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn fma(x: f64, y: f64, z: f64) -> f64;
}
extern "C" {
    pub fn fmaf(x: f32, y: f32, z: f32) -> f32;
}
extern "C" {
    pub fn fmal(x: f64, y: f64, z: f64) -> f64;
}
pub const SDL_bool_SDL_FALSE: SDL_bool = 0;
pub const SDL_bool_SDL_TRUE: SDL_bool = 1;
pub type SDL_bool = libc::c_int;
pub type Sint8 = i8;
pub type Uint8 = u8;
pub type Sint16 = i16;
pub type Uint16 = u16;
pub type Sint32 = i32;
pub type Uint32 = u32;
pub type Sint64 = i64;
pub type Uint64 = u64;
pub type SDL_compile_time_assert_uint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint8 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint16 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint32 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_uint64 = [libc::c_int; 1usize];
pub type SDL_compile_time_assert_sint64 = [libc::c_int; 1usize];
pub const SDL_DUMMY_ENUM_DUMMY_ENUM_VALUE: SDL_DUMMY_ENUM = 0;
pub type SDL_DUMMY_ENUM = libc::c_int;
pub type SDL_compile_time_assert_enum = [libc::c_int; 1usize];
extern "C" {
    pub fn SDL_malloc(size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_calloc(nmemb: usize, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_realloc(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_free(mem: *mut libc::c_void);
}
pub type SDL_malloc_func =
    ::core::option::Option<unsafe extern "C" fn(size: usize) -> *mut libc::c_void>;
pub type SDL_calloc_func =
    ::core::option::Option<unsafe extern "C" fn(nmemb: usize, size: usize) -> *mut libc::c_void>;
pub type SDL_realloc_func = ::core::option::Option<
    unsafe extern "C" fn(mem: *mut libc::c_void, size: usize) -> *mut libc::c_void,
>;
pub type SDL_free_func = ::core::option::Option<unsafe extern "C" fn(mem: *mut libc::c_void)>;
extern "C" {
    #[doc = "  \\brief Get the current set of SDL memory functions"]
    pub fn SDL_GetMemoryFunctions(
        malloc_func: *mut SDL_malloc_func,
        calloc_func: *mut SDL_calloc_func,
        realloc_func: *mut SDL_realloc_func,
        free_func: *mut SDL_free_func,
    );
}
extern "C" {
    #[doc = "  \\brief Replace SDL's memory allocation functions with a custom set\n\n  \\note If you are replacing SDL's memory functions, you should call\n        SDL_GetNumAllocations() and be very careful if it returns non-zero.\n        That means that your free function will be called with memory\n        allocated by the previous memory allocation functions."]
    pub fn SDL_SetMemoryFunctions(
        malloc_func: SDL_malloc_func,
        calloc_func: SDL_calloc_func,
        realloc_func: SDL_realloc_func,
        free_func: SDL_free_func,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the number of outstanding (unfreed) allocations"]
    pub fn SDL_GetNumAllocations() -> libc::c_int;
}
extern "C" {
    pub fn SDL_getenv(name: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_setenv(
        name: *const libc::c_char,
        value: *const libc::c_char,
        overwrite: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_qsort(
        base: *mut libc::c_void,
        nmemb: usize,
        size: usize,
        compare: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *const libc::c_void,
                arg2: *const libc::c_void,
            ) -> libc::c_int,
        >,
    );
}
extern "C" {
    pub fn SDL_abs(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isdigit(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_isspace(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_toupper(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_tolower(x: libc::c_int) -> libc::c_int;
}
extern "C" {
    pub fn SDL_memset(dst: *mut libc::c_void, c: libc::c_int, len: usize) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcpy(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memmove(
        dst: *mut libc::c_void,
        src: *const libc::c_void,
        len: usize,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_memcmp(s1: *const libc::c_void, s2: *const libc::c_void, len: usize) -> libc::c_int;
}
extern "C" {
    pub fn SDL_wcsdup(wstr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn SDL_wcslen(wstr: *const wchar_t) -> usize;
}
extern "C" {
    pub fn SDL_wcslcpy(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcslcat(dst: *mut wchar_t, src: *const wchar_t, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_wcscmp(str1: *const wchar_t, str2: *const wchar_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strlen(str_: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn SDL_strlcpy(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_utf8strlcpy(
        dst: *mut libc::c_char,
        src: *const libc::c_char,
        dst_bytes: usize,
    ) -> usize;
}
extern "C" {
    pub fn SDL_strlcat(dst: *mut libc::c_char, src: *const libc::c_char, maxlen: usize) -> usize;
}
extern "C" {
    pub fn SDL_strdup(str_: *const libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrev(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strupr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strlwr(str_: *mut libc::c_char) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strrchr(str_: *const libc::c_char, c: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_strstr(
        haystack: *const libc::c_char,
        needle: *const libc::c_char,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_utf8strlen(str_: *const libc::c_char) -> usize;
}
extern "C" {
    pub fn SDL_itoa(
        value: libc::c_int,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_uitoa(
        value: libc::c_uint,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ltoa(
        value: libc::c_long,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ultoa(
        value: libc::c_ulong,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_lltoa(
        value: Sint64,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_ulltoa(
        value: Uint64,
        str_: *mut libc::c_char,
        radix: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    pub fn SDL_atoi(str_: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_atof(str_: *const libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strtol(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_long;
}
extern "C" {
    pub fn SDL_strtoul(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> libc::c_ulong;
}
extern "C" {
    pub fn SDL_strtoll(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Sint64;
}
extern "C" {
    pub fn SDL_strtoull(
        str_: *const libc::c_char,
        endp: *mut *mut libc::c_char,
        base: libc::c_int,
    ) -> Uint64;
}
extern "C" {
    pub fn SDL_strtod(str_: *const libc::c_char, endp: *mut *mut libc::c_char) -> f64;
}
extern "C" {
    pub fn SDL_strcmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        maxlen: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strcasecmp(str1: *const libc::c_char, str2: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_strncasecmp(
        str1: *const libc::c_char,
        str2: *const libc::c_char,
        len: usize,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_sscanf(text: *const libc::c_char, fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsscanf(
        text: *const libc::c_char,
        fmt: *const libc::c_char,
        ap: va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_snprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ...
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_vsnprintf(
        text: *mut libc::c_char,
        maxlen: usize,
        fmt: *const libc::c_char,
        ap: va_list,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_acos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_acosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_asin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_asinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_atanf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_atan2(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_atan2f(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_ceil(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_ceilf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_copysign(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_copysignf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_cos(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_cosf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_exp(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_expf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fabs(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_fabsf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_floor(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_floorf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_fmod(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_fmodf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_log(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_logf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_log10(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_log10f(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_pow(x: f64, y: f64) -> f64;
}
extern "C" {
    pub fn SDL_powf(x: f32, y: f32) -> f32;
}
extern "C" {
    pub fn SDL_scalbn(x: f64, n: libc::c_int) -> f64;
}
extern "C" {
    pub fn SDL_scalbnf(x: f32, n: libc::c_int) -> f32;
}
extern "C" {
    pub fn SDL_sin(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sinf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_sqrt(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_sqrtf(x: f32) -> f32;
}
extern "C" {
    pub fn SDL_tan(x: f64) -> f64;
}
extern "C" {
    pub fn SDL_tanf(x: f32) -> f32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_iconv_t {
    _unused: [u8; 0],
}
pub type SDL_iconv_t = *mut _SDL_iconv_t;
extern "C" {
    pub fn SDL_iconv_open(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
    ) -> SDL_iconv_t;
}
extern "C" {
    pub fn SDL_iconv_close(cd: SDL_iconv_t) -> libc::c_int;
}
extern "C" {
    pub fn SDL_iconv(
        cd: SDL_iconv_t,
        inbuf: *mut *const libc::c_char,
        inbytesleft: *mut usize,
        outbuf: *mut *mut libc::c_char,
        outbytesleft: *mut usize,
    ) -> usize;
}
extern "C" {
    #[doc = "  This function converts a string between encodings in one pass, returning a\n  string that must be freed with SDL_free() or NULL on error."]
    pub fn SDL_iconv_string(
        tocode: *const libc::c_char,
        fromcode: *const libc::c_char,
        inbuf: *const libc::c_char,
        inbytesleft: usize,
    ) -> *mut libc::c_char;
}
#[doc = "  The prototype for the application's main() function"]
pub type SDL_main_func = ::core::option::Option<
    unsafe extern "C" fn(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int,
>;
extern "C" {
    pub fn SDL_main(argc: libc::c_int, argv: *mut *mut libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = "  This is called by the real SDL main function to let the rest of the\n  library know that initialization was done properly.\n\n  Calling this yourself without knowing what you're doing can cause\n  crashes and hard to diagnose problems with your application."]
    pub fn SDL_SetMainReady();
}
extern "C" {
    #[doc = "  This can be called to set the application class at startup"]
    pub fn SDL_RegisterApp(
        name: *mut libc::c_char,
        style: Uint32,
        hInst: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    pub fn SDL_UnregisterApp();
}
extern "C" {
    pub fn __debugbreak();
}
#[doc = "< Retry the assert immediately."]
pub const SDL_AssertState_SDL_ASSERTION_RETRY: SDL_AssertState = 0;
#[doc = "< Make the debugger trigger a breakpoint."]
pub const SDL_AssertState_SDL_ASSERTION_BREAK: SDL_AssertState = 1;
#[doc = "< Terminate the program."]
pub const SDL_AssertState_SDL_ASSERTION_ABORT: SDL_AssertState = 2;
#[doc = "< Ignore the assert."]
pub const SDL_AssertState_SDL_ASSERTION_IGNORE: SDL_AssertState = 3;
#[doc = "< Ignore the assert from now on."]
pub const SDL_AssertState_SDL_ASSERTION_ALWAYS_IGNORE: SDL_AssertState = 4;
pub type SDL_AssertState = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AssertData {
    pub always_ignore: libc::c_int,
    pub trigger_count: libc::c_uint,
    pub condition: *const libc::c_char,
    pub filename: *const libc::c_char,
    pub linenum: libc::c_int,
    pub function: *const libc::c_char,
    pub next: *const SDL_AssertData,
}
#[test]
fn bindgen_test_layout_SDL_AssertData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AssertData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AssertData>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AssertData>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AssertData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).always_ignore) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(always_ignore)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).trigger_count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(trigger_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).condition) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).linenum) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(linenum)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).function) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AssertData),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    pub fn SDL_ReportAssertion(
        arg1: *mut SDL_AssertData,
        arg2: *const libc::c_char,
        arg3: *const libc::c_char,
        arg4: libc::c_int,
    ) -> SDL_AssertState;
}
pub type SDL_AssertionHandler = ::core::option::Option<
    unsafe extern "C" fn(
        data: *const SDL_AssertData,
        userdata: *mut libc::c_void,
    ) -> SDL_AssertState,
>;
extern "C" {
    #[doc = "  \\brief Set an application-defined assertion handler.\n\n  This allows an app to show its own assertion UI and/or force the\n  response to an assertion failure. If the app doesn't provide this, SDL\n  will try to do the right thing, popping up a system-specific GUI dialog,\n  and probably minimizing any fullscreen windows.\n\n  This callback may fire from any thread, but it runs wrapped in a mutex, so\n  it will only fire from one thread at a time.\n\n  Setting the callback to NULL restores SDL's original internal handler.\n\n  This callback is NOT reset to SDL's internal handler upon SDL_Quit()!\n\n  Return SDL_AssertState value of how to handle the assertion failure.\n\n  \\param handler Callback function, called when an assertion fails.\n  \\param userdata A pointer passed to the callback as-is."]
    pub fn SDL_SetAssertionHandler(handler: SDL_AssertionHandler, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "  \\brief Get the default assertion handler.\n\n  This returns the function pointer that is called by default when an\n   assertion is triggered. This is an internal function provided by SDL,\n   that is used for assertions when SDL_SetAssertionHandler() hasn't been\n   used to provide a different function.\n\n  \\return The default SDL_AssertionHandler that is called when an assert triggers."]
    pub fn SDL_GetDefaultAssertionHandler() -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = "  \\brief Get the current assertion handler.\n\n  This returns the function pointer that is called when an assertion is\n   triggered. This is either the value last passed to\n   SDL_SetAssertionHandler(), or if no application-specified function is\n   set, is equivalent to calling SDL_GetDefaultAssertionHandler().\n\n   \\param puserdata Pointer to a void*, which will store the \"userdata\"\n                    pointer that was passed to SDL_SetAssertionHandler().\n                    This value will always be NULL for the default handler.\n                    If you don't care about this data, it is safe to pass\n                    a NULL pointer to this function to ignore it.\n  \\return The SDL_AssertionHandler that is called when an assert triggers."]
    pub fn SDL_GetAssertionHandler(puserdata: *mut *mut libc::c_void) -> SDL_AssertionHandler;
}
extern "C" {
    #[doc = "  \\brief Get a list of all assertion failures.\n\n  Get all assertions triggered since last call to SDL_ResetAssertionReport(),\n  or the start of the program.\n\n  The proper way to examine this data looks something like this:\n\n  <code>\n  const SDL_AssertData *item = SDL_GetAssertionReport();\n  while (item) {\n      printf(\"'%s', %s (%s:%d), triggered %u times, always ignore: %s.\\\\n\",\n             item->condition, item->function, item->filename,\n             item->linenum, item->trigger_count,\n             item->always_ignore ? \"yes\" : \"no\");\n      item = item->next;\n  }\n  </code>\n\n  \\return List of all assertions.\n  \\sa SDL_ResetAssertionReport"]
    pub fn SDL_GetAssertionReport() -> *const SDL_AssertData;
}
extern "C" {
    #[doc = "  \\brief Reset the list of all assertion failures.\n\n  Reset list of all assertions triggered.\n\n  \\sa SDL_GetAssertionReport"]
    pub fn SDL_ResetAssertionReport();
}
pub type SDL_SpinLock = libc::c_int;
extern "C" {
    #[doc = " \\brief Try to lock a spin lock by setting it to a non-zero value.\n\n \\param lock Points to the lock.\n\n \\return SDL_TRUE if the lock succeeded, SDL_FALSE if the lock is already held."]
    pub fn SDL_AtomicTryLock(lock: *mut SDL_SpinLock) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Lock a spin lock by setting it to a non-zero value.\n\n \\param lock Points to the lock."]
    pub fn SDL_AtomicLock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " \\brief Unlock a spin lock by setting it to 0. Always returns immediately\n\n \\param lock Points to the lock."]
    pub fn SDL_AtomicUnlock(lock: *mut SDL_SpinLock);
}
extern "C" {
    #[doc = " Memory barriers are designed to prevent reads and writes from being\n reordered by the compiler and being seen out of order on multi-core CPUs.\n\n A typical pattern would be for thread A to write some data and a flag,\n and for thread B to read the flag and get the data. In this case you\n would insert a release barrier between writing the data and the flag,\n guaranteeing that the data write completes no later than the flag is\n written, and you would insert an acquire barrier between reading the\n flag and reading the data, to ensure that all the reads associated\n with the flag have completed.\n\n In this pattern you should always see a release barrier paired with\n an acquire barrier and you should gate the data reads/writes with a\n single flag variable.\n\n For more information on these semantics, take a look at the blog post:\n http://preshing.com/20120913/acquire-and-release-semantics"]
    pub fn SDL_MemoryBarrierReleaseFunction();
}
extern "C" {
    pub fn SDL_MemoryBarrierAcquireFunction();
}
#[doc = " \\brief A type representing an atomic integer value.  It is a struct\n        so people don't accidentally use numeric operations on it."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_atomic_t {
    pub value: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_atomic_t() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_atomic_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_atomic_t>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_atomic_t>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_atomic_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_atomic_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = " \\brief Set an atomic variable to a new value if it is currently an old value.\n\n \\return SDL_TRUE if the atomic variable was set, SDL_FALSE otherwise.\n\n \\note If you don't know what this function is for, you shouldn't use it!"]
    pub fn SDL_AtomicCAS(
        a: *mut SDL_atomic_t,
        oldval: libc::c_int,
        newval: libc::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set an atomic variable to a value.\n\n \\return The previous value of the atomic variable."]
    pub fn SDL_AtomicSet(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the value of an atomic variable"]
    pub fn SDL_AtomicGet(a: *mut SDL_atomic_t) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Add to an atomic variable.\n\n \\return The previous value of the atomic variable.\n\n \\note This same style can be used for any number operation"]
    pub fn SDL_AtomicAdd(a: *mut SDL_atomic_t, v: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Set a pointer to a new value if it is currently an old value.\n\n \\return SDL_TRUE if the pointer was set, SDL_FALSE otherwise.\n\n \\note If you don't know what this function is for, you shouldn't use it!"]
    pub fn SDL_AtomicCASPtr(
        a: *mut *mut libc::c_void,
        oldval: *mut libc::c_void,
        newval: *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set a pointer to a value atomically.\n\n \\return The previous value of the pointer."]
    pub fn SDL_AtomicSetPtr(a: *mut *mut libc::c_void, v: *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    #[doc = " \\brief Get the value of a pointer atomically."]
    pub fn SDL_AtomicGetPtr(a: *mut *mut libc::c_void) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_SetError(fmt: *const libc::c_char, ...) -> libc::c_int;
}
extern "C" {
    pub fn SDL_GetError() -> *const libc::c_char;
}
extern "C" {
    pub fn SDL_ClearError();
}
pub const SDL_errorcode_SDL_ENOMEM: SDL_errorcode = 0;
pub const SDL_errorcode_SDL_EFREAD: SDL_errorcode = 1;
pub const SDL_errorcode_SDL_EFWRITE: SDL_errorcode = 2;
pub const SDL_errorcode_SDL_EFSEEK: SDL_errorcode = 3;
pub const SDL_errorcode_SDL_UNSUPPORTED: SDL_errorcode = 4;
pub const SDL_errorcode_SDL_LASTERROR: SDL_errorcode = 5;
pub type SDL_errorcode = libc::c_int;
extern "C" {
    pub fn SDL_Error(code: SDL_errorcode) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_mutex {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  Create a mutex, initialized unlocked."]
    pub fn SDL_CreateMutex() -> *mut SDL_mutex;
}
extern "C" {
    pub fn SDL_LockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = "  Try to lock the mutex\n\n  \\return 0, SDL_MUTEX_TIMEDOUT, or -1 on error"]
    pub fn SDL_TryLockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    pub fn SDL_UnlockMutex(mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = "  Destroy a mutex."]
    pub fn SDL_DestroyMutex(mutex: *mut SDL_mutex);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_semaphore {
    _unused: [u8; 0],
}
pub type SDL_sem = SDL_semaphore;
extern "C" {
    #[doc = "  Create a semaphore, initialized with value, returns NULL on failure."]
    pub fn SDL_CreateSemaphore(initial_value: Uint32) -> *mut SDL_sem;
}
extern "C" {
    #[doc = "  Destroy a semaphore."]
    pub fn SDL_DestroySemaphore(sem: *mut SDL_sem);
}
extern "C" {
    #[doc = "  This function suspends the calling thread until the semaphore pointed\n  to by \\c sem has a positive count. It then atomically decreases the\n  semaphore count."]
    pub fn SDL_SemWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = "  Non-blocking variant of SDL_SemWait().\n\n  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait would\n          block, and -1 on error."]
    pub fn SDL_SemTryWait(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = "  Variant of SDL_SemWait() with a timeout in milliseconds.\n\n  \\return 0 if the wait succeeds, ::SDL_MUTEX_TIMEDOUT if the wait does not\n          succeed in the allotted time, and -1 on error.\n\n  \\warning On some platforms this function is implemented by looping with a\n           delay of 1 ms, and so should be avoided if possible."]
    pub fn SDL_SemWaitTimeout(sem: *mut SDL_sem, ms: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = "  Atomically increases the semaphore's count (not blocking).\n\n  \\return 0, or -1 on error."]
    pub fn SDL_SemPost(sem: *mut SDL_sem) -> libc::c_int;
}
extern "C" {
    #[doc = "  Returns the current count of the semaphore."]
    pub fn SDL_SemValue(sem: *mut SDL_sem) -> Uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_cond {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  Create a condition variable.\n\n  Typical use of condition variables:\n\n  Thread A:\n    SDL_LockMutex(lock);\n    while ( ! condition ) {\n        SDL_CondWait(cond, lock);\n    }\n    SDL_UnlockMutex(lock);\n\n  Thread B:\n    SDL_LockMutex(lock);\n    ...\n    condition = true;\n    ...\n    SDL_CondSignal(cond);\n    SDL_UnlockMutex(lock);\n\n  There is some discussion whether to signal the condition variable\n  with the mutex locked or not.  There is some potential performance\n  benefit to unlocking first on some platforms, but there are some\n  potential race conditions depending on how your code is structured.\n\n  In general it's safer to signal the condition variable while the\n  mutex is locked."]
    pub fn SDL_CreateCond() -> *mut SDL_cond;
}
extern "C" {
    #[doc = "  Destroy a condition variable."]
    pub fn SDL_DestroyCond(cond: *mut SDL_cond);
}
extern "C" {
    #[doc = "  Restart one of the threads that are waiting on the condition variable.\n\n  \\return 0 or -1 on error."]
    pub fn SDL_CondSignal(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
    #[doc = "  Restart all threads that are waiting on the condition variable.\n\n  \\return 0 or -1 on error."]
    pub fn SDL_CondBroadcast(cond: *mut SDL_cond) -> libc::c_int;
}
extern "C" {
    #[doc = "  Wait on the condition variable, unlocking the provided mutex.\n\n  \\warning The mutex must be locked before entering this function!\n\n  The mutex is re-locked once the condition variable is signaled.\n\n  \\return 0 when it is signaled, or -1 on error."]
    pub fn SDL_CondWait(cond: *mut SDL_cond, mutex: *mut SDL_mutex) -> libc::c_int;
}
extern "C" {
    #[doc = "  Waits for at most \\c ms milliseconds, and returns 0 if the condition\n  variable is signaled, ::SDL_MUTEX_TIMEDOUT if the condition is not\n  signaled in the allotted time, and -1 on error.\n\n  \\warning On some platforms this function is implemented by looping with a\n           delay of 1 ms, and so should be avoided if possible."]
    pub fn SDL_CondWaitTimeout(
        cond: *mut SDL_cond,
        mutex: *mut SDL_mutex,
        ms: Uint32,
    ) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Thread {
    _unused: [u8; 0],
}
pub type SDL_threadID = libc::c_ulong;
pub type SDL_TLSID = libc::c_uint;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_LOW: SDL_ThreadPriority = 0;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_NORMAL: SDL_ThreadPriority = 1;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_HIGH: SDL_ThreadPriority = 2;
pub const SDL_ThreadPriority_SDL_THREAD_PRIORITY_TIME_CRITICAL: SDL_ThreadPriority = 3;
#[doc = "  The SDL thread priority.\n\n  \\note On many systems you require special privileges to set high or time critical priority."]
pub type SDL_ThreadPriority = libc::c_int;
#[doc = "  The function passed to SDL_CreateThread().\n  It is passed a void* user context parameter and returns an int."]
pub type SDL_ThreadFunction =
    ::core::option::Option<unsafe extern "C" fn(data: *mut libc::c_void) -> libc::c_int>;
extern "C" {
    #[doc = "  Create a thread with a default stack size.\n\n  This is equivalent to calling:\n  SDL_CreateThreadWithStackSize(fn, name, 0, data);"]
    pub fn SDL_CreateThread(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = "  Create a thread.\n\n   Thread naming is a little complicated: Most systems have very small\n    limits for the string length (Haiku has 32 bytes, Linux currently has 16,\n    Visual C++ 6.0 has nine!), and possibly other arbitrary rules. You'll\n    have to see what happens with your system's debugger. The name should be\n    UTF-8 (but using the naming limits of C identifiers is a better bet).\n   There are no requirements for thread naming conventions, so long as the\n    string is null-terminated UTF-8, but these guidelines are helpful in\n    choosing a name:\n\n    http://stackoverflow.com/questions/149932/naming-conventions-for-threads\n\n   If a system imposes requirements, SDL will try to munge the string for\n    it (truncate, etc), but the original string contents will be available\n    from SDL_GetThreadName().\n\n   The size (in bytes) of the new stack can be specified. Zero means \"use\n    the system default\" which might be wildly different between platforms\n    (x86 Linux generally defaults to eight megabytes, an embedded device\n    might be a few kilobytes instead).\n\n   In SDL 2.1, stacksize will be folded into the original SDL_CreateThread\n    function."]
    pub fn SDL_CreateThreadWithStackSize(
        fn_: SDL_ThreadFunction,
        name: *const libc::c_char,
        stacksize: usize,
        data: *mut libc::c_void,
    ) -> *mut SDL_Thread;
}
extern "C" {
    #[doc = " Get the thread name, as it was specified in SDL_CreateThread().\n  This function returns a pointer to a UTF-8 string that names the\n  specified thread, or NULL if it doesn't have a name. This is internal\n  memory, not to be free()'d by the caller, and remains valid until the\n  specified thread is cleaned up by SDL_WaitThread()."]
    pub fn SDL_GetThreadName(thread: *mut SDL_Thread) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the thread identifier for the current thread."]
    pub fn SDL_ThreadID() -> SDL_threadID;
}
extern "C" {
    #[doc = "  Get the thread identifier for the specified thread.\n\n  Equivalent to SDL_ThreadID() if the specified thread is NULL."]
    pub fn SDL_GetThreadID(thread: *mut SDL_Thread) -> SDL_threadID;
}
extern "C" {
    #[doc = "  Set the priority for the current thread"]
    pub fn SDL_SetThreadPriority(priority: SDL_ThreadPriority) -> libc::c_int;
}
extern "C" {
    #[doc = "  Wait for a thread to finish. Threads that haven't been detached will\n  remain (as a \"zombie\") until this function cleans them up. Not doing so\n  is a resource leak.\n\n  Once a thread has been cleaned up through this function, the SDL_Thread\n  that references it becomes invalid and should not be referenced again.\n  As such, only one thread may call SDL_WaitThread() on another.\n\n  The return code for the thread function is placed in the area\n  pointed to by \\c status, if \\c status is not NULL.\n\n  You may not wait on a thread that has been used in a call to\n  SDL_DetachThread(). Use either that function or this one, but not\n  both, or behavior is undefined.\n\n  It is safe to pass NULL to this function; it is a no-op."]
    pub fn SDL_WaitThread(thread: *mut SDL_Thread, status: *mut libc::c_int);
}
extern "C" {
    #[doc = "  A thread may be \"detached\" to signify that it should not remain until\n  another thread has called SDL_WaitThread() on it. Detaching a thread\n  is useful for long-running threads that nothing needs to synchronize\n  with or further manage. When a detached thread is done, it simply\n  goes away.\n\n  There is no way to recover the return code of a detached thread. If you\n  need this, don't detach the thread and instead use SDL_WaitThread().\n\n  Once a thread is detached, you should usually assume the SDL_Thread isn't\n  safe to reference again, as it will become invalid immediately upon\n  the detached thread's exit, instead of remaining until someone has called\n  SDL_WaitThread() to finally clean it up. As such, don't detach the same\n  thread more than once.\n\n  If a thread has already exited when passed to SDL_DetachThread(), it will\n  stop waiting for a call to SDL_WaitThread() and clean up immediately.\n  It is not safe to detach a thread that might be used with SDL_WaitThread().\n\n  You may not call SDL_WaitThread() on a thread that has been detached.\n  Use either that function or this one, but not both, or behavior is\n  undefined.\n\n  It is safe to pass NULL to this function; it is a no-op."]
    pub fn SDL_DetachThread(thread: *mut SDL_Thread);
}
extern "C" {
    #[doc = "  \\brief Create an identifier that is globally visible to all threads but refers to data that is thread-specific.\n\n  \\return The newly created thread local storage identifier, or 0 on error\n\n  \\code\n  static SDL_SpinLock tls_lock;\n  static SDL_TLSID thread_local_storage;\n\n  void SetMyThreadData(void *value)\n  {\n      if (!thread_local_storage) {\n          SDL_AtomicLock(&tls_lock);\n          if (!thread_local_storage) {\n              thread_local_storage = SDL_TLSCreate();\n          }\n          SDL_AtomicUnlock(&tls_lock);\n      }\n      SDL_TLSSet(thread_local_storage, value, 0);\n  }\n\n  void *GetMyThreadData(void)\n  {\n      return SDL_TLSGet(thread_local_storage);\n  }\n  \\endcode\n\n  \\sa SDL_TLSGet()\n  \\sa SDL_TLSSet()"]
    pub fn SDL_TLSCreate() -> SDL_TLSID;
}
extern "C" {
    #[doc = "  \\brief Get the value associated with a thread local storage ID for the current thread.\n\n  \\param id The thread local storage ID\n\n  \\return The value associated with the ID for the current thread, or NULL if no value has been set.\n\n  \\sa SDL_TLSCreate()\n  \\sa SDL_TLSSet()"]
    pub fn SDL_TLSGet(id: SDL_TLSID) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  \\brief Set the value associated with a thread local storage ID for the current thread.\n\n  \\param id The thread local storage ID\n  \\param value The value to associate with the ID for the current thread\n  \\param destructor A function called when the thread exits, to free the value.\n\n  \\return 0 on success, -1 on error\n\n  \\sa SDL_TLSCreate()\n  \\sa SDL_TLSGet()"]
    pub fn SDL_TLSSet(
        id: SDL_TLSID,
        value: *const libc::c_void,
        destructor: ::core::option::Option<unsafe extern "C" fn(arg1: *mut libc::c_void)>,
    ) -> libc::c_int;
}
#[doc = " This is the read/write operation structure -- very basic."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_RWops {
    #[doc = "  Return the size of the file in this rwops, or -1 if unknown"]
    pub size: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> Sint64>,
    #[doc = "  Seek to \\c offset relative to \\c whence, one of stdio's whence values:\n  RW_SEEK_SET, RW_SEEK_CUR, RW_SEEK_END\n\n  \\return the final offset in the data stream, or -1 on error."]
    pub seek: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            offset: Sint64,
            whence: libc::c_int,
        ) -> Sint64,
    >,
    #[doc = "  Read up to \\c maxnum objects each of size \\c size from the data\n  stream to the area pointed at by \\c ptr.\n\n  \\return the number of objects read, or 0 at error or end of file."]
    pub read: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *mut libc::c_void,
            size: usize,
            maxnum: usize,
        ) -> usize,
    >,
    #[doc = "  Write exactly \\c num objects each of size \\c size from the area\n  pointed at by \\c ptr to data stream.\n\n  \\return the number of objects written, or 0 at error or end of file."]
    pub write: ::core::option::Option<
        unsafe extern "C" fn(
            context: *mut SDL_RWops,
            ptr: *const libc::c_void,
            size: usize,
            num: usize,
        ) -> usize,
    >,
    #[doc = "  Close and free an allocated SDL_RWops structure.\n\n  \\return 0 if successful or -1 on write error when flushing data."]
    pub close: ::core::option::Option<unsafe extern "C" fn(context: *mut SDL_RWops) -> libc::c_int>,
    pub type_: Uint32,
    pub hidden: SDL_RWops__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_RWops__bindgen_ty_1 {
    pub windowsio: SDL_RWops__bindgen_ty_1__bindgen_ty_1,
    pub stdio: SDL_RWops__bindgen_ty_1__bindgen_ty_2,
    pub mem: SDL_RWops__bindgen_ty_1__bindgen_ty_3,
    pub unknown: SDL_RWops__bindgen_ty_1__bindgen_ty_4,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1 {
    pub append: SDL_bool,
    pub h: *mut libc::c_void,
    pub buffer: SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut libc::c_void,
    pub size: usize,
    pub left: usize,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(left)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).append) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(append)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_2 {
    pub autoclose: SDL_bool,
    pub fp: *mut FILE,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).autoclose) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(autoclose)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(fp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_3 {
    pub base: *mut Uint8,
    pub here: *mut Uint8,
    pub stop: *mut Uint8,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_3> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).here) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(here)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(stop)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RWops__bindgen_ty_1__bindgen_ty_4 {
    pub data1: *mut libc::c_void,
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1__bindgen_ty_4> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1__bindgen_ty_4>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(data2)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_RWops__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowsio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(windowsio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stdio) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(stdio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unknown) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops__bindgen_ty_1),
            "::",
            stringify!(unknown)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_RWops() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RWops> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RWops>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_RWops))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RWops>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_RWops))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).seek) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).read) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).write) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).close) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hidden) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RWops),
            "::",
            stringify!(hidden)
        )
    );
}
extern "C" {
    pub fn SDL_RWFromFile(file: *const libc::c_char, mode: *const libc::c_char) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromFP(fp: *mut FILE, autoclose: SDL_bool) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromMem(mem: *mut libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_RWFromConstMem(mem: *const libc::c_void, size: libc::c_int) -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_AllocRW() -> *mut SDL_RWops;
}
extern "C" {
    pub fn SDL_FreeRW(area: *mut SDL_RWops);
}
extern "C" {
    #[doc = "  Load all the data from an SDL data stream.\n\n  The data is allocated with a zero byte at the end (null terminated)\n\n  If \\c datasize is not NULL, it is filled with the size of the data read.\n\n  If \\c freesrc is non-zero, the stream will be closed after being read.\n\n  The data should be freed with SDL_free().\n\n  \\return the data, or NULL if there was an error."]
    pub fn SDL_LoadFile_RW(
        src: *mut SDL_RWops,
        datasize: *mut usize,
        freesrc: libc::c_int,
    ) -> *mut libc::c_void;
}
extern "C" {
    pub fn SDL_ReadU8(src: *mut SDL_RWops) -> Uint8;
}
extern "C" {
    pub fn SDL_ReadLE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadBE16(src: *mut SDL_RWops) -> Uint16;
}
extern "C" {
    pub fn SDL_ReadLE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadBE32(src: *mut SDL_RWops) -> Uint32;
}
extern "C" {
    pub fn SDL_ReadLE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_ReadBE64(src: *mut SDL_RWops) -> Uint64;
}
extern "C" {
    pub fn SDL_WriteU8(dst: *mut SDL_RWops, value: Uint8) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE16(dst: *mut SDL_RWops, value: Uint16) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE32(dst: *mut SDL_RWops, value: Uint32) -> usize;
}
extern "C" {
    pub fn SDL_WriteLE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
extern "C" {
    pub fn SDL_WriteBE64(dst: *mut SDL_RWops, value: Uint64) -> usize;
}
#[doc = "  \\brief Audio format flags.\n\n  These are what the 16 bits in SDL_AudioFormat currently mean...\n  (Unspecified bits are always zero).\n\n  \\verbatim\n++-----------------------sample is signed if set\n||\n||       ++-----------sample is bigendian if set\n||       ||\n||       ||          ++---sample is float if set\n||       ||          ||\n||       ||          || +---sample bit size---+\n||       ||          || |                     |\n15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n\\endverbatim\n\n  There are macros in SDL 2.0 and later to query these bits."]
pub type SDL_AudioFormat = Uint16;
#[doc = "  This function is called when the audio device needs more data.\n\n  \\param userdata An application-specific parameter saved in\n                  the SDL_AudioSpec structure\n  \\param stream A pointer to the audio data buffer.\n  \\param len    The length of that buffer in bytes.\n\n  Once the callback returns, the buffer will no longer be valid.\n  Stereo samples are stored in a LRLRLR ordering.\n\n  You can choose to avoid callbacks and use SDL_QueueAudio() instead, if\n  you like. Just open your audio device with a NULL callback."]
pub type SDL_AudioCallback = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, stream: *mut Uint8, len: libc::c_int),
>;
#[doc = "  The calculated values in this structure are calculated by SDL_OpenAudio().\n\n  For multi-channel audio, the default SDL channel mapping is:\n  2:  FL FR                       (stereo)\n  3:  FL FR LFE                   (2.1 surround)\n  4:  FL FR BL BR                 (quad)\n  5:  FL FR FC BL BR              (quad + center)\n  6:  FL FR FC LFE SL SR          (5.1 surround - last two can also be BL BR)\n  7:  FL FR FC LFE BC SL SR       (6.1 surround)\n  8:  FL FR FC LFE BL BR SL SR    (7.1 surround)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioSpec {
    #[doc = "< DSP frequency -- samples per second"]
    pub freq: libc::c_int,
    #[doc = "< Audio data format"]
    pub format: SDL_AudioFormat,
    #[doc = "< Number of channels: 1 mono, 2 stereo"]
    pub channels: Uint8,
    #[doc = "< Audio buffer silence value (calculated)"]
    pub silence: Uint8,
    #[doc = "< Audio buffer size in sample FRAMES (total samples divided by channel count)"]
    pub samples: Uint16,
    #[doc = "< Necessary for some compile environments"]
    pub padding: Uint16,
    #[doc = "< Audio buffer size in bytes (calculated)"]
    pub size: Uint32,
    #[doc = "< Callback that feeds the audio device (NULL to use SDL_QueueAudio())."]
    pub callback: SDL_AudioCallback,
    #[doc = "< Userdata passed to callback (ignored for NULL callbacks)."]
    pub userdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_AudioSpec() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AudioSpec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioSpec>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioSpec>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AudioSpec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(freq)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).silence) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(silence)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioSpec),
            "::",
            stringify!(userdata)
        )
    );
}
pub type SDL_AudioFilter =
    ::core::option::Option<unsafe extern "C" fn(cvt: *mut SDL_AudioCVT, format: SDL_AudioFormat)>;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioCVT {
    #[doc = "< Set to 1 if conversion possible"]
    pub needed: libc::c_int,
    #[doc = "< Source audio format"]
    pub src_format: SDL_AudioFormat,
    #[doc = "< Target audio format"]
    pub dst_format: SDL_AudioFormat,
    #[doc = "< Rate conversion increment"]
    pub rate_incr: f64,
    #[doc = "< Buffer to hold entire audio data"]
    pub buf: *mut Uint8,
    #[doc = "< Length of original audio buffer"]
    pub len: libc::c_int,
    #[doc = "< Length of converted audio buffer"]
    pub len_cvt: libc::c_int,
    #[doc = "< buffer must be len*len_mult big"]
    pub len_mult: libc::c_int,
    #[doc = "< Given len, final size is len*len_ratio"]
    pub len_ratio: f64,
    #[doc = "< NULL-terminated list of filter functions"]
    pub filters: [SDL_AudioFilter; 10usize],
    #[doc = "< Current audio conversion function"]
    pub filter_index: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_AudioCVT() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AudioCVT> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioCVT>(),
        84usize,
        concat!("Size of: ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioCVT>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AudioCVT))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).needed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(needed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).src_format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(src_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dst_format) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(dst_format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rate_incr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(rate_incr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len_cvt) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_cvt)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len_mult) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len_ratio) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(len_ratio)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filters) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).filter_index) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioCVT),
            "::",
            stringify!(filter_index)
        )
    );
}
extern "C" {
    pub fn SDL_GetNumAudioDrivers() -> libc::c_int;
}
extern "C" {
    pub fn SDL_GetAudioDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    pub fn SDL_AudioInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    pub fn SDL_AudioQuit();
}
extern "C" {
    #[doc = "  This function returns the name of the current audio driver, or NULL\n  if no driver has been initialized."]
    pub fn SDL_GetCurrentAudioDriver() -> *const libc::c_char;
}
extern "C" {
    #[doc = "  This function opens the audio device with the desired parameters, and\n  returns 0 if successful, placing the actual hardware parameters in the\n  structure pointed to by \\c obtained.  If \\c obtained is NULL, the audio\n  data passed to the callback function will be guaranteed to be in the\n  requested format, and will be automatically converted to the hardware\n  audio format if necessary.  This function returns -1 if it failed\n  to open the audio device, or couldn't set up the audio thread.\n\n  When filling in the desired audio spec structure,\n    - \\c desired->freq should be the desired audio frequency in samples-per-\n      second.\n    - \\c desired->format should be the desired audio format.\n    - \\c desired->samples is the desired size of the audio buffer, in\n      samples.  This number should be a power of two, and may be adjusted by\n      the audio driver to a value more suitable for the hardware.  Good values\n      seem to range between 512 and 8096 inclusive, depending on the\n      application and CPU speed.  Smaller values yield faster response time,\n      but can lead to underflow if the application is doing heavy processing\n      and cannot fill the audio buffer in time.  A stereo sample consists of\n      both right and left channels in LR ordering.\n      Note that the number of samples is directly related to time by the\n      following formula:  \\code ms = (samples*1000)/freq \\endcode\n    - \\c desired->size is the size in bytes of the audio buffer, and is\n      calculated by SDL_OpenAudio().\n    - \\c desired->silence is the value used to set the buffer to silence,\n      and is calculated by SDL_OpenAudio().\n    - \\c desired->callback should be set to a function that will be called\n      when the audio device is ready for more data.  It is passed a pointer\n      to the audio buffer, and the length in bytes of the audio buffer.\n      This function usually runs in a separate thread, and so you should\n      protect data structures that it accesses by calling SDL_LockAudio()\n      and SDL_UnlockAudio() in your code. Alternately, you may pass a NULL\n      pointer here, and call SDL_QueueAudio() with some frequency, to queue\n      more audio samples to be played (or for capture devices, call\n      SDL_DequeueAudio() with some frequency, to obtain audio samples).\n    - \\c desired->userdata is passed as the first parameter to your callback\n      function. If you passed a NULL callback, this value is ignored.\n\n  The audio device starts out playing silence when it's opened, and should\n  be enabled for playing by calling \\c SDL_PauseAudio(0) when you are ready\n  for your audio callback function to be called.  Since the audio driver\n  may modify the requested size of the audio buffer, you should allocate\n  any local mixing buffers after you open the audio device."]
    pub fn SDL_OpenAudio(desired: *mut SDL_AudioSpec, obtained: *mut SDL_AudioSpec) -> libc::c_int;
}
#[doc = "  SDL Audio Device IDs.\n\n  A successful call to SDL_OpenAudio() is always device id 1, and legacy\n  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls\n  always returns devices >= 2 on success. The legacy calls are good both\n  for backwards compatibility and when you don't care about multiple,\n  specific, or capture devices."]
pub type SDL_AudioDeviceID = Uint32;
extern "C" {
    #[doc = "  Get the number of available devices exposed by the current driver.\n  Only valid after a successfully initializing the audio subsystem.\n  Returns -1 if an explicit list of devices can't be determined; this is\n  not an error. For example, if SDL is set up to talk to a remote audio\n  server, it can't list every one available on the Internet, but it will\n  still allow a specific host to be specified to SDL_OpenAudioDevice().\n\n  In many common cases, when this function returns a value <= 0, it can still\n  successfully open the default device (NULL for first argument of\n  SDL_OpenAudioDevice())."]
    pub fn SDL_GetNumAudioDevices(iscapture: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the human-readable name of a specific audio device.\n  Must be a value between 0 and (number of audio devices-1).\n  Only valid after a successfully initializing the audio subsystem.\n  The values returned by this function reflect the latest call to\n  SDL_GetNumAudioDevices(); recall that function to redetect available\n  hardware.\n\n  The string returned by this function is UTF-8 encoded, read-only, and\n  managed internally. You are not to free it. If you need to keep the\n  string for any length of time, you should make your own copy of it, as it\n  will be invalid next time any of several other SDL functions is called."]
    pub fn SDL_GetAudioDeviceName(
        index: libc::c_int,
        iscapture: libc::c_int,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Open a specific audio device. Passing in a device name of NULL requests\n  the most reasonable default (and is equivalent to calling SDL_OpenAudio()).\n\n  The device name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but\n  some drivers allow arbitrary and driver-specific strings, such as a\n  hostname/IP address for a remote audio server, or a filename in the\n  diskaudio driver.\n\n  \\return 0 on error, a valid device ID that is >= 2 on success.\n\n  SDL_OpenAudio(), unlike this function, always acts on device ID 1."]
    pub fn SDL_OpenAudioDevice(
        device: *const libc::c_char,
        iscapture: libc::c_int,
        desired: *const SDL_AudioSpec,
        obtained: *mut SDL_AudioSpec,
        allowed_changes: libc::c_int,
    ) -> SDL_AudioDeviceID;
}
pub const SDL_AudioStatus_SDL_AUDIO_STOPPED: SDL_AudioStatus = 0;
pub const SDL_AudioStatus_SDL_AUDIO_PLAYING: SDL_AudioStatus = 1;
pub const SDL_AudioStatus_SDL_AUDIO_PAUSED: SDL_AudioStatus = 2;
pub type SDL_AudioStatus = libc::c_int;
extern "C" {
    pub fn SDL_GetAudioStatus() -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_GetAudioDeviceStatus(dev: SDL_AudioDeviceID) -> SDL_AudioStatus;
}
extern "C" {
    pub fn SDL_PauseAudio(pause_on: libc::c_int);
}
extern "C" {
    pub fn SDL_PauseAudioDevice(dev: SDL_AudioDeviceID, pause_on: libc::c_int);
}
extern "C" {
    #[doc = "  This function loads a WAVE from the data source, automatically freeing\n  that source if \\c freesrc is non-zero.  For example, to load a WAVE file,\n  you could do:\n  \\code\n      SDL_LoadWAV_RW(SDL_RWFromFile(\"sample.wav\", \"rb\"), 1, ...);\n  \\endcode\n\n  If this function succeeds, it returns the given SDL_AudioSpec,\n  filled with the audio data format of the wave data, and sets\n  \\c *audio_buf to a malloc()'d buffer containing the audio data,\n  and sets \\c *audio_len to the length of that audio buffer, in bytes.\n  You need to free the audio buffer with SDL_FreeWAV() when you are\n  done with it.\n\n  This function returns NULL and sets the SDL error message if the\n  wave file cannot be opened, uses an unknown data format, or is\n  corrupt.  Currently raw and MS-ADPCM WAVE files are supported."]
    pub fn SDL_LoadWAV_RW(
        src: *mut SDL_RWops,
        freesrc: libc::c_int,
        spec: *mut SDL_AudioSpec,
        audio_buf: *mut *mut Uint8,
        audio_len: *mut Uint32,
    ) -> *mut SDL_AudioSpec;
}
extern "C" {
    #[doc = "  This function frees data previously allocated with SDL_LoadWAV_RW()"]
    pub fn SDL_FreeWAV(audio_buf: *mut Uint8);
}
extern "C" {
    #[doc = "  This function takes a source format and rate and a destination format\n  and rate, and initializes the \\c cvt structure with information needed\n  by SDL_ConvertAudio() to convert a buffer of audio data from one format\n  to the other. An unsupported format causes an error and -1 will be returned.\n\n  \\return 0 if no conversion is needed, 1 if the audio filter is set up,\n  or -1 on error."]
    pub fn SDL_BuildAudioCVT(
        cvt: *mut SDL_AudioCVT,
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Once you have initialized the \\c cvt structure using SDL_BuildAudioCVT(),\n  created an audio buffer \\c cvt->buf, and filled it with \\c cvt->len bytes of\n  audio data in the source format, this function will convert it in-place\n  to the desired format.\n\n  The data conversion may expand the size of the audio data, so the buffer\n  \\c cvt->buf should be allocated after the \\c cvt structure is initialized by\n  SDL_BuildAudioCVT(), and should be \\c cvt->len*cvt->len_mult bytes long.\n\n  \\return 0 on success or -1 if \\c cvt->buf is NULL."]
    pub fn SDL_ConvertAudio(cvt: *mut SDL_AudioCVT) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_AudioStream {
    _unused: [u8; 0],
}
pub type SDL_AudioStream = _SDL_AudioStream;
extern "C" {
    #[doc = "  Create a new audio stream\n\n  \\param src_format The format of the source audio\n  \\param src_channels The number of channels of the source audio\n  \\param src_rate The sampling rate of the source audio\n  \\param dst_format The format of the desired audio output\n  \\param dst_channels The number of channels of the desired audio output\n  \\param dst_rate The sampling rate of the desired audio output\n  \\return 0 on success, or -1 on error.\n\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_AudioStreamClear\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_NewAudioStream(
        src_format: SDL_AudioFormat,
        src_channels: Uint8,
        src_rate: libc::c_int,
        dst_format: SDL_AudioFormat,
        dst_channels: Uint8,
        dst_rate: libc::c_int,
    ) -> *mut SDL_AudioStream;
}
extern "C" {
    #[doc = "  Add data to be converted/resampled to the stream\n\n  \\param stream The stream the audio data is being added to\n  \\param buf A pointer to the audio data to add\n  \\param len The number of bytes to write to the stream\n  \\return 0 on success, or -1 on error.\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_AudioStreamClear\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamPut(
        stream: *mut SDL_AudioStream,
        buf: *const libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get converted/resampled data from the stream\n\n  \\param stream The stream the audio is being requested from\n  \\param buf A buffer to fill with audio data\n  \\param len The maximum number of bytes to fill\n  \\return The number of bytes read from the stream, or -1 on error\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_AudioStreamClear\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamGet(
        stream: *mut SDL_AudioStream,
        buf: *mut libc::c_void,
        len: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " Get the number of converted/resampled bytes available. The stream may be\n  buffering data behind the scenes until it has enough to resample\n  correctly, so this number might be lower than what you expect, or even\n  be zero. Add more data or flush the stream if you need the data now.\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_AudioStreamClear\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamAvailable(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = " Tell the stream that you're done sending data, and anything being buffered\n  should be converted/resampled and made available immediately.\n\n It is legal to add more data to a stream after flushing, but there will\n  be audio gaps in the output. Generally this is intended to signal the\n  end of input, so the complete output becomes available.\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamClear\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamFlush(stream: *mut SDL_AudioStream) -> libc::c_int;
}
extern "C" {
    #[doc = "  Clear any pending data in the stream without converting it\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_FreeAudioStream"]
    pub fn SDL_AudioStreamClear(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = " Free an audio stream\n\n  \\sa SDL_NewAudioStream\n  \\sa SDL_AudioStreamPut\n  \\sa SDL_AudioStreamGet\n  \\sa SDL_AudioStreamAvailable\n  \\sa SDL_AudioStreamFlush\n  \\sa SDL_AudioStreamClear"]
    pub fn SDL_FreeAudioStream(stream: *mut SDL_AudioStream);
}
extern "C" {
    #[doc = "  This takes two audio buffers of the playing audio format and mixes\n  them, performing addition, volume adjustment, and overflow clipping.\n  The volume ranges from 0 - 128, and should be set to ::SDL_MIX_MAXVOLUME\n  for full audio volume.  Note this does not change hardware volume.\n  This is provided for convenience -- you can mix your own audio data."]
    pub fn SDL_MixAudio(dst: *mut Uint8, src: *const Uint8, len: Uint32, volume: libc::c_int);
}
extern "C" {
    #[doc = "  This works like SDL_MixAudio(), but you specify the audio format instead of\n  using the format of audio device 1. Thus it can be used when no audio\n  device is open at all."]
    pub fn SDL_MixAudioFormat(
        dst: *mut Uint8,
        src: *const Uint8,
        format: SDL_AudioFormat,
        len: Uint32,
        volume: libc::c_int,
    );
}
extern "C" {
    #[doc = "  Queue more audio on non-callback devices.\n\n  (If you are looking to retrieve queued audio from a non-callback capture\n  device, you want SDL_DequeueAudio() instead. This will return -1 to\n  signify an error if you use it with capture devices.)\n\n  SDL offers two ways to feed audio to the device: you can either supply a\n  callback that SDL triggers with some frequency to obtain more audio\n  (pull method), or you can supply no callback, and then SDL will expect\n  you to supply data at regular intervals (push method) with this function.\n\n  There are no limits on the amount of data you can queue, short of\n  exhaustion of address space. Queued data will drain to the device as\n  necessary without further intervention from you. If the device needs\n  audio but there is not enough queued, it will play silence to make up\n  the difference. This means you will have skips in your audio playback\n  if you aren't routinely queueing sufficient data.\n\n  This function copies the supplied data, so you are safe to free it when\n  the function returns. This function is thread-safe, but queueing to the\n  same device from two threads at once does not promise which buffer will\n  be queued first.\n\n  You may not queue audio on a device that is using an application-supplied\n  callback; doing so returns an error. You have to use the audio callback\n  or queue audio with this function, but not both.\n\n  You should not call SDL_LockAudio() on the device before queueing; SDL\n  handles locking internally for this function.\n\n  \\param dev The device ID to which we will queue audio.\n  \\param data The data to queue to the device for later playback.\n  \\param len The number of bytes (not samples!) to which (data) points.\n  \\return 0 on success, or -1 on error.\n\n  \\sa SDL_GetQueuedAudioSize\n  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_QueueAudio(
        dev: SDL_AudioDeviceID,
        data: *const libc::c_void,
        len: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Dequeue more audio on non-callback devices.\n\n  (If you are looking to queue audio for output on a non-callback playback\n  device, you want SDL_QueueAudio() instead. This will always return 0\n  if you use it with playback devices.)\n\n  SDL offers two ways to retrieve audio from a capture device: you can\n  either supply a callback that SDL triggers with some frequency as the\n  device records more audio data, (push method), or you can supply no\n  callback, and then SDL will expect you to retrieve data at regular\n  intervals (pull method) with this function.\n\n  There are no limits on the amount of data you can queue, short of\n  exhaustion of address space. Data from the device will keep queuing as\n  necessary without further intervention from you. This means you will\n  eventually run out of memory if you aren't routinely dequeueing data.\n\n  Capture devices will not queue data when paused; if you are expecting\n  to not need captured audio for some length of time, use\n  SDL_PauseAudioDevice() to stop the capture device from queueing more\n  data. This can be useful during, say, level loading times. When\n  unpaused, capture devices will start queueing data from that point,\n  having flushed any capturable data available while paused.\n\n  This function is thread-safe, but dequeueing from the same device from\n  two threads at once does not promise which thread will dequeued data\n  first.\n\n  You may not dequeue audio from a device that is using an\n  application-supplied callback; doing so returns an error. You have to use\n  the audio callback, or dequeue audio with this function, but not both.\n\n  You should not call SDL_LockAudio() on the device before queueing; SDL\n  handles locking internally for this function.\n\n  \\param dev The device ID from which we will dequeue audio.\n  \\param data A pointer into where audio data should be copied.\n  \\param len The number of bytes (not samples!) to which (data) points.\n  \\return number of bytes dequeued, which could be less than requested.\n\n  \\sa SDL_GetQueuedAudioSize\n  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_DequeueAudio(dev: SDL_AudioDeviceID, data: *mut libc::c_void, len: Uint32)
        -> Uint32;
}
extern "C" {
    #[doc = "  Get the number of bytes of still-queued audio.\n\n  For playback device:\n\n    This is the number of bytes that have been queued for playback with\n    SDL_QueueAudio(), but have not yet been sent to the hardware. This\n    number may shrink at any time, so this only informs of pending data.\n\n    Once we've sent it to the hardware, this function can not decide the\n    exact byte boundary of what has been played. It's possible that we just\n    gave the hardware several kilobytes right before you called this\n    function, but it hasn't played any of it yet, or maybe half of it, etc.\n\n  For capture devices:\n\n    This is the number of bytes that have been captured by the device and\n    are waiting for you to dequeue. This number may grow at any time, so\n    this only informs of the lower-bound of available data.\n\n  You may not queue audio on a device that is using an application-supplied\n  callback; calling this function on such a device always returns 0.\n  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use\n  the audio callback, but not both.\n\n  You should not call SDL_LockAudio() on the device before querying; SDL\n  handles locking internally for this function.\n\n  \\param dev The device ID of which we will query queued audio size.\n  \\return Number of bytes (not samples!) of queued audio.\n\n  \\sa SDL_QueueAudio\n  \\sa SDL_ClearQueuedAudio"]
    pub fn SDL_GetQueuedAudioSize(dev: SDL_AudioDeviceID) -> Uint32;
}
extern "C" {
    #[doc = "  Drop any queued audio data. For playback devices, this is any queued data\n  still waiting to be submitted to the hardware. For capture devices, this\n  is any data that was queued by the device that hasn't yet been dequeued by\n  the application.\n\n  Immediately after this call, SDL_GetQueuedAudioSize() will return 0. For\n  playback devices, the hardware will start playing silence if more audio\n  isn't queued. Unpaused capture devices will start filling the queue again\n  as soon as they have more data available (which, depending on the state\n  of the hardware and the thread, could be before this function call\n  returns!).\n\n  This will not prevent playback of queued audio that's already been sent\n  to the hardware, as we can not undo that, so expect there to be some\n  fraction of a second of audio that might still be heard. This can be\n  useful if you want to, say, drop any pending music during a level change\n  in your game.\n\n  You may not queue audio on a device that is using an application-supplied\n  callback; calling this function on such a device is always a no-op.\n  You have to queue audio with SDL_QueueAudio()/SDL_DequeueAudio(), or use\n  the audio callback, but not both.\n\n  You should not call SDL_LockAudio() on the device before clearing the\n  queue; SDL handles locking internally for this function.\n\n  This function always succeeds and thus returns void.\n\n  \\param dev The device ID of which to clear the audio queue.\n\n  \\sa SDL_QueueAudio\n  \\sa SDL_GetQueuedAudioSize"]
    pub fn SDL_ClearQueuedAudio(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_LockAudio();
}
extern "C" {
    pub fn SDL_LockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    pub fn SDL_UnlockAudio();
}
extern "C" {
    pub fn SDL_UnlockAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = "  This function shuts down audio processing and closes the audio device."]
    pub fn SDL_CloseAudio();
}
extern "C" {
    pub fn SDL_CloseAudioDevice(dev: SDL_AudioDeviceID);
}
extern "C" {
    #[doc = " \\brief Put UTF-8 text into the clipboard\n\n \\sa SDL_GetClipboardText()"]
    pub fn SDL_SetClipboardText(text: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get UTF-8 text from the clipboard, which must be freed with SDL_free()\n\n \\sa SDL_SetClipboardText()"]
    pub fn SDL_GetClipboardText() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\brief Returns a flag indicating whether the clipboard exists and contains a text string that is non-empty\n\n \\sa SDL_GetClipboardText()"]
    pub fn SDL_HasClipboardText() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns the number of CPU cores available."]
    pub fn SDL_GetCPUCount() -> libc::c_int;
}
extern "C" {
    #[doc = "  This function returns the L1 cache line size of the CPU\n\n  This is useful for determining multi-threaded structure padding\n  or SIMD prefetch sizes."]
    pub fn SDL_GetCPUCacheLineSize() -> libc::c_int;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has the RDTSC instruction."]
    pub fn SDL_HasRDTSC() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AltiVec features."]
    pub fn SDL_HasAltiVec() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has MMX features."]
    pub fn SDL_HasMMX() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has 3DNow! features."]
    pub fn SDL_Has3DNow() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE features."]
    pub fn SDL_HasSSE() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE2 features."]
    pub fn SDL_HasSSE2() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE3 features."]
    pub fn SDL_HasSSE3() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE4.1 features."]
    pub fn SDL_HasSSE41() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has SSE4.2 features."]
    pub fn SDL_HasSSE42() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX features."]
    pub fn SDL_HasAVX() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX2 features."]
    pub fn SDL_HasAVX2() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has AVX-512F (foundation) features."]
    pub fn SDL_HasAVX512F() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns true if the CPU has NEON (ARM SIMD) features."]
    pub fn SDL_HasNEON() -> SDL_bool;
}
extern "C" {
    #[doc = "  This function returns the amount of RAM configured in the system, in MB."]
    pub fn SDL_GetSystemRAM() -> libc::c_int;
}
pub const SDL_PIXELTYPE_UNKNOWN: _bindgen_ty_10 = 0;
pub const SDL_PIXELTYPE_INDEX1: _bindgen_ty_10 = 1;
pub const SDL_PIXELTYPE_INDEX4: _bindgen_ty_10 = 2;
pub const SDL_PIXELTYPE_INDEX8: _bindgen_ty_10 = 3;
pub const SDL_PIXELTYPE_PACKED8: _bindgen_ty_10 = 4;
pub const SDL_PIXELTYPE_PACKED16: _bindgen_ty_10 = 5;
pub const SDL_PIXELTYPE_PACKED32: _bindgen_ty_10 = 6;
pub const SDL_PIXELTYPE_ARRAYU8: _bindgen_ty_10 = 7;
pub const SDL_PIXELTYPE_ARRAYU16: _bindgen_ty_10 = 8;
pub const SDL_PIXELTYPE_ARRAYU32: _bindgen_ty_10 = 9;
pub const SDL_PIXELTYPE_ARRAYF16: _bindgen_ty_10 = 10;
pub const SDL_PIXELTYPE_ARRAYF32: _bindgen_ty_10 = 11;
#[doc = " Pixel type."]
pub type _bindgen_ty_10 = libc::c_int;
pub const SDL_BITMAPORDER_NONE: _bindgen_ty_11 = 0;
pub const SDL_BITMAPORDER_4321: _bindgen_ty_11 = 1;
pub const SDL_BITMAPORDER_1234: _bindgen_ty_11 = 2;
#[doc = " Bitmap pixel order, high bit -> low bit."]
pub type _bindgen_ty_11 = libc::c_int;
pub const SDL_PACKEDORDER_NONE: _bindgen_ty_12 = 0;
pub const SDL_PACKEDORDER_XRGB: _bindgen_ty_12 = 1;
pub const SDL_PACKEDORDER_RGBX: _bindgen_ty_12 = 2;
pub const SDL_PACKEDORDER_ARGB: _bindgen_ty_12 = 3;
pub const SDL_PACKEDORDER_RGBA: _bindgen_ty_12 = 4;
pub const SDL_PACKEDORDER_XBGR: _bindgen_ty_12 = 5;
pub const SDL_PACKEDORDER_BGRX: _bindgen_ty_12 = 6;
pub const SDL_PACKEDORDER_ABGR: _bindgen_ty_12 = 7;
pub const SDL_PACKEDORDER_BGRA: _bindgen_ty_12 = 8;
#[doc = " Packed component order, high bit -> low bit."]
pub type _bindgen_ty_12 = libc::c_int;
pub const SDL_ARRAYORDER_NONE: _bindgen_ty_13 = 0;
pub const SDL_ARRAYORDER_RGB: _bindgen_ty_13 = 1;
pub const SDL_ARRAYORDER_RGBA: _bindgen_ty_13 = 2;
pub const SDL_ARRAYORDER_ARGB: _bindgen_ty_13 = 3;
pub const SDL_ARRAYORDER_BGR: _bindgen_ty_13 = 4;
pub const SDL_ARRAYORDER_BGRA: _bindgen_ty_13 = 5;
pub const SDL_ARRAYORDER_ABGR: _bindgen_ty_13 = 6;
#[doc = " Array component order, low byte -> high byte."]
pub type _bindgen_ty_13 = libc::c_int;
pub const SDL_PACKEDLAYOUT_NONE: _bindgen_ty_14 = 0;
pub const SDL_PACKEDLAYOUT_332: _bindgen_ty_14 = 1;
pub const SDL_PACKEDLAYOUT_4444: _bindgen_ty_14 = 2;
pub const SDL_PACKEDLAYOUT_1555: _bindgen_ty_14 = 3;
pub const SDL_PACKEDLAYOUT_5551: _bindgen_ty_14 = 4;
pub const SDL_PACKEDLAYOUT_565: _bindgen_ty_14 = 5;
pub const SDL_PACKEDLAYOUT_8888: _bindgen_ty_14 = 6;
pub const SDL_PACKEDLAYOUT_2101010: _bindgen_ty_14 = 7;
pub const SDL_PACKEDLAYOUT_1010102: _bindgen_ty_14 = 8;
#[doc = " Packed component layout."]
pub type _bindgen_ty_14 = libc::c_int;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_UNKNOWN: SDL_PixelFormatEnum = 0;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX1LSB: SDL_PixelFormatEnum = 286261504;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX1MSB: SDL_PixelFormatEnum = 287310080;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX4LSB: SDL_PixelFormatEnum = 303039488;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX4MSB: SDL_PixelFormatEnum = 304088064;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_INDEX8: SDL_PixelFormatEnum = 318769153;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB332: SDL_PixelFormatEnum = 336660481;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB444: SDL_PixelFormatEnum = 353504258;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB555: SDL_PixelFormatEnum = 353570562;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR555: SDL_PixelFormatEnum = 357764866;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB4444: SDL_PixelFormatEnum = 355602434;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA4444: SDL_PixelFormatEnum = 356651010;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR4444: SDL_PixelFormatEnum = 359796738;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA4444: SDL_PixelFormatEnum = 360845314;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB1555: SDL_PixelFormatEnum = 355667970;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA5551: SDL_PixelFormatEnum = 356782082;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR1555: SDL_PixelFormatEnum = 359862274;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA5551: SDL_PixelFormatEnum = 360976386;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB565: SDL_PixelFormatEnum = 353701890;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR565: SDL_PixelFormatEnum = 357896194;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB24: SDL_PixelFormatEnum = 386930691;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR24: SDL_PixelFormatEnum = 390076419;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGB888: SDL_PixelFormatEnum = 370546692;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBX8888: SDL_PixelFormatEnum = 371595268;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGR888: SDL_PixelFormatEnum = 374740996;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRX8888: SDL_PixelFormatEnum = 375789572;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB8888: SDL_PixelFormatEnum = 372645892;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA8888: SDL_PixelFormatEnum = 373694468;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR8888: SDL_PixelFormatEnum = 376840196;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA8888: SDL_PixelFormatEnum = 377888772;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB2101010: SDL_PixelFormatEnum = 372711428;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_RGBA32: SDL_PixelFormatEnum = 376840196;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ARGB32: SDL_PixelFormatEnum = 377888772;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_BGRA32: SDL_PixelFormatEnum = 372645892;
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_ABGR32: SDL_PixelFormatEnum = 373694468;
#[doc = "< Planar mode: Y + V + U  (3 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YV12: SDL_PixelFormatEnum = 842094169;
#[doc = "< Planar mode: Y + U + V  (3 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_IYUV: SDL_PixelFormatEnum = 1448433993;
#[doc = "< Packed mode: Y0+U0+Y1+V0 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YUY2: SDL_PixelFormatEnum = 844715353;
#[doc = "< Packed mode: U0+Y0+V0+Y1 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_UYVY: SDL_PixelFormatEnum = 1498831189;
#[doc = "< Packed mode: Y0+V0+Y1+U0 (1 plane)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_YVYU: SDL_PixelFormatEnum = 1431918169;
#[doc = "< Planar mode: Y + U/V interleaved  (2 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_NV12: SDL_PixelFormatEnum = 842094158;
#[doc = "< Planar mode: Y + V/U interleaved  (2 planes)"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_NV21: SDL_PixelFormatEnum = 825382478;
#[doc = "< Android video texture format"]
pub const SDL_PixelFormatEnum_SDL_PIXELFORMAT_EXTERNAL_OES: SDL_PixelFormatEnum = 542328143;
pub type SDL_PixelFormatEnum = libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Color {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
    pub a: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_Color() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Color> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Color>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_Color))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Color>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_Color))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Color),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Palette {
    pub ncolors: libc::c_int,
    pub colors: *mut SDL_Color,
    pub version: Uint32,
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Palette() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Palette> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Palette>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Palette))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Palette>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Palette))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ncolors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Palette),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = "  \\note Everything in the pixel format structure is read-only."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_PixelFormat {
    pub format: Uint32,
    pub palette: *mut SDL_Palette,
    pub BitsPerPixel: Uint8,
    pub BytesPerPixel: Uint8,
    pub padding: [Uint8; 2usize],
    pub Rmask: Uint32,
    pub Gmask: Uint32,
    pub Bmask: Uint32,
    pub Amask: Uint32,
    pub Rloss: Uint8,
    pub Gloss: Uint8,
    pub Bloss: Uint8,
    pub Aloss: Uint8,
    pub Rshift: Uint8,
    pub Gshift: Uint8,
    pub Bshift: Uint8,
    pub Ashift: Uint8,
    pub refcount: libc::c_int,
    pub next: *mut SDL_PixelFormat,
}
#[test]
fn bindgen_test_layout_SDL_PixelFormat() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_PixelFormat> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_PixelFormat>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_PixelFormat>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_PixelFormat))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).palette) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(palette)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BitsPerPixel) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BitsPerPixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).BytesPerPixel) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(BytesPerPixel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rmask) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gmask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bmask) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bmask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Amask) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Amask)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rloss) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gloss) as usize - ptr as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bloss) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Aloss) as usize - ptr as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Aloss)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Rshift) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Rshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gshift) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Gshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Bshift) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Bshift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Ashift) as usize - ptr as usize },
        35usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(Ashift)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_PixelFormat),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = " \\brief Get the human readable name of a pixel format"]
    pub fn SDL_GetPixelFormatName(format: Uint32) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Convert one of the enumerated pixel formats to a bpp and RGBA masks.\n\n  \\return SDL_TRUE, or SDL_FALSE if the conversion wasn't possible.\n\n  \\sa SDL_MasksToPixelFormatEnum()"]
    pub fn SDL_PixelFormatEnumToMasks(
        format: Uint32,
        bpp: *mut libc::c_int,
        Rmask: *mut Uint32,
        Gmask: *mut Uint32,
        Bmask: *mut Uint32,
        Amask: *mut Uint32,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Convert a bpp and RGBA masks to an enumerated pixel format.\n\n  \\return The pixel format, or ::SDL_PIXELFORMAT_UNKNOWN if the conversion\n          wasn't possible.\n\n  \\sa SDL_PixelFormatEnumToMasks()"]
    pub fn SDL_MasksToPixelFormatEnum(
        bpp: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Create an SDL_PixelFormat structure from a pixel format enum."]
    pub fn SDL_AllocFormat(pixel_format: Uint32) -> *mut SDL_PixelFormat;
}
extern "C" {
    #[doc = "  \\brief Free an SDL_PixelFormat structure."]
    pub fn SDL_FreeFormat(format: *mut SDL_PixelFormat);
}
extern "C" {
    #[doc = "  \\brief Create a palette structure with the specified number of color\n         entries.\n\n  \\return A new palette, or NULL if there wasn't enough memory.\n\n  \\note The palette entries are initialized to white.\n\n  \\sa SDL_FreePalette()"]
    pub fn SDL_AllocPalette(ncolors: libc::c_int) -> *mut SDL_Palette;
}
extern "C" {
    #[doc = "  \\brief Set the palette for a pixel format structure."]
    pub fn SDL_SetPixelFormatPalette(
        format: *mut SDL_PixelFormat,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set a range of colors in a palette.\n\n  \\param palette    The palette to modify.\n  \\param colors     An array of colors to copy into the palette.\n  \\param firstcolor The index of the first palette entry to modify.\n  \\param ncolors    The number of entries to modify.\n\n  \\return 0 on success, or -1 if not all of the colors could be set."]
    pub fn SDL_SetPaletteColors(
        palette: *mut SDL_Palette,
        colors: *const SDL_Color,
        firstcolor: libc::c_int,
        ncolors: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Free a palette created with SDL_AllocPalette().\n\n  \\sa SDL_AllocPalette()"]
    pub fn SDL_FreePalette(palette: *mut SDL_Palette);
}
extern "C" {
    #[doc = "  \\brief Maps an RGB triple to an opaque pixel value for a given pixel format.\n\n  \\sa SDL_MapRGBA"]
    pub fn SDL_MapRGB(format: *const SDL_PixelFormat, r: Uint8, g: Uint8, b: Uint8) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Maps an RGBA quadruple to a pixel value for a given pixel format.\n\n  \\sa SDL_MapRGB"]
    pub fn SDL_MapRGBA(
        format: *const SDL_PixelFormat,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get the RGB components from a pixel of the specified format.\n\n  \\sa SDL_GetRGBA"]
    pub fn SDL_GetRGB(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    );
}
extern "C" {
    #[doc = "  \\brief Get the RGBA components from a pixel of the specified format.\n\n  \\sa SDL_GetRGB"]
    pub fn SDL_GetRGBA(
        pixel: Uint32,
        format: *const SDL_PixelFormat,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    );
}
extern "C" {
    #[doc = "  \\brief Calculate a 256 entry gamma ramp for a gamma value."]
    pub fn SDL_CalculateGammaRamp(gamma: f32, ramp: *mut Uint16);
}
#[doc = "  \\brief  The structure that defines a point (integer)\n\n  \\sa SDL_EnclosePoints\n  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Point {
    pub x: libc::c_int,
    pub y: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Point() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Point> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Point>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_Point))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Point>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Point))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Point),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief  The structure that defines a point (floating point)\n\n  \\sa SDL_EnclosePoints\n  \\sa SDL_PointInRect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FPoint {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_FPoint() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_FPoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_FPoint>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FPoint>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FPoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FPoint),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left (integer).\n\n  \\sa SDL_RectEmpty\n  \\sa SDL_RectEquals\n  \\sa SDL_HasIntersection\n  \\sa SDL_IntersectRect\n  \\sa SDL_UnionRect\n  \\sa SDL_EnclosePoints"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Rect {
    pub x: libc::c_int,
    pub y: libc::c_int,
    pub w: libc::c_int,
    pub h: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Rect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Rect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Rect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Rect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Rect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Rect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Rect),
            "::",
            stringify!(h)
        )
    );
}
#[doc = "  \\brief A rectangle, with the origin at the upper left (floating point)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_FRect {
    pub x: f32,
    pub y: f32,
    pub w: f32,
    pub h: f32,
}
#[test]
fn bindgen_test_layout_SDL_FRect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_FRect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_FRect>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_FRect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_FRect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_FRect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_FRect),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Determine whether two rectangles intersect.\n\n  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_HasIntersection(A: *const SDL_Rect, B: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the intersection of two rectangles.\n\n  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_IntersectRect(
        A: *const SDL_Rect,
        B: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the union of two rectangles."]
    pub fn SDL_UnionRect(A: *const SDL_Rect, B: *const SDL_Rect, result: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Calculate a minimal rectangle enclosing a set of points\n\n  \\return SDL_TRUE if any points were within the clipping rect"]
    pub fn SDL_EnclosePoints(
        points: *const SDL_Point,
        count: libc::c_int,
        clip: *const SDL_Rect,
        result: *mut SDL_Rect,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Calculate the intersection of a rectangle and line segment.\n\n  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise."]
    pub fn SDL_IntersectRectAndLine(
        rect: *const SDL_Rect,
        X1: *mut libc::c_int,
        Y1: *mut libc::c_int,
        X2: *mut libc::c_int,
        Y2: *mut libc::c_int,
    ) -> SDL_bool;
}
#[doc = "< no blending\ndstRGBA = srcRGBA"]
pub const SDL_BlendMode_SDL_BLENDMODE_NONE: SDL_BlendMode = 0;
#[doc = "< alpha blending\ndstRGB = (srcRGB * srcA) + (dstRGB * (1-srcA))\ndstA = srcA + (dstA * (1-srcA))"]
pub const SDL_BlendMode_SDL_BLENDMODE_BLEND: SDL_BlendMode = 1;
#[doc = "< additive blending\ndstRGB = (srcRGB * srcA) + dstRGB\ndstA = dstA"]
pub const SDL_BlendMode_SDL_BLENDMODE_ADD: SDL_BlendMode = 2;
#[doc = "< color modulate\ndstRGB = srcRGB * dstRGB\ndstA = dstA"]
pub const SDL_BlendMode_SDL_BLENDMODE_MOD: SDL_BlendMode = 4;
pub const SDL_BlendMode_SDL_BLENDMODE_INVALID: SDL_BlendMode = 2147483647;
#[doc = "  \\brief The blend mode used in SDL_RenderCopy() and drawing operations."]
pub type SDL_BlendMode = libc::c_int;
#[doc = "< dst + src: supported by all renderers"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_ADD: SDL_BlendOperation = 1;
#[doc = "< dst - src : supported by D3D9, D3D11, OpenGL, OpenGLES"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_SUBTRACT: SDL_BlendOperation = 2;
#[doc = "< src - dst : supported by D3D9, D3D11, OpenGL, OpenGLES"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_REV_SUBTRACT: SDL_BlendOperation = 3;
#[doc = "< min(dst, src) : supported by D3D11"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MINIMUM: SDL_BlendOperation = 4;
#[doc = "< max(dst, src) : supported by D3D11"]
pub const SDL_BlendOperation_SDL_BLENDOPERATION_MAXIMUM: SDL_BlendOperation = 5;
#[doc = "  \\brief The blend operation used when combining source and destination pixel components"]
pub type SDL_BlendOperation = libc::c_int;
#[doc = "< 0, 0, 0, 0"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ZERO: SDL_BlendFactor = 1;
#[doc = "< 1, 1, 1, 1"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE: SDL_BlendFactor = 2;
#[doc = "< srcR, srcG, srcB, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_COLOR: SDL_BlendFactor = 3;
#[doc = "< 1-srcR, 1-srcG, 1-srcB, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_COLOR: SDL_BlendFactor = 4;
#[doc = "< srcA, srcA, srcA, srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_SRC_ALPHA: SDL_BlendFactor = 5;
#[doc = "< 1-srcA, 1-srcA, 1-srcA, 1-srcA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_SRC_ALPHA: SDL_BlendFactor = 6;
#[doc = "< dstR, dstG, dstB, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_COLOR: SDL_BlendFactor = 7;
#[doc = "< 1-dstR, 1-dstG, 1-dstB, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_COLOR: SDL_BlendFactor = 8;
#[doc = "< dstA, dstA, dstA, dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_DST_ALPHA: SDL_BlendFactor = 9;
#[doc = "< 1-dstA, 1-dstA, 1-dstA, 1-dstA"]
pub const SDL_BlendFactor_SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA: SDL_BlendFactor = 10;
#[doc = "  \\brief The normalized factor used to multiply pixel components"]
pub type SDL_BlendFactor = libc::c_int;
extern "C" {
    #[doc = "  \\brief Create a custom blend mode, which may or may not be supported by a given renderer\n\n  \\param srcColorFactor source color factor\n  \\param dstColorFactor destination color factor\n  \\param colorOperation color operation\n  \\param srcAlphaFactor source alpha factor\n  \\param dstAlphaFactor destination alpha factor\n  \\param alphaOperation alpha operation\n\n  The result of the blend mode operation will be:\n      dstRGB = dstRGB * dstColorFactor colorOperation srcRGB * srcColorFactor\n  and\n      dstA = dstA * dstAlphaFactor alphaOperation srcA * srcAlphaFactor"]
    pub fn SDL_ComposeCustomBlendMode(
        srcColorFactor: SDL_BlendFactor,
        dstColorFactor: SDL_BlendFactor,
        colorOperation: SDL_BlendOperation,
        srcAlphaFactor: SDL_BlendFactor,
        dstAlphaFactor: SDL_BlendFactor,
        alphaOperation: SDL_BlendOperation,
    ) -> SDL_BlendMode;
}
#[doc = " \\brief A collection of pixels used in software blitting.\n\n \\note  This structure should be treated as read-only, except for \\c pixels,\n        which, if not NULL, contains the raw pixel data for the surface."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Surface {
    #[doc = "< Read-only"]
    pub flags: Uint32,
    #[doc = "< Read-only"]
    pub format: *mut SDL_PixelFormat,
    #[doc = "< Read-only"]
    pub w: libc::c_int,
    #[doc = "< Read-only"]
    pub h: libc::c_int,
    #[doc = "< Read-only"]
    pub pitch: libc::c_int,
    #[doc = "< Read-write"]
    pub pixels: *mut libc::c_void,
    #[doc = "< Read-write"]
    pub userdata: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub locked: libc::c_int,
    #[doc = "< Read-only"]
    pub lock_data: *mut libc::c_void,
    #[doc = "< Read-only"]
    pub clip_rect: SDL_Rect,
    #[doc = "< Private"]
    pub map: *mut SDL_BlitMap,
    #[doc = "< Read-mostly"]
    pub refcount: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_Surface() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Surface> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Surface>(),
        60usize,
        concat!("Size of: ", stringify!(SDL_Surface))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Surface>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Surface))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pitch) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pitch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pixels) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(pixels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userdata) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(userdata)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).locked) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(locked)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).lock_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(lock_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clip_rect) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(clip_rect)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).map) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(map)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refcount) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Surface),
            "::",
            stringify!(refcount)
        )
    );
}
#[doc = " \\brief The type of function used for surface blitting functions."]
pub type SDL_blit = ::core::option::Option<
    unsafe extern "C" fn(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int,
>;
#[doc = "< Full range JPEG"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_JPEG: SDL_YUV_CONVERSION_MODE = 0;
#[doc = "< BT.601 (the default)"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT601: SDL_YUV_CONVERSION_MODE = 1;
#[doc = "< BT.709"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_BT709: SDL_YUV_CONVERSION_MODE = 2;
#[doc = "< BT.601 for SD content, BT.709 for HD content"]
pub const SDL_YUV_CONVERSION_MODE_SDL_YUV_CONVERSION_AUTOMATIC: SDL_YUV_CONVERSION_MODE = 3;
#[doc = " \\brief The formula used for converting between YUV and RGB"]
pub type SDL_YUV_CONVERSION_MODE = libc::c_int;
extern "C" {
    #[doc = "  Allocate and free an RGB surface.\n\n  If the depth is 4 or 8 bits, an empty palette is allocated for the surface.\n  If the depth is greater than 8 bits, the pixel format is set using the\n  flags '[RGB]mask'.\n\n  If the function runs out of memory, it will return NULL.\n\n  \\param flags The \\c flags are obsolete and should be set to 0.\n  \\param width The width in pixels of the surface to create.\n  \\param height The height in pixels of the surface to create.\n  \\param depth The depth in bits of the surface to create.\n  \\param Rmask The red mask of the surface to create.\n  \\param Gmask The green mask of the surface to create.\n  \\param Bmask The blue mask of the surface to create.\n  \\param Amask The alpha mask of the surface to create."]
    pub fn SDL_CreateRGBSurface(
        flags: Uint32,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormat(
        flags: Uint32,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceFrom(
        pixels: *mut libc::c_void,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        pitch: libc::c_int,
        Rmask: Uint32,
        Gmask: Uint32,
        Bmask: Uint32,
        Amask: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_CreateRGBSurfaceWithFormatFrom(
        pixels: *mut libc::c_void,
        width: libc::c_int,
        height: libc::c_int,
        depth: libc::c_int,
        pitch: libc::c_int,
        format: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_FreeSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  \\brief Set the palette used by a surface.\n\n  \\return 0, or -1 if the surface format doesn't use a palette.\n\n  \\note A single palette can be shared with many surfaces."]
    pub fn SDL_SetSurfacePalette(
        surface: *mut SDL_Surface,
        palette: *mut SDL_Palette,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets up a surface for directly accessing the pixels.\n\n  Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write\n  to and read from \\c surface->pixels, using the pixel format stored in\n  \\c surface->format.  Once you are done accessing the surface, you should\n  use SDL_UnlockSurface() to release it.\n\n  Not all surfaces require locking.  If SDL_MUSTLOCK(surface) evaluates\n  to 0, then you can read and write to the surface at any time, and the\n  pixel format of the surface will not change.\n\n  No operating system or library calls should be made between lock/unlock\n  pairs, as critical system locks may be held during this time.\n\n  SDL_LockSurface() returns 0, or -1 if the surface couldn't be locked.\n\n  \\sa SDL_UnlockSurface()"]
    pub fn SDL_LockSurface(surface: *mut SDL_Surface) -> libc::c_int;
}
extern "C" {
    #[doc = " \\sa SDL_LockSurface()"]
    pub fn SDL_UnlockSurface(surface: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  Load a surface from a seekable SDL data stream (memory or file).\n\n  If \\c freesrc is non-zero, the stream will be closed after being read.\n\n  The new surface should be freed with SDL_FreeSurface().\n\n  \\return the new surface, or NULL if there was an error."]
    pub fn SDL_LoadBMP_RW(src: *mut SDL_RWops, freesrc: libc::c_int) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  Save a surface to a seekable SDL data stream (memory or file).\n\n  Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the\n  BMP directly. Other RGB formats with 8-bit or higher get converted to a\n  24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit\n  surface before they are saved. YUV and paletted 1-bit and 4-bit formats are\n  not supported.\n\n  If \\c freedst is non-zero, the stream will be closed after being written.\n\n  \\return 0 if successful or -1 if there was an error."]
    pub fn SDL_SaveBMP_RW(
        surface: *mut SDL_Surface,
        dst: *mut SDL_RWops,
        freedst: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the RLE acceleration hint for a surface.\n\n  \\return 0 on success, or -1 if the surface is not valid\n\n  \\note If RLE is enabled, colorkey and alpha blending blits are much faster,\n        but the surface must be locked before directly accessing the pixels."]
    pub fn SDL_SetSurfaceRLE(surface: *mut SDL_Surface, flag: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the color key (transparent pixel) in a blittable surface.\n\n  \\param surface The surface to update\n  \\param flag Non-zero to enable colorkey and 0 to disable colorkey\n  \\param key The transparent pixel in the native surface format\n\n  \\return 0 on success, or -1 if the surface is not valid\n\n  You can pass SDL_RLEACCEL to enable RLE accelerated blits."]
    pub fn SDL_SetColorKey(
        surface: *mut SDL_Surface,
        flag: libc::c_int,
        key: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Returns whether the surface has a color key\n\n  \\return SDL_TRUE if the surface has a color key, or SDL_FALSE if the surface is NULL or has no color key"]
    pub fn SDL_HasColorKey(surface: *mut SDL_Surface) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Gets the color key (transparent pixel) in a blittable surface.\n\n  \\param surface The surface to update\n  \\param key A pointer filled in with the transparent pixel in the native\n             surface format\n\n  \\return 0 on success, or -1 if the surface is not valid or colorkey is not\n          enabled."]
    pub fn SDL_GetColorKey(surface: *mut SDL_Surface, key: *mut Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional color value used in blit operations.\n\n  \\param surface The surface to update.\n  \\param r The red color value multiplied into blit operations.\n  \\param g The green color value multiplied into blit operations.\n  \\param b The blue color value multiplied into blit operations.\n\n  \\return 0 on success, or -1 if the surface is not valid.\n\n  \\sa SDL_GetSurfaceColorMod()"]
    pub fn SDL_SetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional color value used in blit operations.\n\n  \\param surface The surface to query.\n  \\param r A pointer filled in with the current red color value.\n  \\param g A pointer filled in with the current green color value.\n  \\param b A pointer filled in with the current blue color value.\n\n  \\return 0 on success, or -1 if the surface is not valid.\n\n  \\sa SDL_SetSurfaceColorMod()"]
    pub fn SDL_GetSurfaceColorMod(
        surface: *mut SDL_Surface,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional alpha value used in blit operations.\n\n  \\param surface The surface to update.\n  \\param alpha The alpha value multiplied into blit operations.\n\n  \\return 0 on success, or -1 if the surface is not valid.\n\n  \\sa SDL_GetSurfaceAlphaMod()"]
    pub fn SDL_SetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional alpha value used in blit operations.\n\n  \\param surface The surface to query.\n  \\param alpha A pointer filled in with the current alpha value.\n\n  \\return 0 on success, or -1 if the surface is not valid.\n\n  \\sa SDL_SetSurfaceAlphaMod()"]
    pub fn SDL_GetSurfaceAlphaMod(surface: *mut SDL_Surface, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for blit operations.\n\n  \\param surface The surface to update.\n  \\param blendMode ::SDL_BlendMode to use for blit blending.\n\n  \\return 0 on success, or -1 if the parameters are not valid.\n\n  \\sa SDL_GetSurfaceBlendMode()"]
    pub fn SDL_SetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for blit operations.\n\n  \\param surface   The surface to query.\n  \\param blendMode A pointer filled in with the current blend mode.\n\n  \\return 0 on success, or -1 if the surface is not valid.\n\n  \\sa SDL_SetSurfaceBlendMode()"]
    pub fn SDL_GetSurfaceBlendMode(
        surface: *mut SDL_Surface,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Sets the clipping rectangle for the destination surface in a blit.\n\n  If the clip rectangle is NULL, clipping will be disabled.\n\n  If the clip rectangle doesn't intersect the surface, the function will\n  return SDL_FALSE and blits will be completely clipped.  Otherwise the\n  function returns SDL_TRUE and blits to the surface will be clipped to\n  the intersection of the surface area and the clipping rectangle.\n\n  Note that blits are automatically clipped to the edges of the source\n  and destination surfaces."]
    pub fn SDL_SetClipRect(surface: *mut SDL_Surface, rect: *const SDL_Rect) -> SDL_bool;
}
extern "C" {
    #[doc = "  Gets the clipping rectangle for the destination surface in a blit.\n\n  \\c rect must be a pointer to a valid rectangle which will be filled\n  with the correct values."]
    pub fn SDL_GetClipRect(surface: *mut SDL_Surface, rect: *mut SDL_Rect);
}
extern "C" {
    pub fn SDL_DuplicateSurface(surface: *mut SDL_Surface) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  Creates a new surface of the specified format, and then copies and maps\n  the given surface to it so the blit of the converted surface will be as\n  fast as possible.  If this function fails, it returns NULL.\n\n  The \\c flags parameter is passed to SDL_CreateRGBSurface() and has those\n  semantics.  You can also pass ::SDL_RLEACCEL in the flags parameter and\n  SDL will try to RLE accelerate colorkey and alpha blits in the resulting\n  surface."]
    pub fn SDL_ConvertSurface(
        src: *mut SDL_Surface,
        fmt: *const SDL_PixelFormat,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    pub fn SDL_ConvertSurfaceFormat(
        src: *mut SDL_Surface,
        pixel_format: Uint32,
        flags: Uint32,
    ) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = " \\brief Copy a block of pixels of one format to another format\n\n  \\return 0 on success, or -1 if there was an error"]
    pub fn SDL_ConvertPixels(
        width: libc::c_int,
        height: libc::c_int,
        src_format: Uint32,
        src: *const libc::c_void,
        src_pitch: libc::c_int,
        dst_format: Uint32,
        dst: *mut libc::c_void,
        dst_pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Performs a fast fill of the given rectangle with \\c color.\n\n  If \\c rect is NULL, the whole surface will be filled with \\c color.\n\n  The color should be a pixel of the format used by the surface, and\n  can be generated by the SDL_MapRGB() function.\n\n  \\return 0 on success, or -1 on error."]
    pub fn SDL_FillRect(dst: *mut SDL_Surface, rect: *const SDL_Rect, color: Uint32)
        -> libc::c_int;
}
extern "C" {
    pub fn SDL_FillRects(
        dst: *mut SDL_Surface,
        rects: *const SDL_Rect,
        count: libc::c_int,
        color: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  This is the public blit function, SDL_BlitSurface(), and it performs\n  rectangle validation and clipping before passing it to SDL_LowerBlit()"]
    pub fn SDL_UpperBlit(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  This is a semi-private blit function and it performs low-level surface\n  blitting only."]
    pub fn SDL_LowerBlit(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Perform a fast, low quality, stretch blit between two surfaces of the\n         same pixel format.\n\n  \\note This function uses a static buffer, and is not thread-safe."]
    pub fn SDL_SoftStretch(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  This is the public scaled blit function, SDL_BlitScaled(), and it performs\n  rectangle validation and clipping before passing it to SDL_LowerBlitScaled()"]
    pub fn SDL_UpperBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *const SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  This is a semi-private blit function and it performs low-level surface\n  scaled blitting only."]
    pub fn SDL_LowerBlitScaled(
        src: *mut SDL_Surface,
        srcrect: *mut SDL_Rect,
        dst: *mut SDL_Surface,
        dstrect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the YUV conversion mode"]
    pub fn SDL_SetYUVConversionMode(mode: SDL_YUV_CONVERSION_MODE);
}
extern "C" {
    #[doc = "  \\brief Get the YUV conversion mode"]
    pub fn SDL_GetYUVConversionMode() -> SDL_YUV_CONVERSION_MODE;
}
extern "C" {
    #[doc = "  \\brief Get the YUV conversion mode, returning the correct mode for the resolution when the current conversion mode is SDL_YUV_CONVERSION_AUTOMATIC"]
    pub fn SDL_GetYUVConversionModeForResolution(
        width: libc::c_int,
        height: libc::c_int,
    ) -> SDL_YUV_CONVERSION_MODE;
}
#[doc = "  \\brief  The structure that defines a display mode\n\n  \\sa SDL_GetNumDisplayModes()\n  \\sa SDL_GetDisplayMode()\n  \\sa SDL_GetDesktopDisplayMode()\n  \\sa SDL_GetCurrentDisplayMode()\n  \\sa SDL_GetClosestDisplayMode()\n  \\sa SDL_SetWindowDisplayMode()\n  \\sa SDL_GetWindowDisplayMode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayMode {
    #[doc = "< pixel format"]
    pub format: Uint32,
    #[doc = "< width, in screen coordinates"]
    pub w: libc::c_int,
    #[doc = "< height, in screen coordinates"]
    pub h: libc::c_int,
    #[doc = "< refresh rate (or zero for unspecified)"]
    pub refresh_rate: libc::c_int,
    #[doc = "< driver-specific data, initialize to 0"]
    pub driverdata: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_DisplayMode() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DisplayMode> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayMode>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayMode>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DisplayMode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).refresh_rate) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(refresh_rate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).driverdata) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayMode),
            "::",
            stringify!(driverdata)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Window {
    _unused: [u8; 0],
}
#[doc = "< fullscreen window"]
pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN: SDL_WindowFlags = 1;
#[doc = "< window usable with OpenGL context"]
pub const SDL_WindowFlags_SDL_WINDOW_OPENGL: SDL_WindowFlags = 2;
#[doc = "< window is visible"]
pub const SDL_WindowFlags_SDL_WINDOW_SHOWN: SDL_WindowFlags = 4;
#[doc = "< window is not visible"]
pub const SDL_WindowFlags_SDL_WINDOW_HIDDEN: SDL_WindowFlags = 8;
#[doc = "< no window decoration"]
pub const SDL_WindowFlags_SDL_WINDOW_BORDERLESS: SDL_WindowFlags = 16;
#[doc = "< window can be resized"]
pub const SDL_WindowFlags_SDL_WINDOW_RESIZABLE: SDL_WindowFlags = 32;
#[doc = "< window is minimized"]
pub const SDL_WindowFlags_SDL_WINDOW_MINIMIZED: SDL_WindowFlags = 64;
#[doc = "< window is maximized"]
pub const SDL_WindowFlags_SDL_WINDOW_MAXIMIZED: SDL_WindowFlags = 128;
#[doc = "< window has grabbed input focus"]
pub const SDL_WindowFlags_SDL_WINDOW_INPUT_GRABBED: SDL_WindowFlags = 256;
#[doc = "< window has input focus"]
pub const SDL_WindowFlags_SDL_WINDOW_INPUT_FOCUS: SDL_WindowFlags = 512;
#[doc = "< window has mouse focus"]
pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_FOCUS: SDL_WindowFlags = 1024;
pub const SDL_WindowFlags_SDL_WINDOW_FULLSCREEN_DESKTOP: SDL_WindowFlags = 4097;
#[doc = "< window not created by SDL"]
pub const SDL_WindowFlags_SDL_WINDOW_FOREIGN: SDL_WindowFlags = 2048;
#[doc = "< window should be created in high-DPI mode if supported.\nOn macOS NSHighResolutionCapable must be set true in the\napplication's Info.plist for this to have any effect."]
pub const SDL_WindowFlags_SDL_WINDOW_ALLOW_HIGHDPI: SDL_WindowFlags = 8192;
#[doc = "< window has mouse captured (unrelated to INPUT_GRABBED)"]
pub const SDL_WindowFlags_SDL_WINDOW_MOUSE_CAPTURE: SDL_WindowFlags = 16384;
#[doc = "< window should always be above others"]
pub const SDL_WindowFlags_SDL_WINDOW_ALWAYS_ON_TOP: SDL_WindowFlags = 32768;
#[doc = "< window should not be added to the taskbar"]
pub const SDL_WindowFlags_SDL_WINDOW_SKIP_TASKBAR: SDL_WindowFlags = 65536;
#[doc = "< window should be treated as a utility window"]
pub const SDL_WindowFlags_SDL_WINDOW_UTILITY: SDL_WindowFlags = 131072;
#[doc = "< window should be treated as a tooltip"]
pub const SDL_WindowFlags_SDL_WINDOW_TOOLTIP: SDL_WindowFlags = 262144;
#[doc = "< window should be treated as a popup menu"]
pub const SDL_WindowFlags_SDL_WINDOW_POPUP_MENU: SDL_WindowFlags = 524288;
#[doc = "< window usable for Vulkan surface"]
pub const SDL_WindowFlags_SDL_WINDOW_VULKAN: SDL_WindowFlags = 268435456;
#[doc = "  \\brief The flags on a window\n\n  \\sa SDL_GetWindowFlags()"]
pub type SDL_WindowFlags = libc::c_int;
#[doc = "< Never used"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_NONE: SDL_WindowEventID = 0;
#[doc = "< Window has been shown"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_SHOWN: SDL_WindowEventID = 1;
#[doc = "< Window has been hidden"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIDDEN: SDL_WindowEventID = 2;
#[doc = "< Window has been exposed and should be\nredrawn"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_EXPOSED: SDL_WindowEventID = 3;
#[doc = "< Window has been moved to data1, data2"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MOVED: SDL_WindowEventID = 4;
#[doc = "< Window has been resized to data1xdata2"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESIZED: SDL_WindowEventID = 5;
#[doc = "< The window size has changed, either as\na result of an API call or through the\nsystem or user changing the window size."]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_SIZE_CHANGED: SDL_WindowEventID = 6;
#[doc = "< Window has been minimized"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MINIMIZED: SDL_WindowEventID = 7;
#[doc = "< Window has been maximized"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_MAXIMIZED: SDL_WindowEventID = 8;
#[doc = "< Window has been restored to normal size\nand position"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_RESTORED: SDL_WindowEventID = 9;
#[doc = "< Window has gained mouse focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_ENTER: SDL_WindowEventID = 10;
#[doc = "< Window has lost mouse focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_LEAVE: SDL_WindowEventID = 11;
#[doc = "< Window has gained keyboard focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_GAINED: SDL_WindowEventID = 12;
#[doc = "< Window has lost keyboard focus"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_FOCUS_LOST: SDL_WindowEventID = 13;
#[doc = "< The window manager requests that the window be closed"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_CLOSE: SDL_WindowEventID = 14;
#[doc = "< Window is being offered a focus (should SetWindowInputFocus() on itself or a subwindow, or ignore)"]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_TAKE_FOCUS: SDL_WindowEventID = 15;
#[doc = "< Window had a hit test that wasn't SDL_HITTEST_NORMAL."]
pub const SDL_WindowEventID_SDL_WINDOWEVENT_HIT_TEST: SDL_WindowEventID = 16;
#[doc = "  \\brief Event subtype for window events"]
pub type SDL_WindowEventID = libc::c_int;
#[doc = "< Never used"]
pub const SDL_DisplayEventID_SDL_DISPLAYEVENT_NONE: SDL_DisplayEventID = 0;
#[doc = "< Display orientation has changed to data1"]
pub const SDL_DisplayEventID_SDL_DISPLAYEVENT_ORIENTATION: SDL_DisplayEventID = 1;
#[doc = "  \\brief Event subtype for display events"]
pub type SDL_DisplayEventID = libc::c_int;
#[doc = "< The display orientation can't be determined"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_UNKNOWN: SDL_DisplayOrientation = 0;
#[doc = "< The display is in landscape mode, with the right side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE: SDL_DisplayOrientation = 1;
#[doc = "< The display is in landscape mode, with the left side up, relative to portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_LANDSCAPE_FLIPPED: SDL_DisplayOrientation = 2;
#[doc = "< The display is in portrait mode"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT: SDL_DisplayOrientation = 3;
#[doc = "< The display is in portrait mode, upside down"]
pub const SDL_DisplayOrientation_SDL_ORIENTATION_PORTRAIT_FLIPPED: SDL_DisplayOrientation = 4;
pub type SDL_DisplayOrientation = libc::c_int;
#[doc = "  \\brief An opaque handle to an OpenGL context."]
pub type SDL_GLContext = *mut libc::c_void;
pub const SDL_GLattr_SDL_GL_RED_SIZE: SDL_GLattr = 0;
pub const SDL_GLattr_SDL_GL_GREEN_SIZE: SDL_GLattr = 1;
pub const SDL_GLattr_SDL_GL_BLUE_SIZE: SDL_GLattr = 2;
pub const SDL_GLattr_SDL_GL_ALPHA_SIZE: SDL_GLattr = 3;
pub const SDL_GLattr_SDL_GL_BUFFER_SIZE: SDL_GLattr = 4;
pub const SDL_GLattr_SDL_GL_DOUBLEBUFFER: SDL_GLattr = 5;
pub const SDL_GLattr_SDL_GL_DEPTH_SIZE: SDL_GLattr = 6;
pub const SDL_GLattr_SDL_GL_STENCIL_SIZE: SDL_GLattr = 7;
pub const SDL_GLattr_SDL_GL_ACCUM_RED_SIZE: SDL_GLattr = 8;
pub const SDL_GLattr_SDL_GL_ACCUM_GREEN_SIZE: SDL_GLattr = 9;
pub const SDL_GLattr_SDL_GL_ACCUM_BLUE_SIZE: SDL_GLattr = 10;
pub const SDL_GLattr_SDL_GL_ACCUM_ALPHA_SIZE: SDL_GLattr = 11;
pub const SDL_GLattr_SDL_GL_STEREO: SDL_GLattr = 12;
pub const SDL_GLattr_SDL_GL_MULTISAMPLEBUFFERS: SDL_GLattr = 13;
pub const SDL_GLattr_SDL_GL_MULTISAMPLESAMPLES: SDL_GLattr = 14;
pub const SDL_GLattr_SDL_GL_ACCELERATED_VISUAL: SDL_GLattr = 15;
pub const SDL_GLattr_SDL_GL_RETAINED_BACKING: SDL_GLattr = 16;
pub const SDL_GLattr_SDL_GL_CONTEXT_MAJOR_VERSION: SDL_GLattr = 17;
pub const SDL_GLattr_SDL_GL_CONTEXT_MINOR_VERSION: SDL_GLattr = 18;
pub const SDL_GLattr_SDL_GL_CONTEXT_EGL: SDL_GLattr = 19;
pub const SDL_GLattr_SDL_GL_CONTEXT_FLAGS: SDL_GLattr = 20;
pub const SDL_GLattr_SDL_GL_CONTEXT_PROFILE_MASK: SDL_GLattr = 21;
pub const SDL_GLattr_SDL_GL_SHARE_WITH_CURRENT_CONTEXT: SDL_GLattr = 22;
pub const SDL_GLattr_SDL_GL_FRAMEBUFFER_SRGB_CAPABLE: SDL_GLattr = 23;
pub const SDL_GLattr_SDL_GL_CONTEXT_RELEASE_BEHAVIOR: SDL_GLattr = 24;
pub const SDL_GLattr_SDL_GL_CONTEXT_RESET_NOTIFICATION: SDL_GLattr = 25;
pub const SDL_GLattr_SDL_GL_CONTEXT_NO_ERROR: SDL_GLattr = 26;
#[doc = "  \\brief OpenGL configuration attributes"]
pub type SDL_GLattr = libc::c_int;
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_CORE: SDL_GLprofile = 1;
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_COMPATIBILITY: SDL_GLprofile = 2;
#[doc = "< GLX_CONTEXT_ES2_PROFILE_BIT_EXT"]
pub const SDL_GLprofile_SDL_GL_CONTEXT_PROFILE_ES: SDL_GLprofile = 4;
pub type SDL_GLprofile = libc::c_int;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_DEBUG_FLAG: SDL_GLcontextFlag = 1;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_FORWARD_COMPATIBLE_FLAG: SDL_GLcontextFlag = 2;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_ROBUST_ACCESS_FLAG: SDL_GLcontextFlag = 4;
pub const SDL_GLcontextFlag_SDL_GL_CONTEXT_RESET_ISOLATION_FLAG: SDL_GLcontextFlag = 8;
pub type SDL_GLcontextFlag = libc::c_int;
pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE: SDL_GLcontextReleaseFlag =
    0;
pub const SDL_GLcontextReleaseFlag_SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH: SDL_GLcontextReleaseFlag =
    1;
pub type SDL_GLcontextReleaseFlag = libc::c_int;
pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_NO_NOTIFICATION:
    SDL_GLContextResetNotification = 0;
pub const SDL_GLContextResetNotification_SDL_GL_CONTEXT_RESET_LOSE_CONTEXT:
    SDL_GLContextResetNotification = 1;
pub type SDL_GLContextResetNotification = libc::c_int;
extern "C" {
    #[doc = "  \\brief Get the number of video drivers compiled into SDL\n\n  \\sa SDL_GetVideoDriver()"]
    pub fn SDL_GetNumVideoDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the name of a built in video driver.\n\n  \\note The video drivers are presented in the order in which they are\n        normally checked during initialization.\n\n  \\sa SDL_GetNumVideoDrivers()"]
    pub fn SDL_GetVideoDriver(index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Initialize the video subsystem, optionally specifying a video driver.\n\n  \\param driver_name Initialize a specific driver by name, or NULL for the\n                     default video driver.\n\n  \\return 0 on success, -1 on error\n\n  This function initializes the video subsystem; setting up a connection\n  to the window manager, etc, and determines the available display modes\n  and pixel formats, but does not initialize a window or graphics mode.\n\n  \\sa SDL_VideoQuit()"]
    pub fn SDL_VideoInit(driver_name: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Shuts down the video subsystem.\n\n  This function closes all windows, and restores the original video mode.\n\n  \\sa SDL_VideoInit()"]
    pub fn SDL_VideoQuit();
}
extern "C" {
    #[doc = "  \\brief Returns the name of the currently initialized video driver.\n\n  \\return The name of the current video driver or NULL if no driver\n          has been initialized\n\n  \\sa SDL_GetNumVideoDrivers()\n  \\sa SDL_GetVideoDriver()"]
    pub fn SDL_GetCurrentVideoDriver() -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Returns the number of available video displays.\n\n  \\sa SDL_GetDisplayBounds()"]
    pub fn SDL_GetNumVideoDisplays() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the name of a display in UTF-8 encoding\n\n  \\return The name of a display, or NULL for an invalid display index.\n\n  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayName(displayIndex: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the desktop area represented by a display, with the primary\n         display located at 0,0\n\n  \\return 0 on success, or -1 if the index is out of range.\n\n  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayBounds(displayIndex: libc::c_int, rect: *mut SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the usable desktop area represented by a display, with the\n         primary display located at 0,0\n\n  This is the same area as SDL_GetDisplayBounds() reports, but with portions\n  reserved by the system removed. For example, on Mac OS X, this subtracts\n  the area occupied by the menu bar and dock.\n\n  Setting a window to be fullscreen generally bypasses these unusable areas,\n  so these are good guidelines for the maximum space available to a\n  non-fullscreen window.\n\n  \\return 0 on success, or -1 if the index is out of range.\n\n  \\sa SDL_GetDisplayBounds()\n  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayUsableBounds(
        displayIndex: libc::c_int,
        rect: *mut SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the dots/pixels-per-inch for a display\n\n  \\note Diagonal, horizontal and vertical DPI can all be optionally\n        returned if the parameter is non-NULL.\n\n  \\return 0 on success, or -1 if no DPI information is available or the index is out of range.\n\n  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayDPI(
        displayIndex: libc::c_int,
        ddpi: *mut f32,
        hdpi: *mut f32,
        vdpi: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the orientation of a display\n\n  \\return The orientation of the display, or SDL_ORIENTATION_UNKNOWN if it isn't available.\n\n  \\sa SDL_GetNumVideoDisplays()"]
    pub fn SDL_GetDisplayOrientation(displayIndex: libc::c_int) -> SDL_DisplayOrientation;
}
extern "C" {
    #[doc = "  \\brief Returns the number of available display modes.\n\n  \\sa SDL_GetDisplayMode()"]
    pub fn SDL_GetNumDisplayModes(displayIndex: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about a specific display mode.\n\n  \\note The display modes are sorted in this priority:\n        \\li bits per pixel -> more colors to fewer colors\n        \\li width -> largest to smallest\n        \\li height -> largest to smallest\n        \\li refresh rate -> highest to lowest\n\n  \\sa SDL_GetNumDisplayModes()"]
    pub fn SDL_GetDisplayMode(
        displayIndex: libc::c_int,
        modeIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the desktop display mode."]
    pub fn SDL_GetDesktopDisplayMode(
        displayIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the current display mode."]
    pub fn SDL_GetCurrentDisplayMode(
        displayIndex: libc::c_int,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the closest match to the requested display mode.\n\n  \\param displayIndex The index of display from which mode should be queried.\n  \\param mode The desired display mode\n  \\param closest A pointer to a display mode to be filled in with the closest\n                 match of the available display modes.\n\n  \\return The passed in value \\c closest, or NULL if no matching video mode\n          was available.\n\n  The available display modes are scanned, and \\c closest is filled in with the\n  closest mode matching the requested mode and returned.  The mode format and\n  refresh_rate default to the desktop mode if they are 0.  The modes are\n  scanned with size being first priority, format being second priority, and\n  finally checking the refresh_rate.  If all the available modes are too\n  small, then NULL is returned.\n\n  \\sa SDL_GetNumDisplayModes()\n  \\sa SDL_GetDisplayMode()"]
    pub fn SDL_GetClosestDisplayMode(
        displayIndex: libc::c_int,
        mode: *const SDL_DisplayMode,
        closest: *mut SDL_DisplayMode,
    ) -> *mut SDL_DisplayMode;
}
extern "C" {
    #[doc = "  \\brief Get the display index associated with a window.\n\n  \\return the display index of the display containing the center of the\n          window, or -1 on error."]
    pub fn SDL_GetWindowDisplayIndex(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the display mode used when a fullscreen window is visible.\n\n  By default the window's dimensions and the desktop format and refresh rate\n  are used.\n\n  \\param window The window for which the display mode should be set.\n  \\param mode The mode to use, or NULL for the default mode.\n\n  \\return 0 on success, or -1 if setting the display mode failed.\n\n  \\sa SDL_GetWindowDisplayMode()\n  \\sa SDL_SetWindowFullscreen()"]
    pub fn SDL_SetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *const SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill in information about the display mode used when a fullscreen\n         window is visible.\n\n  \\sa SDL_SetWindowDisplayMode()\n  \\sa SDL_SetWindowFullscreen()"]
    pub fn SDL_GetWindowDisplayMode(
        window: *mut SDL_Window,
        mode: *mut SDL_DisplayMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the pixel format associated with the window."]
    pub fn SDL_GetWindowPixelFormat(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Create a window with the specified position, dimensions, and flags.\n\n  \\param title The title of the window, in UTF-8 encoding.\n  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or\n               ::SDL_WINDOWPOS_UNDEFINED.\n  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or\n               ::SDL_WINDOWPOS_UNDEFINED.\n  \\param w     The width of the window, in screen coordinates.\n  \\param h     The height of the window, in screen coordinates.\n  \\param flags The flags for the window, a mask of any of the following:\n               ::SDL_WINDOW_FULLSCREEN,    ::SDL_WINDOW_OPENGL,\n               ::SDL_WINDOW_HIDDEN,        ::SDL_WINDOW_BORDERLESS,\n               ::SDL_WINDOW_RESIZABLE,     ::SDL_WINDOW_MAXIMIZED,\n               ::SDL_WINDOW_MINIMIZED,     ::SDL_WINDOW_INPUT_GRABBED,\n               ::SDL_WINDOW_ALLOW_HIGHDPI, ::SDL_WINDOW_VULKAN.\n\n  \\return The created window, or NULL if window creation failed.\n\n  If the window is created with the SDL_WINDOW_ALLOW_HIGHDPI flag, its size\n  in pixels may differ from its size in screen coordinates on platforms with\n  high-DPI support (e.g. iOS and Mac OS X). Use SDL_GetWindowSize() to query\n  the client area's size in screen coordinates, and SDL_GL_GetDrawableSize(),\n  SDL_Vulkan_GetDrawableSize(), or SDL_GetRendererOutputSize() to query the\n  drawable size in pixels.\n\n  If the window is created with any of the SDL_WINDOW_OPENGL or\n  SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function\n  (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the\n  corresponding UnloadLibrary function is called by SDL_DestroyWindow().\n\n  If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,\n  SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.\n\n  \\note On non-Apple devices, SDL requires you to either not link to the\n        Vulkan loader or link to a dynamic library version. This limitation\n        may be removed in a future version of SDL.\n\n  \\sa SDL_DestroyWindow()\n  \\sa SDL_GL_LoadLibrary()\n  \\sa SDL_Vulkan_LoadLibrary()"]
    pub fn SDL_CreateWindow(
        title: *const libc::c_char,
        x: libc::c_int,
        y: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Create an SDL window from an existing native window.\n\n  \\param data A pointer to driver-dependent window creation data\n\n  \\return The created window, or NULL if window creation failed.\n\n  \\sa SDL_DestroyWindow()"]
    pub fn SDL_CreateWindowFrom(data: *const libc::c_void) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the numeric ID of a window, for logging purposes."]
    pub fn SDL_GetWindowID(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get a window from a stored ID, or NULL if it doesn't exist."]
    pub fn SDL_GetWindowFromID(id: Uint32) -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the window flags."]
    pub fn SDL_GetWindowFlags(window: *mut SDL_Window) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Set the title of a window, in UTF-8 format.\n\n  \\sa SDL_GetWindowTitle()"]
    pub fn SDL_SetWindowTitle(window: *mut SDL_Window, title: *const libc::c_char);
}
extern "C" {
    #[doc = "  \\brief Get the title of a window, in UTF-8 format.\n\n  \\sa SDL_SetWindowTitle()"]
    pub fn SDL_GetWindowTitle(window: *mut SDL_Window) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Set the icon for a window.\n\n  \\param window The window for which the icon should be set.\n  \\param icon The icon for the window."]
    pub fn SDL_SetWindowIcon(window: *mut SDL_Window, icon: *mut SDL_Surface);
}
extern "C" {
    #[doc = "  \\brief Associate an arbitrary named pointer with a window.\n\n  \\param window   The window to associate with the pointer.\n  \\param name     The name of the pointer.\n  \\param userdata The associated pointer.\n\n  \\return The previous value associated with 'name'\n\n  \\note The name is case-sensitive.\n\n  \\sa SDL_GetWindowData()"]
    pub fn SDL_SetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
        userdata: *mut libc::c_void,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  \\brief Retrieve the data pointer associated with a window.\n\n  \\param window   The window to query.\n  \\param name     The name of the pointer.\n\n  \\return The value associated with 'name'\n\n  \\sa SDL_SetWindowData()"]
    pub fn SDL_GetWindowData(
        window: *mut SDL_Window,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  \\brief Set the position of a window.\n\n  \\param window   The window to reposition.\n  \\param x        The x coordinate of the window in screen coordinates, or\n                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.\n  \\param y        The y coordinate of the window in screen coordinates, or\n                  ::SDL_WINDOWPOS_CENTERED or ::SDL_WINDOWPOS_UNDEFINED.\n\n  \\note The window coordinate origin is the upper left of the display.\n\n  \\sa SDL_GetWindowPosition()"]
    pub fn SDL_SetWindowPosition(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Get the position of a window.\n\n  \\param window   The window to query.\n  \\param x        Pointer to variable for storing the x position, in screen\n                  coordinates. May be NULL.\n  \\param y        Pointer to variable for storing the y position, in screen\n                  coordinates. May be NULL.\n\n  \\sa SDL_SetWindowPosition()"]
    pub fn SDL_GetWindowPosition(window: *mut SDL_Window, x: *mut libc::c_int, y: *mut libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Set the size of a window's client area.\n\n  \\param window   The window to resize.\n  \\param w        The width of the window, in screen coordinates. Must be >0.\n  \\param h        The height of the window, in screen coordinates. Must be >0.\n\n  \\note Fullscreen windows automatically match the size of the display mode,\n        and you should use SDL_SetWindowDisplayMode() to change their size.\n\n  The window size in screen coordinates may differ from the size in pixels, if\n  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with\n  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or\n  SDL_GetRendererOutputSize() to get the real client area size in pixels.\n\n  \\sa SDL_GetWindowSize()\n  \\sa SDL_SetWindowDisplayMode()"]
    pub fn SDL_SetWindowSize(window: *mut SDL_Window, w: libc::c_int, h: libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's client area.\n\n  \\param window   The window to query.\n  \\param w        Pointer to variable for storing the width, in screen\n                  coordinates. May be NULL.\n  \\param h        Pointer to variable for storing the height, in screen\n                  coordinates. May be NULL.\n\n  The window size in screen coordinates may differ from the size in pixels, if\n  the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a platform with\n  high-dpi support (e.g. iOS or OS X). Use SDL_GL_GetDrawableSize() or\n  SDL_GetRendererOutputSize() to get the real client area size in pixels.\n\n  \\sa SDL_SetWindowSize()"]
    pub fn SDL_GetWindowSize(window: *mut SDL_Window, w: *mut libc::c_int, h: *mut libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's borders (decorations) around the client area.\n\n  \\param window The window to query.\n  \\param top Pointer to variable for storing the size of the top border. NULL is permitted.\n  \\param left Pointer to variable for storing the size of the left border. NULL is permitted.\n  \\param bottom Pointer to variable for storing the size of the bottom border. NULL is permitted.\n  \\param right Pointer to variable for storing the size of the right border. NULL is permitted.\n\n  \\return 0 on success, or -1 if getting this information is not supported.\n\n  \\note if this function fails (returns -1), the size values will be\n        initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as\n        if the window in question was borderless."]
    pub fn SDL_GetWindowBordersSize(
        window: *mut SDL_Window,
        top: *mut libc::c_int,
        left: *mut libc::c_int,
        bottom: *mut libc::c_int,
        right: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the minimum size of a window's client area.\n\n  \\param window    The window to set a new minimum size.\n  \\param min_w     The minimum width of the window, must be >0\n  \\param min_h     The minimum height of the window, must be >0\n\n  \\note You can't change the minimum size of a fullscreen window, it\n        automatically matches the size of the display mode.\n\n  \\sa SDL_GetWindowMinimumSize()\n  \\sa SDL_SetWindowMaximumSize()"]
    pub fn SDL_SetWindowMinimumSize(
        window: *mut SDL_Window,
        min_w: libc::c_int,
        min_h: libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the minimum size of a window's client area.\n\n  \\param window   The window to query.\n  \\param w        Pointer to variable for storing the minimum width, may be NULL\n  \\param h        Pointer to variable for storing the minimum height, may be NULL\n\n  \\sa SDL_GetWindowMaximumSize()\n  \\sa SDL_SetWindowMinimumSize()"]
    pub fn SDL_GetWindowMinimumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the maximum size of a window's client area.\n\n  \\param window    The window to set a new maximum size.\n  \\param max_w     The maximum width of the window, must be >0\n  \\param max_h     The maximum height of the window, must be >0\n\n  \\note You can't change the maximum size of a fullscreen window, it\n        automatically matches the size of the display mode.\n\n  \\sa SDL_GetWindowMaximumSize()\n  \\sa SDL_SetWindowMinimumSize()"]
    pub fn SDL_SetWindowMaximumSize(
        window: *mut SDL_Window,
        max_w: libc::c_int,
        max_h: libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Get the maximum size of a window's client area.\n\n  \\param window   The window to query.\n  \\param w        Pointer to variable for storing the maximum width, may be NULL\n  \\param h        Pointer to variable for storing the maximum height, may be NULL\n\n  \\sa SDL_GetWindowMinimumSize()\n  \\sa SDL_SetWindowMaximumSize()"]
    pub fn SDL_GetWindowMaximumSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the border state of a window.\n\n  This will add or remove the window's SDL_WINDOW_BORDERLESS flag and\n  add or remove the border from the actual window. This is a no-op if the\n  window's border already matches the requested state.\n\n  \\param window The window of which to change the border state.\n  \\param bordered SDL_FALSE to remove border, SDL_TRUE to add border.\n\n  \\note You can't change the border state of a fullscreen window.\n\n  \\sa SDL_GetWindowFlags()"]
    pub fn SDL_SetWindowBordered(window: *mut SDL_Window, bordered: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Set the user-resizable state of a window.\n\n  This will add or remove the window's SDL_WINDOW_RESIZABLE flag and\n  allow/disallow user resizing of the window. This is a no-op if the\n  window's resizable state already matches the requested state.\n\n  \\param window The window of which to change the resizable state.\n  \\param resizable SDL_TRUE to allow resizing, SDL_FALSE to disallow.\n\n  \\note You can't change the resizable state of a fullscreen window.\n\n  \\sa SDL_GetWindowFlags()"]
    pub fn SDL_SetWindowResizable(window: *mut SDL_Window, resizable: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Show a window.\n\n  \\sa SDL_HideWindow()"]
    pub fn SDL_ShowWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Hide a window.\n\n  \\sa SDL_ShowWindow()"]
    pub fn SDL_HideWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Raise a window above other windows and set the input focus."]
    pub fn SDL_RaiseWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Make a window as large as possible.\n\n  \\sa SDL_RestoreWindow()"]
    pub fn SDL_MaximizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Minimize a window to an iconic representation.\n\n  \\sa SDL_RestoreWindow()"]
    pub fn SDL_MinimizeWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Restore the size and position of a minimized or maximized window.\n\n  \\sa SDL_MaximizeWindow()\n  \\sa SDL_MinimizeWindow()"]
    pub fn SDL_RestoreWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Set a window's fullscreen state.\n\n  \\return 0 on success, or -1 if setting the display mode failed.\n\n  \\sa SDL_SetWindowDisplayMode()\n  \\sa SDL_GetWindowDisplayMode()"]
    pub fn SDL_SetWindowFullscreen(window: *mut SDL_Window, flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the SDL surface associated with the window.\n\n  \\return The window's framebuffer surface, or NULL on error.\n\n  A new surface will be created with the optimal format for the window,\n  if necessary. This surface will be freed when the window is destroyed.\n\n  \\note You may not combine this with 3D or the rendering API on this window.\n\n  \\sa SDL_UpdateWindowSurface()\n  \\sa SDL_UpdateWindowSurfaceRects()"]
    pub fn SDL_GetWindowSurface(window: *mut SDL_Window) -> *mut SDL_Surface;
}
extern "C" {
    #[doc = "  \\brief Copy the window surface to the screen.\n\n  \\return 0 on success, or -1 on error.\n\n  \\sa SDL_GetWindowSurface()\n  \\sa SDL_UpdateWindowSurfaceRects()"]
    pub fn SDL_UpdateWindowSurface(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a number of rectangles on the window surface to the screen.\n\n  \\return 0 on success, or -1 on error.\n\n  \\sa SDL_GetWindowSurface()\n  \\sa SDL_UpdateWindowSurface()"]
    pub fn SDL_UpdateWindowSurfaceRects(
        window: *mut SDL_Window,
        rects: *const SDL_Rect,
        numrects: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set a window's input grab mode.\n\n  \\param window The window for which the input grab mode should be set.\n  \\param grabbed This is SDL_TRUE to grab input, and SDL_FALSE to release input.\n\n  If the caller enables a grab while another window is currently grabbed,\n  the other window loses its grab in favor of the caller's window.\n\n  \\sa SDL_GetWindowGrab()"]
    pub fn SDL_SetWindowGrab(window: *mut SDL_Window, grabbed: SDL_bool);
}
extern "C" {
    #[doc = "  \\brief Get a window's input grab mode.\n\n  \\return This returns SDL_TRUE if input is grabbed, and SDL_FALSE otherwise.\n\n  \\sa SDL_SetWindowGrab()"]
    pub fn SDL_GetWindowGrab(window: *mut SDL_Window) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Get the window that currently has an input grab enabled.\n\n  \\return This returns the window if input is grabbed, and NULL otherwise.\n\n  \\sa SDL_SetWindowGrab()"]
    pub fn SDL_GetGrabbedWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Set the brightness (gamma correction) for a window.\n\n  \\return 0 on success, or -1 if setting the brightness isn't supported.\n\n  \\sa SDL_GetWindowBrightness()\n  \\sa SDL_SetWindowGammaRamp()"]
    pub fn SDL_SetWindowBrightness(window: *mut SDL_Window, brightness: f32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the brightness (gamma correction) for a window.\n\n  \\return The last brightness value passed to SDL_SetWindowBrightness()\n\n  \\sa SDL_SetWindowBrightness()"]
    pub fn SDL_GetWindowBrightness(window: *mut SDL_Window) -> f32;
}
extern "C" {
    #[doc = "  \\brief Set the opacity for a window\n\n  \\param window The window which will be made transparent or opaque\n  \\param opacity Opacity (0.0f - transparent, 1.0f - opaque) This will be\n                 clamped internally between 0.0f and 1.0f.\n\n  \\return 0 on success, or -1 if setting the opacity isn't supported.\n\n  \\sa SDL_GetWindowOpacity()"]
    pub fn SDL_SetWindowOpacity(window: *mut SDL_Window, opacity: f32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the opacity of a window.\n\n  If transparency isn't supported on this platform, opacity will be reported\n  as 1.0f without error.\n\n  \\param window The window in question.\n  \\param out_opacity Opacity (0.0f - transparent, 1.0f - opaque)\n\n  \\return 0 on success, or -1 on error (invalid window, etc).\n\n  \\sa SDL_SetWindowOpacity()"]
    pub fn SDL_GetWindowOpacity(window: *mut SDL_Window, out_opacity: *mut f32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the window as a modal for another window (TODO: reconsider this function and/or its name)\n\n  \\param modal_window The window that should be modal\n  \\param parent_window The parent window\n\n  \\return 0 on success, or -1 otherwise."]
    pub fn SDL_SetWindowModalFor(
        modal_window: *mut SDL_Window,
        parent_window: *mut SDL_Window,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Explicitly sets input focus to the window.\n\n  You almost certainly want SDL_RaiseWindow() instead of this function. Use\n  this with caution, as you might give focus to a window that's completely\n  obscured by other windows.\n\n  \\param window The window that should get the input focus\n\n  \\return 0 on success, or -1 otherwise.\n  \\sa SDL_RaiseWindow()"]
    pub fn SDL_SetWindowInputFocus(window: *mut SDL_Window) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the gamma ramp for a window.\n\n  \\param window The window for which the gamma ramp should be set.\n  \\param red The translation table for the red channel, or NULL.\n  \\param green The translation table for the green channel, or NULL.\n  \\param blue The translation table for the blue channel, or NULL.\n\n  \\return 0 on success, or -1 if gamma ramps are unsupported.\n\n  Set the gamma translation table for the red, green, and blue channels\n  of the video hardware.  Each table is an array of 256 16-bit quantities,\n  representing a mapping between the input and output for that channel.\n  The input is the index into the array, and the output is the 16-bit\n  gamma value at that index, scaled to the output color precision.\n\n  \\sa SDL_GetWindowGammaRamp()"]
    pub fn SDL_SetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *const Uint16,
        green: *const Uint16,
        blue: *const Uint16,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the gamma ramp for a window.\n\n  \\param window The window from which the gamma ramp should be queried.\n  \\param red   A pointer to a 256 element array of 16-bit quantities to hold\n               the translation table for the red channel, or NULL.\n  \\param green A pointer to a 256 element array of 16-bit quantities to hold\n               the translation table for the green channel, or NULL.\n  \\param blue  A pointer to a 256 element array of 16-bit quantities to hold\n               the translation table for the blue channel, or NULL.\n\n  \\return 0 on success, or -1 if gamma ramps are unsupported.\n\n  \\sa SDL_SetWindowGammaRamp()"]
    pub fn SDL_GetWindowGammaRamp(
        window: *mut SDL_Window,
        red: *mut Uint16,
        green: *mut Uint16,
        blue: *mut Uint16,
    ) -> libc::c_int;
}
#[doc = "< Region is normal. No special properties."]
pub const SDL_HitTestResult_SDL_HITTEST_NORMAL: SDL_HitTestResult = 0;
#[doc = "< Region can drag entire window."]
pub const SDL_HitTestResult_SDL_HITTEST_DRAGGABLE: SDL_HitTestResult = 1;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPLEFT: SDL_HitTestResult = 2;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOP: SDL_HitTestResult = 3;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_TOPRIGHT: SDL_HitTestResult = 4;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_RIGHT: SDL_HitTestResult = 5;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMRIGHT: SDL_HitTestResult = 6;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOM: SDL_HitTestResult = 7;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_BOTTOMLEFT: SDL_HitTestResult = 8;
pub const SDL_HitTestResult_SDL_HITTEST_RESIZE_LEFT: SDL_HitTestResult = 9;
#[doc = "  \\brief Possible return values from the SDL_HitTest callback.\n\n  \\sa SDL_HitTest"]
pub type SDL_HitTestResult = libc::c_int;
#[doc = "  \\brief Callback used for hit-testing.\n\n  \\sa SDL_SetWindowHitTest"]
pub type SDL_HitTest = ::core::option::Option<
    unsafe extern "C" fn(
        win: *mut SDL_Window,
        area: *const SDL_Point,
        data: *mut libc::c_void,
    ) -> SDL_HitTestResult,
>;
extern "C" {
    #[doc = "  \\brief Provide a callback that decides if a window region has special properties.\n\n  Normally windows are dragged and resized by decorations provided by the\n  system window manager (a title bar, borders, etc), but for some apps, it\n  makes sense to drag them from somewhere else inside the window itself; for\n  example, one might have a borderless window that wants to be draggable\n  from any part, or simulate its own title bar, etc.\n\n  This function lets the app provide a callback that designates pieces of\n  a given window as special. This callback is run during event processing\n  if we need to tell the OS to treat a region of the window specially; the\n  use of this callback is known as \"hit testing.\"\n\n  Mouse input may not be delivered to your application if it is within\n  a special area; the OS will often apply that input to moving the window or\n  resizing the window and not deliver it to the application.\n\n  Specifying NULL for a callback disables hit-testing. Hit-testing is\n  disabled by default.\n\n  Platforms that don't support this functionality will return -1\n  unconditionally, even if you're attempting to disable hit-testing.\n\n  Your callback may fire at any time, and its firing does not indicate any\n  specific behavior (for example, on Windows, this certainly might fire\n  when the OS is deciding whether to drag your window, but it fires for lots\n  of other reasons, too, some unrelated to anything you probably care about\n  _and when the mouse isn't actually at the location it is testing_).\n  Since this can fire at any time, you should try to keep your callback\n  efficient, devoid of allocations, etc.\n\n  \\param window The window to set hit-testing on.\n  \\param callback The callback to call when doing a hit-test.\n  \\param callback_data An app-defined void pointer passed to the callback.\n  \\return 0 on success, -1 on error (including unsupported)."]
    pub fn SDL_SetWindowHitTest(
        window: *mut SDL_Window,
        callback: SDL_HitTest,
        callback_data: *mut libc::c_void,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Destroy a window."]
    pub fn SDL_DestroyWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Returns whether the screensaver is currently enabled (default off).\n\n  \\sa SDL_EnableScreenSaver()\n  \\sa SDL_DisableScreenSaver()"]
    pub fn SDL_IsScreenSaverEnabled() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Allow the screen to be blanked by a screensaver\n\n  \\sa SDL_IsScreenSaverEnabled()\n  \\sa SDL_DisableScreenSaver()"]
    pub fn SDL_EnableScreenSaver();
}
extern "C" {
    #[doc = "  \\brief Prevent the screen from being blanked by a screensaver\n\n  \\sa SDL_IsScreenSaverEnabled()\n  \\sa SDL_EnableScreenSaver()"]
    pub fn SDL_DisableScreenSaver();
}
extern "C" {
    #[doc = "  \\brief Dynamically load an OpenGL library.\n\n  \\param path The platform dependent OpenGL library name, or NULL to open the\n              default OpenGL library.\n\n  \\return 0 on success, or -1 if the library couldn't be loaded.\n\n  This should be done after initializing the video driver, but before\n  creating any OpenGL windows.  If no OpenGL library is loaded, the default\n  library will be loaded upon creation of the first OpenGL window.\n\n  \\note If you do this, you need to retrieve all of the GL functions used in\n        your program from the dynamic library using SDL_GL_GetProcAddress().\n\n  \\sa SDL_GL_GetProcAddress()\n  \\sa SDL_GL_UnloadLibrary()"]
    pub fn SDL_GL_LoadLibrary(path: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the address of an OpenGL function."]
    pub fn SDL_GL_GetProcAddress(proc_: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  \\brief Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().\n\n  \\sa SDL_GL_LoadLibrary()"]
    pub fn SDL_GL_UnloadLibrary();
}
extern "C" {
    #[doc = "  \\brief Return true if an OpenGL extension is supported for the current\n         context."]
    pub fn SDL_GL_ExtensionSupported(extension: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Reset all previously set OpenGL context attributes to their default values"]
    pub fn SDL_GL_ResetAttributes();
}
extern "C" {
    #[doc = "  \\brief Set an OpenGL window attribute before window creation.\n\n  \\return 0 on success, or -1 if the attribute could not be set."]
    pub fn SDL_GL_SetAttribute(attr: SDL_GLattr, value: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the actual value for an attribute from the current context.\n\n  \\return 0 on success, or -1 if the attribute could not be retrieved.\n          The integer at \\c value will be modified in either case."]
    pub fn SDL_GL_GetAttribute(attr: SDL_GLattr, value: *mut libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Create an OpenGL context for use with an OpenGL window, and make it\n         current.\n\n  \\sa SDL_GL_DeleteContext()"]
    pub fn SDL_GL_CreateContext(window: *mut SDL_Window) -> SDL_GLContext;
}
extern "C" {
    #[doc = "  \\brief Set up an OpenGL context for rendering into an OpenGL window.\n\n  \\note The context must have been created with a compatible window."]
    pub fn SDL_GL_MakeCurrent(window: *mut SDL_Window, context: SDL_GLContext) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the currently active OpenGL window."]
    pub fn SDL_GL_GetCurrentWindow() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get the currently active OpenGL context."]
    pub fn SDL_GL_GetCurrentContext() -> SDL_GLContext;
}
extern "C" {
    #[doc = "  \\brief Get the size of a window's underlying drawable in pixels (for use\n         with glViewport).\n\n  \\param window   Window from which the drawable size should be queried\n  \\param w        Pointer to variable for storing the width in pixels, may be NULL\n  \\param h        Pointer to variable for storing the height in pixels, may be NULL\n\n This may differ from SDL_GetWindowSize() if we're rendering to a high-DPI\n drawable, i.e. the window was created with SDL_WINDOW_ALLOW_HIGHDPI on a\n platform with high-DPI support (Apple calls this \"Retina\"), and not disabled\n by the SDL_HINT_VIDEO_HIGHDPI_DISABLED hint.\n\n  \\sa SDL_GetWindowSize()\n  \\sa SDL_CreateWindow()"]
    pub fn SDL_GL_GetDrawableSize(
        window: *mut SDL_Window,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set the swap interval for the current OpenGL context.\n\n  \\param interval 0 for immediate updates, 1 for updates synchronized with the\n                  vertical retrace. If the system supports it, you may\n                  specify -1 to allow late swaps to happen immediately\n                  instead of waiting for the next retrace.\n\n  \\return 0 on success, or -1 if setting the swap interval is not supported.\n\n  \\sa SDL_GL_GetSwapInterval()"]
    pub fn SDL_GL_SetSwapInterval(interval: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the swap interval for the current OpenGL context.\n\n  \\return 0 if there is no vertical retrace synchronization, 1 if the buffer\n          swap is synchronized with the vertical retrace, and -1 if late\n          swaps happen immediately instead of waiting for the next retrace.\n          If the system can't determine the swap interval, or there isn't a\n          valid current context, this will return 0 as a safe default.\n\n  \\sa SDL_GL_SetSwapInterval()"]
    pub fn SDL_GL_GetSwapInterval() -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Swap the OpenGL buffers for a window, if double-buffering is\n        supported."]
    pub fn SDL_GL_SwapWindow(window: *mut SDL_Window);
}
extern "C" {
    #[doc = "  \\brief Delete an OpenGL context.\n\n  \\sa SDL_GL_CreateContext()"]
    pub fn SDL_GL_DeleteContext(context: SDL_GLContext);
}
pub const SDL_Scancode_SDL_SCANCODE_UNKNOWN: SDL_Scancode = 0;
pub const SDL_Scancode_SDL_SCANCODE_A: SDL_Scancode = 4;
pub const SDL_Scancode_SDL_SCANCODE_B: SDL_Scancode = 5;
pub const SDL_Scancode_SDL_SCANCODE_C: SDL_Scancode = 6;
pub const SDL_Scancode_SDL_SCANCODE_D: SDL_Scancode = 7;
pub const SDL_Scancode_SDL_SCANCODE_E: SDL_Scancode = 8;
pub const SDL_Scancode_SDL_SCANCODE_F: SDL_Scancode = 9;
pub const SDL_Scancode_SDL_SCANCODE_G: SDL_Scancode = 10;
pub const SDL_Scancode_SDL_SCANCODE_H: SDL_Scancode = 11;
pub const SDL_Scancode_SDL_SCANCODE_I: SDL_Scancode = 12;
pub const SDL_Scancode_SDL_SCANCODE_J: SDL_Scancode = 13;
pub const SDL_Scancode_SDL_SCANCODE_K: SDL_Scancode = 14;
pub const SDL_Scancode_SDL_SCANCODE_L: SDL_Scancode = 15;
pub const SDL_Scancode_SDL_SCANCODE_M: SDL_Scancode = 16;
pub const SDL_Scancode_SDL_SCANCODE_N: SDL_Scancode = 17;
pub const SDL_Scancode_SDL_SCANCODE_O: SDL_Scancode = 18;
pub const SDL_Scancode_SDL_SCANCODE_P: SDL_Scancode = 19;
pub const SDL_Scancode_SDL_SCANCODE_Q: SDL_Scancode = 20;
pub const SDL_Scancode_SDL_SCANCODE_R: SDL_Scancode = 21;
pub const SDL_Scancode_SDL_SCANCODE_S: SDL_Scancode = 22;
pub const SDL_Scancode_SDL_SCANCODE_T: SDL_Scancode = 23;
pub const SDL_Scancode_SDL_SCANCODE_U: SDL_Scancode = 24;
pub const SDL_Scancode_SDL_SCANCODE_V: SDL_Scancode = 25;
pub const SDL_Scancode_SDL_SCANCODE_W: SDL_Scancode = 26;
pub const SDL_Scancode_SDL_SCANCODE_X: SDL_Scancode = 27;
pub const SDL_Scancode_SDL_SCANCODE_Y: SDL_Scancode = 28;
pub const SDL_Scancode_SDL_SCANCODE_Z: SDL_Scancode = 29;
pub const SDL_Scancode_SDL_SCANCODE_1: SDL_Scancode = 30;
pub const SDL_Scancode_SDL_SCANCODE_2: SDL_Scancode = 31;
pub const SDL_Scancode_SDL_SCANCODE_3: SDL_Scancode = 32;
pub const SDL_Scancode_SDL_SCANCODE_4: SDL_Scancode = 33;
pub const SDL_Scancode_SDL_SCANCODE_5: SDL_Scancode = 34;
pub const SDL_Scancode_SDL_SCANCODE_6: SDL_Scancode = 35;
pub const SDL_Scancode_SDL_SCANCODE_7: SDL_Scancode = 36;
pub const SDL_Scancode_SDL_SCANCODE_8: SDL_Scancode = 37;
pub const SDL_Scancode_SDL_SCANCODE_9: SDL_Scancode = 38;
pub const SDL_Scancode_SDL_SCANCODE_0: SDL_Scancode = 39;
pub const SDL_Scancode_SDL_SCANCODE_RETURN: SDL_Scancode = 40;
pub const SDL_Scancode_SDL_SCANCODE_ESCAPE: SDL_Scancode = 41;
pub const SDL_Scancode_SDL_SCANCODE_BACKSPACE: SDL_Scancode = 42;
pub const SDL_Scancode_SDL_SCANCODE_TAB: SDL_Scancode = 43;
pub const SDL_Scancode_SDL_SCANCODE_SPACE: SDL_Scancode = 44;
pub const SDL_Scancode_SDL_SCANCODE_MINUS: SDL_Scancode = 45;
pub const SDL_Scancode_SDL_SCANCODE_EQUALS: SDL_Scancode = 46;
pub const SDL_Scancode_SDL_SCANCODE_LEFTBRACKET: SDL_Scancode = 47;
pub const SDL_Scancode_SDL_SCANCODE_RIGHTBRACKET: SDL_Scancode = 48;
#[doc = "< Located at the lower left of the return\n   key on ISO keyboards and at the right end\n   of the QWERTY row on ANSI keyboards.\n   Produces REVERSE SOLIDUS (backslash) and\n   VERTICAL LINE in a US layout, REVERSE\n   SOLIDUS and VERTICAL LINE in a UK Mac\n   layout, NUMBER SIGN and TILDE in a UK\n   Windows layout, DOLLAR SIGN and POUND SIGN\n   in a Swiss German layout, NUMBER SIGN and\n   APOSTROPHE in a German layout, GRAVE\n   ACCENT and POUND SIGN in a French Mac\n   layout, and ASTERISK and MICRO SIGN in a\n   French Windows layout."]
pub const SDL_Scancode_SDL_SCANCODE_BACKSLASH: SDL_Scancode = 49;
#[doc = "< ISO USB keyboards actually use this code\n   instead of 49 for the same key, but all\n   OSes I've seen treat the two codes\n   identically. So, as an implementor, unless\n   your keyboard generates both of those\n   codes and your OS treats them differently,\n   you should generate SDL_SCANCODE_BACKSLASH\n   instead of this code. As a user, you\n   should not rely on this code because SDL\n   will never generate it with most (all?)\n   keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSHASH: SDL_Scancode = 50;
pub const SDL_Scancode_SDL_SCANCODE_SEMICOLON: SDL_Scancode = 51;
pub const SDL_Scancode_SDL_SCANCODE_APOSTROPHE: SDL_Scancode = 52;
#[doc = "< Located in the top left corner (on both ANSI\n   and ISO keyboards). Produces GRAVE ACCENT and\n   TILDE in a US Windows layout and in US and UK\n   Mac layouts on ANSI keyboards, GRAVE ACCENT\n   and NOT SIGN in a UK Windows layout, SECTION\n   SIGN and PLUS-MINUS SIGN in US and UK Mac\n   layouts on ISO keyboards, SECTION SIGN and\n   DEGREE SIGN in a Swiss German layout (Mac:\n   only on ISO keyboards), CIRCUMFLEX ACCENT and\n   DEGREE SIGN in a German layout (Mac: only on\n   ISO keyboards), SUPERSCRIPT TWO and TILDE in a\n   French Windows layout, COMMERCIAL AT and\n   NUMBER SIGN in a French Mac layout on ISO\n   keyboards, and LESS-THAN SIGN and GREATER-THAN\n   SIGN in a Swiss German, German, or French Mac\n   layout on ANSI keyboards."]
pub const SDL_Scancode_SDL_SCANCODE_GRAVE: SDL_Scancode = 53;
pub const SDL_Scancode_SDL_SCANCODE_COMMA: SDL_Scancode = 54;
pub const SDL_Scancode_SDL_SCANCODE_PERIOD: SDL_Scancode = 55;
pub const SDL_Scancode_SDL_SCANCODE_SLASH: SDL_Scancode = 56;
pub const SDL_Scancode_SDL_SCANCODE_CAPSLOCK: SDL_Scancode = 57;
pub const SDL_Scancode_SDL_SCANCODE_F1: SDL_Scancode = 58;
pub const SDL_Scancode_SDL_SCANCODE_F2: SDL_Scancode = 59;
pub const SDL_Scancode_SDL_SCANCODE_F3: SDL_Scancode = 60;
pub const SDL_Scancode_SDL_SCANCODE_F4: SDL_Scancode = 61;
pub const SDL_Scancode_SDL_SCANCODE_F5: SDL_Scancode = 62;
pub const SDL_Scancode_SDL_SCANCODE_F6: SDL_Scancode = 63;
pub const SDL_Scancode_SDL_SCANCODE_F7: SDL_Scancode = 64;
pub const SDL_Scancode_SDL_SCANCODE_F8: SDL_Scancode = 65;
pub const SDL_Scancode_SDL_SCANCODE_F9: SDL_Scancode = 66;
pub const SDL_Scancode_SDL_SCANCODE_F10: SDL_Scancode = 67;
pub const SDL_Scancode_SDL_SCANCODE_F11: SDL_Scancode = 68;
pub const SDL_Scancode_SDL_SCANCODE_F12: SDL_Scancode = 69;
pub const SDL_Scancode_SDL_SCANCODE_PRINTSCREEN: SDL_Scancode = 70;
pub const SDL_Scancode_SDL_SCANCODE_SCROLLLOCK: SDL_Scancode = 71;
pub const SDL_Scancode_SDL_SCANCODE_PAUSE: SDL_Scancode = 72;
#[doc = "< insert on PC, help on some Mac keyboards (but\ndoes send code 73, not 117)"]
pub const SDL_Scancode_SDL_SCANCODE_INSERT: SDL_Scancode = 73;
pub const SDL_Scancode_SDL_SCANCODE_HOME: SDL_Scancode = 74;
pub const SDL_Scancode_SDL_SCANCODE_PAGEUP: SDL_Scancode = 75;
pub const SDL_Scancode_SDL_SCANCODE_DELETE: SDL_Scancode = 76;
pub const SDL_Scancode_SDL_SCANCODE_END: SDL_Scancode = 77;
pub const SDL_Scancode_SDL_SCANCODE_PAGEDOWN: SDL_Scancode = 78;
pub const SDL_Scancode_SDL_SCANCODE_RIGHT: SDL_Scancode = 79;
pub const SDL_Scancode_SDL_SCANCODE_LEFT: SDL_Scancode = 80;
pub const SDL_Scancode_SDL_SCANCODE_DOWN: SDL_Scancode = 81;
pub const SDL_Scancode_SDL_SCANCODE_UP: SDL_Scancode = 82;
#[doc = "< num lock on PC, clear on Mac keyboards"]
pub const SDL_Scancode_SDL_SCANCODE_NUMLOCKCLEAR: SDL_Scancode = 83;
pub const SDL_Scancode_SDL_SCANCODE_KP_DIVIDE: SDL_Scancode = 84;
pub const SDL_Scancode_SDL_SCANCODE_KP_MULTIPLY: SDL_Scancode = 85;
pub const SDL_Scancode_SDL_SCANCODE_KP_MINUS: SDL_Scancode = 86;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUS: SDL_Scancode = 87;
pub const SDL_Scancode_SDL_SCANCODE_KP_ENTER: SDL_Scancode = 88;
pub const SDL_Scancode_SDL_SCANCODE_KP_1: SDL_Scancode = 89;
pub const SDL_Scancode_SDL_SCANCODE_KP_2: SDL_Scancode = 90;
pub const SDL_Scancode_SDL_SCANCODE_KP_3: SDL_Scancode = 91;
pub const SDL_Scancode_SDL_SCANCODE_KP_4: SDL_Scancode = 92;
pub const SDL_Scancode_SDL_SCANCODE_KP_5: SDL_Scancode = 93;
pub const SDL_Scancode_SDL_SCANCODE_KP_6: SDL_Scancode = 94;
pub const SDL_Scancode_SDL_SCANCODE_KP_7: SDL_Scancode = 95;
pub const SDL_Scancode_SDL_SCANCODE_KP_8: SDL_Scancode = 96;
pub const SDL_Scancode_SDL_SCANCODE_KP_9: SDL_Scancode = 97;
pub const SDL_Scancode_SDL_SCANCODE_KP_0: SDL_Scancode = 98;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERIOD: SDL_Scancode = 99;
#[doc = "< This is the additional key that ISO\n   keyboards have over ANSI ones,\n   located between left shift and Y.\n   Produces GRAVE ACCENT and TILDE in a\n   US or UK Mac layout, REVERSE SOLIDUS\n   (backslash) and VERTICAL LINE in a\n   US or UK Windows layout, and\n   LESS-THAN SIGN and GREATER-THAN SIGN\n   in a Swiss German, German, or French\n   layout."]
pub const SDL_Scancode_SDL_SCANCODE_NONUSBACKSLASH: SDL_Scancode = 100;
#[doc = "< windows contextual menu, compose"]
pub const SDL_Scancode_SDL_SCANCODE_APPLICATION: SDL_Scancode = 101;
#[doc = "< The USB document says this is a status flag,\n   not a physical key - but some Mac keyboards\n   do have a power key."]
pub const SDL_Scancode_SDL_SCANCODE_POWER: SDL_Scancode = 102;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALS: SDL_Scancode = 103;
pub const SDL_Scancode_SDL_SCANCODE_F13: SDL_Scancode = 104;
pub const SDL_Scancode_SDL_SCANCODE_F14: SDL_Scancode = 105;
pub const SDL_Scancode_SDL_SCANCODE_F15: SDL_Scancode = 106;
pub const SDL_Scancode_SDL_SCANCODE_F16: SDL_Scancode = 107;
pub const SDL_Scancode_SDL_SCANCODE_F17: SDL_Scancode = 108;
pub const SDL_Scancode_SDL_SCANCODE_F18: SDL_Scancode = 109;
pub const SDL_Scancode_SDL_SCANCODE_F19: SDL_Scancode = 110;
pub const SDL_Scancode_SDL_SCANCODE_F20: SDL_Scancode = 111;
pub const SDL_Scancode_SDL_SCANCODE_F21: SDL_Scancode = 112;
pub const SDL_Scancode_SDL_SCANCODE_F22: SDL_Scancode = 113;
pub const SDL_Scancode_SDL_SCANCODE_F23: SDL_Scancode = 114;
pub const SDL_Scancode_SDL_SCANCODE_F24: SDL_Scancode = 115;
pub const SDL_Scancode_SDL_SCANCODE_EXECUTE: SDL_Scancode = 116;
pub const SDL_Scancode_SDL_SCANCODE_HELP: SDL_Scancode = 117;
pub const SDL_Scancode_SDL_SCANCODE_MENU: SDL_Scancode = 118;
pub const SDL_Scancode_SDL_SCANCODE_SELECT: SDL_Scancode = 119;
pub const SDL_Scancode_SDL_SCANCODE_STOP: SDL_Scancode = 120;
#[doc = "< redo"]
pub const SDL_Scancode_SDL_SCANCODE_AGAIN: SDL_Scancode = 121;
pub const SDL_Scancode_SDL_SCANCODE_UNDO: SDL_Scancode = 122;
pub const SDL_Scancode_SDL_SCANCODE_CUT: SDL_Scancode = 123;
pub const SDL_Scancode_SDL_SCANCODE_COPY: SDL_Scancode = 124;
pub const SDL_Scancode_SDL_SCANCODE_PASTE: SDL_Scancode = 125;
pub const SDL_Scancode_SDL_SCANCODE_FIND: SDL_Scancode = 126;
pub const SDL_Scancode_SDL_SCANCODE_MUTE: SDL_Scancode = 127;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEUP: SDL_Scancode = 128;
pub const SDL_Scancode_SDL_SCANCODE_VOLUMEDOWN: SDL_Scancode = 129;
pub const SDL_Scancode_SDL_SCANCODE_KP_COMMA: SDL_Scancode = 133;
pub const SDL_Scancode_SDL_SCANCODE_KP_EQUALSAS400: SDL_Scancode = 134;
#[doc = "< used on Asian keyboards, see\nfootnotes in USB doc"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL1: SDL_Scancode = 135;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL2: SDL_Scancode = 136;
#[doc = "< Yen"]
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL3: SDL_Scancode = 137;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL4: SDL_Scancode = 138;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL5: SDL_Scancode = 139;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL6: SDL_Scancode = 140;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL7: SDL_Scancode = 141;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL8: SDL_Scancode = 142;
pub const SDL_Scancode_SDL_SCANCODE_INTERNATIONAL9: SDL_Scancode = 143;
#[doc = "< Hangul/English toggle"]
pub const SDL_Scancode_SDL_SCANCODE_LANG1: SDL_Scancode = 144;
#[doc = "< Hanja conversion"]
pub const SDL_Scancode_SDL_SCANCODE_LANG2: SDL_Scancode = 145;
#[doc = "< Katakana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG3: SDL_Scancode = 146;
#[doc = "< Hiragana"]
pub const SDL_Scancode_SDL_SCANCODE_LANG4: SDL_Scancode = 147;
#[doc = "< Zenkaku/Hankaku"]
pub const SDL_Scancode_SDL_SCANCODE_LANG5: SDL_Scancode = 148;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG6: SDL_Scancode = 149;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG7: SDL_Scancode = 150;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG8: SDL_Scancode = 151;
#[doc = "< reserved"]
pub const SDL_Scancode_SDL_SCANCODE_LANG9: SDL_Scancode = 152;
#[doc = "< Erase-Eaze"]
pub const SDL_Scancode_SDL_SCANCODE_ALTERASE: SDL_Scancode = 153;
pub const SDL_Scancode_SDL_SCANCODE_SYSREQ: SDL_Scancode = 154;
pub const SDL_Scancode_SDL_SCANCODE_CANCEL: SDL_Scancode = 155;
pub const SDL_Scancode_SDL_SCANCODE_CLEAR: SDL_Scancode = 156;
pub const SDL_Scancode_SDL_SCANCODE_PRIOR: SDL_Scancode = 157;
pub const SDL_Scancode_SDL_SCANCODE_RETURN2: SDL_Scancode = 158;
pub const SDL_Scancode_SDL_SCANCODE_SEPARATOR: SDL_Scancode = 159;
pub const SDL_Scancode_SDL_SCANCODE_OUT: SDL_Scancode = 160;
pub const SDL_Scancode_SDL_SCANCODE_OPER: SDL_Scancode = 161;
pub const SDL_Scancode_SDL_SCANCODE_CLEARAGAIN: SDL_Scancode = 162;
pub const SDL_Scancode_SDL_SCANCODE_CRSEL: SDL_Scancode = 163;
pub const SDL_Scancode_SDL_SCANCODE_EXSEL: SDL_Scancode = 164;
pub const SDL_Scancode_SDL_SCANCODE_KP_00: SDL_Scancode = 176;
pub const SDL_Scancode_SDL_SCANCODE_KP_000: SDL_Scancode = 177;
pub const SDL_Scancode_SDL_SCANCODE_THOUSANDSSEPARATOR: SDL_Scancode = 178;
pub const SDL_Scancode_SDL_SCANCODE_DECIMALSEPARATOR: SDL_Scancode = 179;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYUNIT: SDL_Scancode = 180;
pub const SDL_Scancode_SDL_SCANCODE_CURRENCYSUBUNIT: SDL_Scancode = 181;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTPAREN: SDL_Scancode = 182;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTPAREN: SDL_Scancode = 183;
pub const SDL_Scancode_SDL_SCANCODE_KP_LEFTBRACE: SDL_Scancode = 184;
pub const SDL_Scancode_SDL_SCANCODE_KP_RIGHTBRACE: SDL_Scancode = 185;
pub const SDL_Scancode_SDL_SCANCODE_KP_TAB: SDL_Scancode = 186;
pub const SDL_Scancode_SDL_SCANCODE_KP_BACKSPACE: SDL_Scancode = 187;
pub const SDL_Scancode_SDL_SCANCODE_KP_A: SDL_Scancode = 188;
pub const SDL_Scancode_SDL_SCANCODE_KP_B: SDL_Scancode = 189;
pub const SDL_Scancode_SDL_SCANCODE_KP_C: SDL_Scancode = 190;
pub const SDL_Scancode_SDL_SCANCODE_KP_D: SDL_Scancode = 191;
pub const SDL_Scancode_SDL_SCANCODE_KP_E: SDL_Scancode = 192;
pub const SDL_Scancode_SDL_SCANCODE_KP_F: SDL_Scancode = 193;
pub const SDL_Scancode_SDL_SCANCODE_KP_XOR: SDL_Scancode = 194;
pub const SDL_Scancode_SDL_SCANCODE_KP_POWER: SDL_Scancode = 195;
pub const SDL_Scancode_SDL_SCANCODE_KP_PERCENT: SDL_Scancode = 196;
pub const SDL_Scancode_SDL_SCANCODE_KP_LESS: SDL_Scancode = 197;
pub const SDL_Scancode_SDL_SCANCODE_KP_GREATER: SDL_Scancode = 198;
pub const SDL_Scancode_SDL_SCANCODE_KP_AMPERSAND: SDL_Scancode = 199;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLAMPERSAND: SDL_Scancode = 200;
pub const SDL_Scancode_SDL_SCANCODE_KP_VERTICALBAR: SDL_Scancode = 201;
pub const SDL_Scancode_SDL_SCANCODE_KP_DBLVERTICALBAR: SDL_Scancode = 202;
pub const SDL_Scancode_SDL_SCANCODE_KP_COLON: SDL_Scancode = 203;
pub const SDL_Scancode_SDL_SCANCODE_KP_HASH: SDL_Scancode = 204;
pub const SDL_Scancode_SDL_SCANCODE_KP_SPACE: SDL_Scancode = 205;
pub const SDL_Scancode_SDL_SCANCODE_KP_AT: SDL_Scancode = 206;
pub const SDL_Scancode_SDL_SCANCODE_KP_EXCLAM: SDL_Scancode = 207;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSTORE: SDL_Scancode = 208;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMRECALL: SDL_Scancode = 209;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMCLEAR: SDL_Scancode = 210;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMADD: SDL_Scancode = 211;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMSUBTRACT: SDL_Scancode = 212;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMMULTIPLY: SDL_Scancode = 213;
pub const SDL_Scancode_SDL_SCANCODE_KP_MEMDIVIDE: SDL_Scancode = 214;
pub const SDL_Scancode_SDL_SCANCODE_KP_PLUSMINUS: SDL_Scancode = 215;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEAR: SDL_Scancode = 216;
pub const SDL_Scancode_SDL_SCANCODE_KP_CLEARENTRY: SDL_Scancode = 217;
pub const SDL_Scancode_SDL_SCANCODE_KP_BINARY: SDL_Scancode = 218;
pub const SDL_Scancode_SDL_SCANCODE_KP_OCTAL: SDL_Scancode = 219;
pub const SDL_Scancode_SDL_SCANCODE_KP_DECIMAL: SDL_Scancode = 220;
pub const SDL_Scancode_SDL_SCANCODE_KP_HEXADECIMAL: SDL_Scancode = 221;
pub const SDL_Scancode_SDL_SCANCODE_LCTRL: SDL_Scancode = 224;
pub const SDL_Scancode_SDL_SCANCODE_LSHIFT: SDL_Scancode = 225;
#[doc = "< alt, option"]
pub const SDL_Scancode_SDL_SCANCODE_LALT: SDL_Scancode = 226;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_LGUI: SDL_Scancode = 227;
pub const SDL_Scancode_SDL_SCANCODE_RCTRL: SDL_Scancode = 228;
pub const SDL_Scancode_SDL_SCANCODE_RSHIFT: SDL_Scancode = 229;
#[doc = "< alt gr, option"]
pub const SDL_Scancode_SDL_SCANCODE_RALT: SDL_Scancode = 230;
#[doc = "< windows, command (apple), meta"]
pub const SDL_Scancode_SDL_SCANCODE_RGUI: SDL_Scancode = 231;
#[doc = "< I'm not sure if this is really not covered\n   by any of the above, but since there's a\n   special KMOD_MODE for it I'm adding it here"]
pub const SDL_Scancode_SDL_SCANCODE_MODE: SDL_Scancode = 257;
pub const SDL_Scancode_SDL_SCANCODE_AUDIONEXT: SDL_Scancode = 258;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOPREV: SDL_Scancode = 259;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOSTOP: SDL_Scancode = 260;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOPLAY: SDL_Scancode = 261;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOMUTE: SDL_Scancode = 262;
pub const SDL_Scancode_SDL_SCANCODE_MEDIASELECT: SDL_Scancode = 263;
pub const SDL_Scancode_SDL_SCANCODE_WWW: SDL_Scancode = 264;
pub const SDL_Scancode_SDL_SCANCODE_MAIL: SDL_Scancode = 265;
pub const SDL_Scancode_SDL_SCANCODE_CALCULATOR: SDL_Scancode = 266;
pub const SDL_Scancode_SDL_SCANCODE_COMPUTER: SDL_Scancode = 267;
pub const SDL_Scancode_SDL_SCANCODE_AC_SEARCH: SDL_Scancode = 268;
pub const SDL_Scancode_SDL_SCANCODE_AC_HOME: SDL_Scancode = 269;
pub const SDL_Scancode_SDL_SCANCODE_AC_BACK: SDL_Scancode = 270;
pub const SDL_Scancode_SDL_SCANCODE_AC_FORWARD: SDL_Scancode = 271;
pub const SDL_Scancode_SDL_SCANCODE_AC_STOP: SDL_Scancode = 272;
pub const SDL_Scancode_SDL_SCANCODE_AC_REFRESH: SDL_Scancode = 273;
pub const SDL_Scancode_SDL_SCANCODE_AC_BOOKMARKS: SDL_Scancode = 274;
pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSDOWN: SDL_Scancode = 275;
pub const SDL_Scancode_SDL_SCANCODE_BRIGHTNESSUP: SDL_Scancode = 276;
#[doc = "< display mirroring/dual display\nswitch, video mode switch"]
pub const SDL_Scancode_SDL_SCANCODE_DISPLAYSWITCH: SDL_Scancode = 277;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMTOGGLE: SDL_Scancode = 278;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMDOWN: SDL_Scancode = 279;
pub const SDL_Scancode_SDL_SCANCODE_KBDILLUMUP: SDL_Scancode = 280;
pub const SDL_Scancode_SDL_SCANCODE_EJECT: SDL_Scancode = 281;
pub const SDL_Scancode_SDL_SCANCODE_SLEEP: SDL_Scancode = 282;
pub const SDL_Scancode_SDL_SCANCODE_APP1: SDL_Scancode = 283;
pub const SDL_Scancode_SDL_SCANCODE_APP2: SDL_Scancode = 284;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOREWIND: SDL_Scancode = 285;
pub const SDL_Scancode_SDL_SCANCODE_AUDIOFASTFORWARD: SDL_Scancode = 286;
#[doc = "< not a key, just marks the number of scancodes\nfor array bounds"]
pub const SDL_Scancode_SDL_NUM_SCANCODES: SDL_Scancode = 512;
#[doc = "  \\brief The SDL keyboard scancode representation.\n\n  Values of this type are used to represent keyboard keys, among other places\n  in the \\link SDL_Keysym::scancode key.keysym.scancode \\endlink field of the\n  SDL_Event structure.\n\n  The values in this enumeration are based on the USB usage page standard:\n  https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf"]
pub type SDL_Scancode = libc::c_int;
#[doc = "  \\brief The SDL virtual key representation.\n\n  Values of this type are used to represent keyboard keys using the current\n  layout of the keyboard.  These values include Unicode values representing\n  the unmodified character that would be generated by pressing the key, or\n  an SDLK_* constant for those keys that do not generate characters.\n\n  A special exception is the number keys at the top of the keyboard which\n  always map to SDLK_0...SDLK_9, regardless of layout."]
pub type SDL_Keycode = Sint32;
pub const SDLK_UNKNOWN: _bindgen_ty_15 = 0;
pub const SDLK_RETURN: _bindgen_ty_15 = 13;
pub const SDLK_ESCAPE: _bindgen_ty_15 = 27;
pub const SDLK_BACKSPACE: _bindgen_ty_15 = 8;
pub const SDLK_TAB: _bindgen_ty_15 = 9;
pub const SDLK_SPACE: _bindgen_ty_15 = 32;
pub const SDLK_EXCLAIM: _bindgen_ty_15 = 33;
pub const SDLK_QUOTEDBL: _bindgen_ty_15 = 34;
pub const SDLK_HASH: _bindgen_ty_15 = 35;
pub const SDLK_PERCENT: _bindgen_ty_15 = 37;
pub const SDLK_DOLLAR: _bindgen_ty_15 = 36;
pub const SDLK_AMPERSAND: _bindgen_ty_15 = 38;
pub const SDLK_QUOTE: _bindgen_ty_15 = 39;
pub const SDLK_LEFTPAREN: _bindgen_ty_15 = 40;
pub const SDLK_RIGHTPAREN: _bindgen_ty_15 = 41;
pub const SDLK_ASTERISK: _bindgen_ty_15 = 42;
pub const SDLK_PLUS: _bindgen_ty_15 = 43;
pub const SDLK_COMMA: _bindgen_ty_15 = 44;
pub const SDLK_MINUS: _bindgen_ty_15 = 45;
pub const SDLK_PERIOD: _bindgen_ty_15 = 46;
pub const SDLK_SLASH: _bindgen_ty_15 = 47;
pub const SDLK_0: _bindgen_ty_15 = 48;
pub const SDLK_1: _bindgen_ty_15 = 49;
pub const SDLK_2: _bindgen_ty_15 = 50;
pub const SDLK_3: _bindgen_ty_15 = 51;
pub const SDLK_4: _bindgen_ty_15 = 52;
pub const SDLK_5: _bindgen_ty_15 = 53;
pub const SDLK_6: _bindgen_ty_15 = 54;
pub const SDLK_7: _bindgen_ty_15 = 55;
pub const SDLK_8: _bindgen_ty_15 = 56;
pub const SDLK_9: _bindgen_ty_15 = 57;
pub const SDLK_COLON: _bindgen_ty_15 = 58;
pub const SDLK_SEMICOLON: _bindgen_ty_15 = 59;
pub const SDLK_LESS: _bindgen_ty_15 = 60;
pub const SDLK_EQUALS: _bindgen_ty_15 = 61;
pub const SDLK_GREATER: _bindgen_ty_15 = 62;
pub const SDLK_QUESTION: _bindgen_ty_15 = 63;
pub const SDLK_AT: _bindgen_ty_15 = 64;
pub const SDLK_LEFTBRACKET: _bindgen_ty_15 = 91;
pub const SDLK_BACKSLASH: _bindgen_ty_15 = 92;
pub const SDLK_RIGHTBRACKET: _bindgen_ty_15 = 93;
pub const SDLK_CARET: _bindgen_ty_15 = 94;
pub const SDLK_UNDERSCORE: _bindgen_ty_15 = 95;
pub const SDLK_BACKQUOTE: _bindgen_ty_15 = 96;
pub const SDLK_a: _bindgen_ty_15 = 97;
pub const SDLK_b: _bindgen_ty_15 = 98;
pub const SDLK_c: _bindgen_ty_15 = 99;
pub const SDLK_d: _bindgen_ty_15 = 100;
pub const SDLK_e: _bindgen_ty_15 = 101;
pub const SDLK_f: _bindgen_ty_15 = 102;
pub const SDLK_g: _bindgen_ty_15 = 103;
pub const SDLK_h: _bindgen_ty_15 = 104;
pub const SDLK_i: _bindgen_ty_15 = 105;
pub const SDLK_j: _bindgen_ty_15 = 106;
pub const SDLK_k: _bindgen_ty_15 = 107;
pub const SDLK_l: _bindgen_ty_15 = 108;
pub const SDLK_m: _bindgen_ty_15 = 109;
pub const SDLK_n: _bindgen_ty_15 = 110;
pub const SDLK_o: _bindgen_ty_15 = 111;
pub const SDLK_p: _bindgen_ty_15 = 112;
pub const SDLK_q: _bindgen_ty_15 = 113;
pub const SDLK_r: _bindgen_ty_15 = 114;
pub const SDLK_s: _bindgen_ty_15 = 115;
pub const SDLK_t: _bindgen_ty_15 = 116;
pub const SDLK_u: _bindgen_ty_15 = 117;
pub const SDLK_v: _bindgen_ty_15 = 118;
pub const SDLK_w: _bindgen_ty_15 = 119;
pub const SDLK_x: _bindgen_ty_15 = 120;
pub const SDLK_y: _bindgen_ty_15 = 121;
pub const SDLK_z: _bindgen_ty_15 = 122;
pub const SDLK_CAPSLOCK: _bindgen_ty_15 = 1073741881;
pub const SDLK_F1: _bindgen_ty_15 = 1073741882;
pub const SDLK_F2: _bindgen_ty_15 = 1073741883;
pub const SDLK_F3: _bindgen_ty_15 = 1073741884;
pub const SDLK_F4: _bindgen_ty_15 = 1073741885;
pub const SDLK_F5: _bindgen_ty_15 = 1073741886;
pub const SDLK_F6: _bindgen_ty_15 = 1073741887;
pub const SDLK_F7: _bindgen_ty_15 = 1073741888;
pub const SDLK_F8: _bindgen_ty_15 = 1073741889;
pub const SDLK_F9: _bindgen_ty_15 = 1073741890;
pub const SDLK_F10: _bindgen_ty_15 = 1073741891;
pub const SDLK_F11: _bindgen_ty_15 = 1073741892;
pub const SDLK_F12: _bindgen_ty_15 = 1073741893;
pub const SDLK_PRINTSCREEN: _bindgen_ty_15 = 1073741894;
pub const SDLK_SCROLLLOCK: _bindgen_ty_15 = 1073741895;
pub const SDLK_PAUSE: _bindgen_ty_15 = 1073741896;
pub const SDLK_INSERT: _bindgen_ty_15 = 1073741897;
pub const SDLK_HOME: _bindgen_ty_15 = 1073741898;
pub const SDLK_PAGEUP: _bindgen_ty_15 = 1073741899;
pub const SDLK_DELETE: _bindgen_ty_15 = 127;
pub const SDLK_END: _bindgen_ty_15 = 1073741901;
pub const SDLK_PAGEDOWN: _bindgen_ty_15 = 1073741902;
pub const SDLK_RIGHT: _bindgen_ty_15 = 1073741903;
pub const SDLK_LEFT: _bindgen_ty_15 = 1073741904;
pub const SDLK_DOWN: _bindgen_ty_15 = 1073741905;
pub const SDLK_UP: _bindgen_ty_15 = 1073741906;
pub const SDLK_NUMLOCKCLEAR: _bindgen_ty_15 = 1073741907;
pub const SDLK_KP_DIVIDE: _bindgen_ty_15 = 1073741908;
pub const SDLK_KP_MULTIPLY: _bindgen_ty_15 = 1073741909;
pub const SDLK_KP_MINUS: _bindgen_ty_15 = 1073741910;
pub const SDLK_KP_PLUS: _bindgen_ty_15 = 1073741911;
pub const SDLK_KP_ENTER: _bindgen_ty_15 = 1073741912;
pub const SDLK_KP_1: _bindgen_ty_15 = 1073741913;
pub const SDLK_KP_2: _bindgen_ty_15 = 1073741914;
pub const SDLK_KP_3: _bindgen_ty_15 = 1073741915;
pub const SDLK_KP_4: _bindgen_ty_15 = 1073741916;
pub const SDLK_KP_5: _bindgen_ty_15 = 1073741917;
pub const SDLK_KP_6: _bindgen_ty_15 = 1073741918;
pub const SDLK_KP_7: _bindgen_ty_15 = 1073741919;
pub const SDLK_KP_8: _bindgen_ty_15 = 1073741920;
pub const SDLK_KP_9: _bindgen_ty_15 = 1073741921;
pub const SDLK_KP_0: _bindgen_ty_15 = 1073741922;
pub const SDLK_KP_PERIOD: _bindgen_ty_15 = 1073741923;
pub const SDLK_APPLICATION: _bindgen_ty_15 = 1073741925;
pub const SDLK_POWER: _bindgen_ty_15 = 1073741926;
pub const SDLK_KP_EQUALS: _bindgen_ty_15 = 1073741927;
pub const SDLK_F13: _bindgen_ty_15 = 1073741928;
pub const SDLK_F14: _bindgen_ty_15 = 1073741929;
pub const SDLK_F15: _bindgen_ty_15 = 1073741930;
pub const SDLK_F16: _bindgen_ty_15 = 1073741931;
pub const SDLK_F17: _bindgen_ty_15 = 1073741932;
pub const SDLK_F18: _bindgen_ty_15 = 1073741933;
pub const SDLK_F19: _bindgen_ty_15 = 1073741934;
pub const SDLK_F20: _bindgen_ty_15 = 1073741935;
pub const SDLK_F21: _bindgen_ty_15 = 1073741936;
pub const SDLK_F22: _bindgen_ty_15 = 1073741937;
pub const SDLK_F23: _bindgen_ty_15 = 1073741938;
pub const SDLK_F24: _bindgen_ty_15 = 1073741939;
pub const SDLK_EXECUTE: _bindgen_ty_15 = 1073741940;
pub const SDLK_HELP: _bindgen_ty_15 = 1073741941;
pub const SDLK_MENU: _bindgen_ty_15 = 1073741942;
pub const SDLK_SELECT: _bindgen_ty_15 = 1073741943;
pub const SDLK_STOP: _bindgen_ty_15 = 1073741944;
pub const SDLK_AGAIN: _bindgen_ty_15 = 1073741945;
pub const SDLK_UNDO: _bindgen_ty_15 = 1073741946;
pub const SDLK_CUT: _bindgen_ty_15 = 1073741947;
pub const SDLK_COPY: _bindgen_ty_15 = 1073741948;
pub const SDLK_PASTE: _bindgen_ty_15 = 1073741949;
pub const SDLK_FIND: _bindgen_ty_15 = 1073741950;
pub const SDLK_MUTE: _bindgen_ty_15 = 1073741951;
pub const SDLK_VOLUMEUP: _bindgen_ty_15 = 1073741952;
pub const SDLK_VOLUMEDOWN: _bindgen_ty_15 = 1073741953;
pub const SDLK_KP_COMMA: _bindgen_ty_15 = 1073741957;
pub const SDLK_KP_EQUALSAS400: _bindgen_ty_15 = 1073741958;
pub const SDLK_ALTERASE: _bindgen_ty_15 = 1073741977;
pub const SDLK_SYSREQ: _bindgen_ty_15 = 1073741978;
pub const SDLK_CANCEL: _bindgen_ty_15 = 1073741979;
pub const SDLK_CLEAR: _bindgen_ty_15 = 1073741980;
pub const SDLK_PRIOR: _bindgen_ty_15 = 1073741981;
pub const SDLK_RETURN2: _bindgen_ty_15 = 1073741982;
pub const SDLK_SEPARATOR: _bindgen_ty_15 = 1073741983;
pub const SDLK_OUT: _bindgen_ty_15 = 1073741984;
pub const SDLK_OPER: _bindgen_ty_15 = 1073741985;
pub const SDLK_CLEARAGAIN: _bindgen_ty_15 = 1073741986;
pub const SDLK_CRSEL: _bindgen_ty_15 = 1073741987;
pub const SDLK_EXSEL: _bindgen_ty_15 = 1073741988;
pub const SDLK_KP_00: _bindgen_ty_15 = 1073742000;
pub const SDLK_KP_000: _bindgen_ty_15 = 1073742001;
pub const SDLK_THOUSANDSSEPARATOR: _bindgen_ty_15 = 1073742002;
pub const SDLK_DECIMALSEPARATOR: _bindgen_ty_15 = 1073742003;
pub const SDLK_CURRENCYUNIT: _bindgen_ty_15 = 1073742004;
pub const SDLK_CURRENCYSUBUNIT: _bindgen_ty_15 = 1073742005;
pub const SDLK_KP_LEFTPAREN: _bindgen_ty_15 = 1073742006;
pub const SDLK_KP_RIGHTPAREN: _bindgen_ty_15 = 1073742007;
pub const SDLK_KP_LEFTBRACE: _bindgen_ty_15 = 1073742008;
pub const SDLK_KP_RIGHTBRACE: _bindgen_ty_15 = 1073742009;
pub const SDLK_KP_TAB: _bindgen_ty_15 = 1073742010;
pub const SDLK_KP_BACKSPACE: _bindgen_ty_15 = 1073742011;
pub const SDLK_KP_A: _bindgen_ty_15 = 1073742012;
pub const SDLK_KP_B: _bindgen_ty_15 = 1073742013;
pub const SDLK_KP_C: _bindgen_ty_15 = 1073742014;
pub const SDLK_KP_D: _bindgen_ty_15 = 1073742015;
pub const SDLK_KP_E: _bindgen_ty_15 = 1073742016;
pub const SDLK_KP_F: _bindgen_ty_15 = 1073742017;
pub const SDLK_KP_XOR: _bindgen_ty_15 = 1073742018;
pub const SDLK_KP_POWER: _bindgen_ty_15 = 1073742019;
pub const SDLK_KP_PERCENT: _bindgen_ty_15 = 1073742020;
pub const SDLK_KP_LESS: _bindgen_ty_15 = 1073742021;
pub const SDLK_KP_GREATER: _bindgen_ty_15 = 1073742022;
pub const SDLK_KP_AMPERSAND: _bindgen_ty_15 = 1073742023;
pub const SDLK_KP_DBLAMPERSAND: _bindgen_ty_15 = 1073742024;
pub const SDLK_KP_VERTICALBAR: _bindgen_ty_15 = 1073742025;
pub const SDLK_KP_DBLVERTICALBAR: _bindgen_ty_15 = 1073742026;
pub const SDLK_KP_COLON: _bindgen_ty_15 = 1073742027;
pub const SDLK_KP_HASH: _bindgen_ty_15 = 1073742028;
pub const SDLK_KP_SPACE: _bindgen_ty_15 = 1073742029;
pub const SDLK_KP_AT: _bindgen_ty_15 = 1073742030;
pub const SDLK_KP_EXCLAM: _bindgen_ty_15 = 1073742031;
pub const SDLK_KP_MEMSTORE: _bindgen_ty_15 = 1073742032;
pub const SDLK_KP_MEMRECALL: _bindgen_ty_15 = 1073742033;
pub const SDLK_KP_MEMCLEAR: _bindgen_ty_15 = 1073742034;
pub const SDLK_KP_MEMADD: _bindgen_ty_15 = 1073742035;
pub const SDLK_KP_MEMSUBTRACT: _bindgen_ty_15 = 1073742036;
pub const SDLK_KP_MEMMULTIPLY: _bindgen_ty_15 = 1073742037;
pub const SDLK_KP_MEMDIVIDE: _bindgen_ty_15 = 1073742038;
pub const SDLK_KP_PLUSMINUS: _bindgen_ty_15 = 1073742039;
pub const SDLK_KP_CLEAR: _bindgen_ty_15 = 1073742040;
pub const SDLK_KP_CLEARENTRY: _bindgen_ty_15 = 1073742041;
pub const SDLK_KP_BINARY: _bindgen_ty_15 = 1073742042;
pub const SDLK_KP_OCTAL: _bindgen_ty_15 = 1073742043;
pub const SDLK_KP_DECIMAL: _bindgen_ty_15 = 1073742044;
pub const SDLK_KP_HEXADECIMAL: _bindgen_ty_15 = 1073742045;
pub const SDLK_LCTRL: _bindgen_ty_15 = 1073742048;
pub const SDLK_LSHIFT: _bindgen_ty_15 = 1073742049;
pub const SDLK_LALT: _bindgen_ty_15 = 1073742050;
pub const SDLK_LGUI: _bindgen_ty_15 = 1073742051;
pub const SDLK_RCTRL: _bindgen_ty_15 = 1073742052;
pub const SDLK_RSHIFT: _bindgen_ty_15 = 1073742053;
pub const SDLK_RALT: _bindgen_ty_15 = 1073742054;
pub const SDLK_RGUI: _bindgen_ty_15 = 1073742055;
pub const SDLK_MODE: _bindgen_ty_15 = 1073742081;
pub const SDLK_AUDIONEXT: _bindgen_ty_15 = 1073742082;
pub const SDLK_AUDIOPREV: _bindgen_ty_15 = 1073742083;
pub const SDLK_AUDIOSTOP: _bindgen_ty_15 = 1073742084;
pub const SDLK_AUDIOPLAY: _bindgen_ty_15 = 1073742085;
pub const SDLK_AUDIOMUTE: _bindgen_ty_15 = 1073742086;
pub const SDLK_MEDIASELECT: _bindgen_ty_15 = 1073742087;
pub const SDLK_WWW: _bindgen_ty_15 = 1073742088;
pub const SDLK_MAIL: _bindgen_ty_15 = 1073742089;
pub const SDLK_CALCULATOR: _bindgen_ty_15 = 1073742090;
pub const SDLK_COMPUTER: _bindgen_ty_15 = 1073742091;
pub const SDLK_AC_SEARCH: _bindgen_ty_15 = 1073742092;
pub const SDLK_AC_HOME: _bindgen_ty_15 = 1073742093;
pub const SDLK_AC_BACK: _bindgen_ty_15 = 1073742094;
pub const SDLK_AC_FORWARD: _bindgen_ty_15 = 1073742095;
pub const SDLK_AC_STOP: _bindgen_ty_15 = 1073742096;
pub const SDLK_AC_REFRESH: _bindgen_ty_15 = 1073742097;
pub const SDLK_AC_BOOKMARKS: _bindgen_ty_15 = 1073742098;
pub const SDLK_BRIGHTNESSDOWN: _bindgen_ty_15 = 1073742099;
pub const SDLK_BRIGHTNESSUP: _bindgen_ty_15 = 1073742100;
pub const SDLK_DISPLAYSWITCH: _bindgen_ty_15 = 1073742101;
pub const SDLK_KBDILLUMTOGGLE: _bindgen_ty_15 = 1073742102;
pub const SDLK_KBDILLUMDOWN: _bindgen_ty_15 = 1073742103;
pub const SDLK_KBDILLUMUP: _bindgen_ty_15 = 1073742104;
pub const SDLK_EJECT: _bindgen_ty_15 = 1073742105;
pub const SDLK_SLEEP: _bindgen_ty_15 = 1073742106;
pub const SDLK_APP1: _bindgen_ty_15 = 1073742107;
pub const SDLK_APP2: _bindgen_ty_15 = 1073742108;
pub const SDLK_AUDIOREWIND: _bindgen_ty_15 = 1073742109;
pub const SDLK_AUDIOFASTFORWARD: _bindgen_ty_15 = 1073742110;
pub type _bindgen_ty_15 = libc::c_int;
pub const SDL_Keymod_KMOD_NONE: SDL_Keymod = 0;
pub const SDL_Keymod_KMOD_LSHIFT: SDL_Keymod = 1;
pub const SDL_Keymod_KMOD_RSHIFT: SDL_Keymod = 2;
pub const SDL_Keymod_KMOD_LCTRL: SDL_Keymod = 64;
pub const SDL_Keymod_KMOD_RCTRL: SDL_Keymod = 128;
pub const SDL_Keymod_KMOD_LALT: SDL_Keymod = 256;
pub const SDL_Keymod_KMOD_RALT: SDL_Keymod = 512;
pub const SDL_Keymod_KMOD_LGUI: SDL_Keymod = 1024;
pub const SDL_Keymod_KMOD_RGUI: SDL_Keymod = 2048;
pub const SDL_Keymod_KMOD_NUM: SDL_Keymod = 4096;
pub const SDL_Keymod_KMOD_CAPS: SDL_Keymod = 8192;
pub const SDL_Keymod_KMOD_MODE: SDL_Keymod = 16384;
pub const SDL_Keymod_KMOD_RESERVED: SDL_Keymod = 32768;
#[doc = " \\brief Enumeration of valid key mods (possibly OR'd together)."]
pub type SDL_Keymod = libc::c_int;
#[doc = "  \\brief The SDL keysym structure, used in key events.\n\n  \\note  If you are looking for translated character input, see the ::SDL_TEXTINPUT event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Keysym {
    #[doc = "< SDL physical key code - see ::SDL_Scancode for details"]
    pub scancode: SDL_Scancode,
    #[doc = "< SDL virtual key code - see ::SDL_Keycode for details"]
    pub sym: SDL_Keycode,
    #[doc = "< current key modifiers"]
    pub mod_: Uint16,
    pub unused: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_Keysym() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Keysym> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Keysym>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Keysym>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Keysym))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).scancode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(scancode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sym) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(sym)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mod_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Keysym),
            "::",
            stringify!(unused)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the window which currently has keyboard focus."]
    pub fn SDL_GetKeyboardFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Get a snapshot of the current state of the keyboard.\n\n  \\param numkeys if non-NULL, receives the length of the returned array.\n\n  \\return An array of key states. Indexes into this array are obtained by using ::SDL_Scancode values.\n\n  \\b Example:\n  \\code\n  const Uint8 *state = SDL_GetKeyboardState(NULL);\n  if ( state[SDL_SCANCODE_RETURN] )   {\n      printf(\"<RETURN> is pressed.\\n\");\n  }\n  \\endcode"]
    pub fn SDL_GetKeyboardState(numkeys: *mut libc::c_int) -> *const Uint8;
}
extern "C" {
    #[doc = "  \\brief Get the current key modifier state for the keyboard."]
    pub fn SDL_GetModState() -> SDL_Keymod;
}
extern "C" {
    #[doc = "  \\brief Set the current key modifier state for the keyboard.\n\n  \\note This does not change the keyboard state, only the key modifier flags."]
    pub fn SDL_SetModState(modstate: SDL_Keymod);
}
extern "C" {
    #[doc = "  \\brief Get the key code corresponding to the given scancode according\n         to the current keyboard layout.\n\n  See ::SDL_Keycode for details.\n\n  \\sa SDL_GetKeyName()"]
    pub fn SDL_GetKeyFromScancode(scancode: SDL_Scancode) -> SDL_Keycode;
}
extern "C" {
    #[doc = "  \\brief Get the scancode corresponding to the given key code according to the\n         current keyboard layout.\n\n  See ::SDL_Scancode for details.\n\n  \\sa SDL_GetScancodeName()"]
    pub fn SDL_GetScancodeFromKey(key: SDL_Keycode) -> SDL_Scancode;
}
extern "C" {
    #[doc = "  \\brief Get a human-readable name for a scancode.\n\n  \\return A pointer to the name for the scancode.\n          If the scancode doesn't have a name, this function returns\n          an empty string (\"\").\n\n  \\sa SDL_Scancode"]
    pub fn SDL_GetScancodeName(scancode: SDL_Scancode) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a scancode from a human-readable name\n\n  \\return scancode, or SDL_SCANCODE_UNKNOWN if the name wasn't recognized\n\n  \\sa SDL_Scancode"]
    pub fn SDL_GetScancodeFromName(name: *const libc::c_char) -> SDL_Scancode;
}
extern "C" {
    #[doc = "  \\brief Get a human-readable name for a key.\n\n  \\return A pointer to a UTF-8 string that stays valid at least until the next\n          call to this function. If you need it around any longer, you must\n          copy it.  If the key doesn't have a name, this function returns an\n          empty string (\"\").\n\n  \\sa SDL_Keycode"]
    pub fn SDL_GetKeyName(key: SDL_Keycode) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a key code from a human-readable name\n\n  \\return key code, or SDLK_UNKNOWN if the name wasn't recognized\n\n  \\sa SDL_Keycode"]
    pub fn SDL_GetKeyFromName(name: *const libc::c_char) -> SDL_Keycode;
}
extern "C" {
    #[doc = "  \\brief Start accepting Unicode text input events.\n         This function will show the on-screen keyboard if supported.\n\n  \\sa SDL_StopTextInput()\n  \\sa SDL_SetTextInputRect()\n  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_StartTextInput();
}
extern "C" {
    #[doc = "  \\brief Return whether or not Unicode text input events are enabled.\n\n  \\sa SDL_StartTextInput()\n  \\sa SDL_StopTextInput()"]
    pub fn SDL_IsTextInputActive() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Stop receiving any text input events.\n         This function will hide the on-screen keyboard if supported.\n\n  \\sa SDL_StartTextInput()\n  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_StopTextInput();
}
extern "C" {
    #[doc = "  \\brief Set the rectangle used to type Unicode text inputs.\n         This is used as a hint for IME and on-screen keyboard placement.\n\n  \\sa SDL_StartTextInput()"]
    pub fn SDL_SetTextInputRect(rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Returns whether the platform has some screen keyboard support.\n\n  \\return SDL_TRUE if some keyboard support is available else SDL_FALSE.\n\n  \\note Not all screen keyboard functions are supported on all platforms.\n\n  \\sa SDL_IsScreenKeyboardShown()"]
    pub fn SDL_HasScreenKeyboardSupport() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Returns whether the screen keyboard is shown for given window.\n\n  \\param window The window for which screen keyboard should be queried.\n\n  \\return SDL_TRUE if screen keyboard is shown else SDL_FALSE.\n\n  \\sa SDL_HasScreenKeyboardSupport()"]
    pub fn SDL_IsScreenKeyboardShown(window: *mut SDL_Window) -> SDL_bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Cursor {
    _unused: [u8; 0],
}
#[doc = "< Arrow"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_ARROW: SDL_SystemCursor = 0;
#[doc = "< I-beam"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_IBEAM: SDL_SystemCursor = 1;
#[doc = "< Wait"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAIT: SDL_SystemCursor = 2;
#[doc = "< Crosshair"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_CROSSHAIR: SDL_SystemCursor = 3;
#[doc = "< Small wait cursor (or Wait if not available)"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_WAITARROW: SDL_SystemCursor = 4;
#[doc = "< Double arrow pointing northwest and southeast"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENWSE: SDL_SystemCursor = 5;
#[doc = "< Double arrow pointing northeast and southwest"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENESW: SDL_SystemCursor = 6;
#[doc = "< Double arrow pointing west and east"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEWE: SDL_SystemCursor = 7;
#[doc = "< Double arrow pointing north and south"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZENS: SDL_SystemCursor = 8;
#[doc = "< Four pointed arrow pointing north, south, east, and west"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_SIZEALL: SDL_SystemCursor = 9;
#[doc = "< Slashed circle or crossbones"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_NO: SDL_SystemCursor = 10;
#[doc = "< Hand"]
pub const SDL_SystemCursor_SDL_SYSTEM_CURSOR_HAND: SDL_SystemCursor = 11;
pub const SDL_SystemCursor_SDL_NUM_SYSTEM_CURSORS: SDL_SystemCursor = 12;
#[doc = " \\brief Cursor types for SDL_CreateSystemCursor()."]
pub type SDL_SystemCursor = libc::c_int;
#[doc = "< The scroll direction is normal"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_NORMAL: SDL_MouseWheelDirection = 0;
#[doc = "< The scroll direction is flipped / natural"]
pub const SDL_MouseWheelDirection_SDL_MOUSEWHEEL_FLIPPED: SDL_MouseWheelDirection = 1;
#[doc = " \\brief Scroll direction types for the Scroll event"]
pub type SDL_MouseWheelDirection = libc::c_int;
extern "C" {
    #[doc = "  \\brief Get the window which currently has mouse focus."]
    pub fn SDL_GetMouseFocus() -> *mut SDL_Window;
}
extern "C" {
    #[doc = "  \\brief Retrieve the current state of the mouse.\n\n  The current button state is returned as a button bitmask, which can\n  be tested using the SDL_BUTTON(X) macros, and x and y are set to the\n  mouse cursor position relative to the focus window for the currently\n  selected mouse.  You can pass NULL for either x or y."]
    pub fn SDL_GetMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Get the current state of the mouse, in relation to the desktop\n\n  This works just like SDL_GetMouseState(), but the coordinates will be\n  reported relative to the top-left of the desktop. This can be useful if\n  you need to track the mouse outside of a specific window and\n  SDL_CaptureMouse() doesn't fit your needs. For example, it could be\n  useful if you need to track the mouse while dragging a window, where\n  coordinates relative to a window might not be in sync at all times.\n\n  \\note SDL_GetMouseState() returns the mouse position as SDL understands\n        it from the last pump of the event queue. This function, however,\n        queries the OS for the current mouse position, and as such, might\n        be a slightly less efficient function. Unless you know what you're\n        doing and have a good reason to use this function, you probably want\n        SDL_GetMouseState() instead.\n\n  \\param x Returns the current X coord, relative to the desktop. Can be NULL.\n  \\param y Returns the current Y coord, relative to the desktop. Can be NULL.\n  \\return The current button state as a bitmask, which can be tested using the SDL_BUTTON(X) macros.\n\n  \\sa SDL_GetMouseState"]
    pub fn SDL_GetGlobalMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Retrieve the relative state of the mouse.\n\n  The current button state is returned as a button bitmask, which can\n  be tested using the SDL_BUTTON(X) macros, and x and y are set to the\n  mouse deltas since the last call to SDL_GetRelativeMouseState()."]
    pub fn SDL_GetRelativeMouseState(x: *mut libc::c_int, y: *mut libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = "  \\brief Moves the mouse to the given position within the window.\n\n  \\param window The window to move the mouse into, or NULL for the current mouse focus\n  \\param x The x coordinate within the window\n  \\param y The y coordinate within the window\n\n  \\note This function generates a mouse motion event"]
    pub fn SDL_WarpMouseInWindow(window: *mut SDL_Window, x: libc::c_int, y: libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Moves the mouse to the given position in global screen space.\n\n  \\param x The x coordinate\n  \\param y The y coordinate\n  \\return 0 on success, -1 on error (usually: unsupported by a platform).\n\n  \\note This function generates a mouse motion event"]
    pub fn SDL_WarpMouseGlobal(x: libc::c_int, y: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set relative mouse mode.\n\n  \\param enabled Whether or not to enable relative mode\n\n  \\return 0 on success, or -1 if relative mode is not supported.\n\n  While the mouse is in relative mode, the cursor is hidden, and the\n  driver will try to report continuous motion in the current window.\n  Only relative motion events will be delivered, the mouse position\n  will not change.\n\n  \\note This function will flush any pending mouse motion.\n\n  \\sa SDL_GetRelativeMouseMode()"]
    pub fn SDL_SetRelativeMouseMode(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Capture the mouse, to track input outside an SDL window.\n\n  \\param enabled Whether or not to enable capturing\n\n  Capturing enables your app to obtain mouse events globally, instead of\n  just within your window. Not all video targets support this function.\n  When capturing is enabled, the current window will get all mouse events,\n  but unlike relative mode, no change is made to the cursor and it is\n  not restrained to your window.\n\n  This function may also deny mouse input to other windows--both those in\n  your application and others on the system--so you should use this\n  function sparingly, and in small bursts. For example, you might want to\n  track the mouse while the user is dragging something, until the user\n  releases a mouse button. It is not recommended that you capture the mouse\n  for long periods of time, such as the entire time your app is running.\n\n  While captured, mouse events still report coordinates relative to the\n  current (foreground) window, but those coordinates may be outside the\n  bounds of the window (including negative values). Capturing is only\n  allowed for the foreground window. If the window loses focus while\n  capturing, the capture will be disabled automatically.\n\n  While capturing is enabled, the current window will have the\n  SDL_WINDOW_MOUSE_CAPTURE flag set.\n\n  \\return 0 on success, or -1 if not supported."]
    pub fn SDL_CaptureMouse(enabled: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Query whether relative mouse mode is enabled.\n\n  \\sa SDL_SetRelativeMouseMode()"]
    pub fn SDL_GetRelativeMouseMode() -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Create a cursor, using the specified bitmap data and\n         mask (in MSB format).\n\n  The cursor width must be a multiple of 8 bits.\n\n  The cursor is created in black and white according to the following:\n  <table>\n  <tr><td> data </td><td> mask </td><td> resulting pixel on screen </td></tr>\n  <tr><td>  0   </td><td>  1   </td><td> White </td></tr>\n  <tr><td>  1   </td><td>  1   </td><td> Black </td></tr>\n  <tr><td>  0   </td><td>  0   </td><td> Transparent </td></tr>\n  <tr><td>  1   </td><td>  0   </td><td> Inverted color if possible, black\n                                         if not. </td></tr>\n  </table>\n\n  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateCursor(
        data: *const Uint8,
        mask: *const Uint8,
        w: libc::c_int,
        h: libc::c_int,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Create a color cursor.\n\n  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateColorCursor(
        surface: *mut SDL_Surface,
        hot_x: libc::c_int,
        hot_y: libc::c_int,
    ) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Create a system cursor.\n\n  \\sa SDL_FreeCursor()"]
    pub fn SDL_CreateSystemCursor(id: SDL_SystemCursor) -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Set the active cursor."]
    pub fn SDL_SetCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = "  \\brief Return the active cursor."]
    pub fn SDL_GetCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Return the default cursor."]
    pub fn SDL_GetDefaultCursor() -> *mut SDL_Cursor;
}
extern "C" {
    #[doc = "  \\brief Frees a cursor created with SDL_CreateCursor() or similar functions.\n\n  \\sa SDL_CreateCursor()\n  \\sa SDL_CreateColorCursor()\n  \\sa SDL_CreateSystemCursor()"]
    pub fn SDL_FreeCursor(cursor: *mut SDL_Cursor);
}
extern "C" {
    #[doc = "  \\brief Toggle whether or not the cursor is shown.\n\n  \\param toggle 1 to show the cursor, 0 to hide it, -1 to query the current\n                state.\n\n  \\return 1 if the cursor is shown, or 0 if the cursor is hidden."]
    pub fn SDL_ShowCursor(toggle: libc::c_int) -> libc::c_int;
}
#[doc = " The joystick structure used to identify an SDL joystick"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Joystick {
    _unused: [u8; 0],
}
pub type SDL_Joystick = _SDL_Joystick;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoystickGUID {
    pub data: [Uint8; 16usize],
}
#[test]
fn bindgen_test_layout_SDL_JoystickGUID() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoystickGUID> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoystickGUID>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoystickGUID>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_JoystickGUID))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoystickGUID),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " This is a unique ID for a joystick for the time it is connected to the system,\n and is never reused for the lifetime of the application. If the joystick is\n disconnected and reconnected, it will get a new ID.\n\n The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_JoystickID = Sint32;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_UNKNOWN: SDL_JoystickType = 0;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GAMECONTROLLER: SDL_JoystickType = 1;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_WHEEL: SDL_JoystickType = 2;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_STICK: SDL_JoystickType = 3;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_FLIGHT_STICK: SDL_JoystickType = 4;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DANCE_PAD: SDL_JoystickType = 5;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_GUITAR: SDL_JoystickType = 6;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_DRUM_KIT: SDL_JoystickType = 7;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_ARCADE_PAD: SDL_JoystickType = 8;
pub const SDL_JoystickType_SDL_JOYSTICK_TYPE_THROTTLE: SDL_JoystickType = 9;
pub type SDL_JoystickType = libc::c_int;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_UNKNOWN: SDL_JoystickPowerLevel = -1;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_EMPTY: SDL_JoystickPowerLevel = 0;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_LOW: SDL_JoystickPowerLevel = 1;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MEDIUM: SDL_JoystickPowerLevel = 2;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_FULL: SDL_JoystickPowerLevel = 3;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_WIRED: SDL_JoystickPowerLevel = 4;
pub const SDL_JoystickPowerLevel_SDL_JOYSTICK_POWER_MAX: SDL_JoystickPowerLevel = 5;
pub type SDL_JoystickPowerLevel = libc::c_int;
extern "C" {
    #[doc = " Locking for multi-threaded access to the joystick API\n\n If you are using the joystick API or handling events from multiple threads\n you should use these locking functions to protect access to the joysticks.\n\n In particular, you are guaranteed that the joystick list won't change, so\n the API functions that take a joystick index will be valid, and joystick\n and game controller events will not be delivered."]
    pub fn SDL_LockJoysticks();
}
extern "C" {
    pub fn SDL_UnlockJoysticks();
}
extern "C" {
    #[doc = "  Count the number of joysticks attached to the system right now"]
    pub fn SDL_NumJoysticks() -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the implementation dependent name of a joystick.\n  This can be called before any joysticks are opened.\n  If no name can be found, this function returns NULL."]
    pub fn SDL_JoystickNameForIndex(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the player index of a joystick, or -1 if it's not available\n  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDevicePlayerIndex(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  Return the GUID for the joystick at this index\n  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDeviceGUID(device_index: libc::c_int) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Get the USB vendor ID of a joystick, if available.\n  This can be called before any joysticks are opened.\n  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceVendor(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of a joystick, if available.\n  This can be called before any joysticks are opened.\n  If the product ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceProduct(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of a joystick, if available.\n  This can be called before any joysticks are opened.\n  If the product version isn't available this function returns 0."]
    pub fn SDL_JoystickGetDeviceProductVersion(device_index: libc::c_int) -> Uint16;
}
extern "C" {
    #[doc = "  Get the type of a joystick, if available.\n  This can be called before any joysticks are opened."]
    pub fn SDL_JoystickGetDeviceType(device_index: libc::c_int) -> SDL_JoystickType;
}
extern "C" {
    #[doc = "  Get the instance ID of a joystick.\n  This can be called before any joysticks are opened.\n  If the index is out of range, this function will return -1."]
    pub fn SDL_JoystickGetDeviceInstanceID(device_index: libc::c_int) -> SDL_JoystickID;
}
extern "C" {
    #[doc = "  Open a joystick for use.\n  The index passed as an argument refers to the N'th joystick on the system.\n  This index is not the value which will identify this joystick in future\n  joystick events.  The joystick's instance id (::SDL_JoystickID) will be used\n  there instead.\n\n  \\return A joystick identifier, or NULL if an error occurred."]
    pub fn SDL_JoystickOpen(device_index: libc::c_int) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = " Return the SDL_Joystick associated with an instance id."]
    pub fn SDL_JoystickFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = "  Return the name for this currently opened joystick.\n  If no name can be found, this function returns NULL."]
    pub fn SDL_JoystickName(joystick: *mut SDL_Joystick) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the player index of an opened joystick, or -1 if it's not available\n\n  For XInput controllers this returns the XInput user index."]
    pub fn SDL_JoystickGetPlayerIndex(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  Return the GUID for this opened joystick"]
    pub fn SDL_JoystickGetGUID(joystick: *mut SDL_Joystick) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Get the USB vendor ID of an opened joystick, if available.\n  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetVendor(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of an opened joystick, if available.\n  If the product ID isn't available this function returns 0."]
    pub fn SDL_JoystickGetProduct(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of an opened joystick, if available.\n  If the product version isn't available this function returns 0."]
    pub fn SDL_JoystickGetProductVersion(joystick: *mut SDL_Joystick) -> Uint16;
}
extern "C" {
    #[doc = "  Get the type of an opened joystick."]
    pub fn SDL_JoystickGetType(joystick: *mut SDL_Joystick) -> SDL_JoystickType;
}
extern "C" {
    #[doc = "  Return a string representation for this guid. pszGUID must point to at least 33 bytes\n  (32 for the string plus a NULL terminator)."]
    pub fn SDL_JoystickGetGUIDString(
        guid: SDL_JoystickGUID,
        pszGUID: *mut libc::c_char,
        cbGUID: libc::c_int,
    );
}
extern "C" {
    #[doc = "  Convert a string into a joystick guid"]
    pub fn SDL_JoystickGetGUIDFromString(pchGUID: *const libc::c_char) -> SDL_JoystickGUID;
}
extern "C" {
    #[doc = "  Returns SDL_TRUE if the joystick has been opened and currently connected, or SDL_FALSE if it has not."]
    pub fn SDL_JoystickGetAttached(joystick: *mut SDL_Joystick) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the instance ID of an opened joystick or -1 if the joystick is invalid."]
    pub fn SDL_JoystickInstanceID(joystick: *mut SDL_Joystick) -> SDL_JoystickID;
}
extern "C" {
    #[doc = "  Get the number of general axis controls on a joystick."]
    pub fn SDL_JoystickNumAxes(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the number of trackballs on a joystick.\n\n  Joystick trackballs have only relative motion events associated\n  with them and their state cannot be polled."]
    pub fn SDL_JoystickNumBalls(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the number of POV hats on a joystick."]
    pub fn SDL_JoystickNumHats(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the number of buttons on a joystick."]
    pub fn SDL_JoystickNumButtons(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  Update the current state of the open joysticks.\n\n  This is called automatically by the event loop if any joystick\n  events are enabled."]
    pub fn SDL_JoystickUpdate();
}
extern "C" {
    #[doc = "  Enable/disable joystick event polling.\n\n  If joystick events are disabled, you must call SDL_JoystickUpdate()\n  yourself and check the state of the joystick when you want joystick\n  information.\n\n  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
    pub fn SDL_JoystickEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the current state of an axis control on a joystick.\n\n  The state is a value ranging from -32768 to 32767.\n\n  The axis indices start at index 0."]
    pub fn SDL_JoystickGetAxis(joystick: *mut SDL_Joystick, axis: libc::c_int) -> Sint16;
}
extern "C" {
    #[doc = "  Get the initial state of an axis control on a joystick.\n\n  The state is a value ranging from -32768 to 32767.\n\n  The axis indices start at index 0.\n\n  \\return SDL_TRUE if this axis has any initial value, or SDL_FALSE if not."]
    pub fn SDL_JoystickGetAxisInitialState(
        joystick: *mut SDL_Joystick,
        axis: libc::c_int,
        state: *mut Sint16,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the current state of a POV hat on a joystick.\n\n  The hat indices start at index 0.\n\n  \\return The return value is one of the following positions:\n           - ::SDL_HAT_CENTERED\n           - ::SDL_HAT_UP\n           - ::SDL_HAT_RIGHT\n           - ::SDL_HAT_DOWN\n           - ::SDL_HAT_LEFT\n           - ::SDL_HAT_RIGHTUP\n           - ::SDL_HAT_RIGHTDOWN\n           - ::SDL_HAT_LEFTUP\n           - ::SDL_HAT_LEFTDOWN"]
    pub fn SDL_JoystickGetHat(joystick: *mut SDL_Joystick, hat: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = "  Get the ball axis change since the last poll.\n\n  \\return 0, or -1 if you passed it invalid parameters.\n\n  The ball indices start at index 0."]
    pub fn SDL_JoystickGetBall(
        joystick: *mut SDL_Joystick,
        ball: libc::c_int,
        dx: *mut libc::c_int,
        dy: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the current state of a button on a joystick.\n\n  The button indices start at index 0."]
    pub fn SDL_JoystickGetButton(joystick: *mut SDL_Joystick, button: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = "  Trigger a rumble effect\n  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.\n\n  \\param joystick The joystick to vibrate\n  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF\n  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF\n  \\param duration_ms The duration of the rumble effect, in milliseconds\n\n  \\return 0, or -1 if rumble isn't supported on this joystick"]
    pub fn SDL_JoystickRumble(
        joystick: *mut SDL_Joystick,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Close a joystick previously opened with SDL_JoystickOpen()."]
    pub fn SDL_JoystickClose(joystick: *mut SDL_Joystick);
}
extern "C" {
    #[doc = "  Return the battery level of this joystick"]
    pub fn SDL_JoystickCurrentPowerLevel(joystick: *mut SDL_Joystick) -> SDL_JoystickPowerLevel;
}
#[doc = " The gamecontroller structure used to identify an SDL game controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_GameController {
    _unused: [u8; 0],
}
pub type SDL_GameController = _SDL_GameController;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_NONE: SDL_GameControllerBindType = 0;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_BUTTON: SDL_GameControllerBindType = 1;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_AXIS: SDL_GameControllerBindType = 2;
pub const SDL_GameControllerBindType_SDL_CONTROLLER_BINDTYPE_HAT: SDL_GameControllerBindType = 3;
pub type SDL_GameControllerBindType = libc::c_int;
#[doc = "  Get the SDL joystick layer binding for this controller button/axis mapping"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_GameControllerButtonBind {
    pub bindType: SDL_GameControllerBindType,
    pub value: SDL_GameControllerButtonBind__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_GameControllerButtonBind__bindgen_ty_1 {
    pub button: libc::c_int,
    pub axis: libc::c_int,
    pub hat: SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1 {
    pub hat: libc::c_int,
    pub hat_mask: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<
        SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1,
    > = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hat_mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(hat_mask)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GameControllerButtonBind__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind__bindgen_ty_1),
            "::",
            stringify!(hat)
        )
    );
}
#[test]
fn bindgen_test_layout_SDL_GameControllerButtonBind() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_GameControllerButtonBind> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_GameControllerButtonBind>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_GameControllerButtonBind>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_GameControllerButtonBind))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bindType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(bindType)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_GameControllerButtonBind),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    #[doc = "  Load a set of mappings from a seekable SDL data stream (memory or file), filtered by the current SDL_GetPlatform()\n  A community sourced database of controllers is available at https://raw.github.com/gabomdq/SDL_GameControllerDB/master/gamecontrollerdb.txt\n\n  If \\c freerw is non-zero, the stream will be closed after being read.\n\n \\return number of mappings added, -1 on error"]
    pub fn SDL_GameControllerAddMappingsFromRW(
        rw: *mut SDL_RWops,
        freerw: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Add or update an existing mapping configuration\n\n \\return 1 if mapping is added, 0 if updated, -1 on error"]
    pub fn SDL_GameControllerAddMapping(mappingString: *const libc::c_char) -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the number of mappings installed\n\n  \\return the number of mappings"]
    pub fn SDL_GameControllerNumMappings() -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the mapping at a particular index.\n\n  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if the index is out of range."]
    pub fn SDL_GameControllerMappingForIndex(mapping_index: libc::c_int) -> *mut libc::c_char;
}
extern "C" {
    #[doc = "  Get a mapping string for a GUID\n\n  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMappingForGUID(guid: SDL_JoystickGUID) -> *mut libc::c_char;
}
extern "C" {
    #[doc = "  Get a mapping string for an open GameController\n\n  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMapping(gamecontroller: *mut SDL_GameController) -> *mut libc::c_char;
}
extern "C" {
    #[doc = "  Is the joystick on this index supported by the game controller interface?"]
    pub fn SDL_IsGameController(joystick_index: libc::c_int) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the implementation dependent name of a game controller.\n  This can be called before any controllers are opened.\n  If no name can be found, this function returns NULL."]
    pub fn SDL_GameControllerNameForIndex(joystick_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the mapping of a game controller.\n  This can be called before any controllers are opened.\n\n  \\return the mapping string.  Must be freed with SDL_free().  Returns NULL if no mapping is available"]
    pub fn SDL_GameControllerMappingForDeviceIndex(
        joystick_index: libc::c_int,
    ) -> *mut libc::c_char;
}
extern "C" {
    #[doc = "  Open a game controller for use.\n  The index passed as an argument refers to the N'th game controller on the system.\n  This index is not the value which will identify this controller in future\n  controller events.  The joystick's instance id (::SDL_JoystickID) will be\n  used there instead.\n\n  \\return A controller identifier, or NULL if an error occurred."]
    pub fn SDL_GameControllerOpen(joystick_index: libc::c_int) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = " Return the SDL_GameController associated with an instance id."]
    pub fn SDL_GameControllerFromInstanceID(joyid: SDL_JoystickID) -> *mut SDL_GameController;
}
extern "C" {
    #[doc = "  Return the name for this currently opened controller"]
    pub fn SDL_GameControllerName(gamecontroller: *mut SDL_GameController) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the player index of an opened game controller, or -1 if it's not available\n\n  For XInput controllers this returns the XInput user index."]
    pub fn SDL_GameControllerGetPlayerIndex(gamecontroller: *mut SDL_GameController)
        -> libc::c_int;
}
extern "C" {
    #[doc = "  Get the USB vendor ID of an opened controller, if available.\n  If the vendor ID isn't available this function returns 0."]
    pub fn SDL_GameControllerGetVendor(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Get the USB product ID of an opened controller, if available.\n  If the product ID isn't available this function returns 0."]
    pub fn SDL_GameControllerGetProduct(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Get the product version of an opened controller, if available.\n  If the product version isn't available this function returns 0."]
    pub fn SDL_GameControllerGetProductVersion(gamecontroller: *mut SDL_GameController) -> Uint16;
}
extern "C" {
    #[doc = "  Returns SDL_TRUE if the controller has been opened and currently connected,\n  or SDL_FALSE if it has not."]
    pub fn SDL_GameControllerGetAttached(gamecontroller: *mut SDL_GameController) -> SDL_bool;
}
extern "C" {
    #[doc = "  Get the underlying joystick object used by a controller"]
    pub fn SDL_GameControllerGetJoystick(
        gamecontroller: *mut SDL_GameController,
    ) -> *mut SDL_Joystick;
}
extern "C" {
    #[doc = "  Enable/disable controller event polling.\n\n  If controller events are disabled, you must call SDL_GameControllerUpdate()\n  yourself and check the state of the controller when you want controller\n  information.\n\n  The state can be one of ::SDL_QUERY, ::SDL_ENABLE or ::SDL_IGNORE."]
    pub fn SDL_GameControllerEventState(state: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  Update the current state of the open game controllers.\n\n  This is called automatically by the event loop if any game controller\n  events are enabled."]
    pub fn SDL_GameControllerUpdate();
}
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_INVALID: SDL_GameControllerAxis = -1;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTX: SDL_GameControllerAxis = 0;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_LEFTY: SDL_GameControllerAxis = 1;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTX: SDL_GameControllerAxis = 2;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_RIGHTY: SDL_GameControllerAxis = 3;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERLEFT: SDL_GameControllerAxis = 4;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_TRIGGERRIGHT: SDL_GameControllerAxis = 5;
pub const SDL_GameControllerAxis_SDL_CONTROLLER_AXIS_MAX: SDL_GameControllerAxis = 6;
#[doc = "  The list of axes available from a controller\n\n  Thumbstick axis values range from SDL_JOYSTICK_AXIS_MIN to SDL_JOYSTICK_AXIS_MAX,\n  and are centered within ~8000 of zero, though advanced UI will allow users to set\n  or autodetect the dead zone, which varies between controllers.\n\n  Trigger axis values range from 0 to SDL_JOYSTICK_AXIS_MAX."]
pub type SDL_GameControllerAxis = libc::c_int;
extern "C" {
    #[doc = "  turn this string into a axis mapping"]
    pub fn SDL_GameControllerGetAxisFromString(
        pchString: *const libc::c_char,
    ) -> SDL_GameControllerAxis;
}
extern "C" {
    #[doc = "  turn this axis enum into a string mapping"]
    pub fn SDL_GameControllerGetStringForAxis(axis: SDL_GameControllerAxis) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
    pub fn SDL_GameControllerGetBindForAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = "  Get the current state of an axis control on a game controller.\n\n  The state is a value ranging from -32768 to 32767 (except for the triggers,\n  which range from 0 to 32767).\n\n  The axis indices start at index 0."]
    pub fn SDL_GameControllerGetAxis(
        gamecontroller: *mut SDL_GameController,
        axis: SDL_GameControllerAxis,
    ) -> Sint16;
}
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_INVALID: SDL_GameControllerButton = -1;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_A: SDL_GameControllerButton = 0;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_B: SDL_GameControllerButton = 1;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_X: SDL_GameControllerButton = 2;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_Y: SDL_GameControllerButton = 3;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_BACK: SDL_GameControllerButton = 4;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_GUIDE: SDL_GameControllerButton = 5;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_START: SDL_GameControllerButton = 6;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSTICK: SDL_GameControllerButton = 7;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSTICK: SDL_GameControllerButton = 8;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_LEFTSHOULDER: SDL_GameControllerButton = 9;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_RIGHTSHOULDER: SDL_GameControllerButton =
    10;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_UP: SDL_GameControllerButton = 11;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_DOWN: SDL_GameControllerButton = 12;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_LEFT: SDL_GameControllerButton = 13;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_DPAD_RIGHT: SDL_GameControllerButton = 14;
pub const SDL_GameControllerButton_SDL_CONTROLLER_BUTTON_MAX: SDL_GameControllerButton = 15;
#[doc = "  The list of buttons available from a controller"]
pub type SDL_GameControllerButton = libc::c_int;
extern "C" {
    #[doc = "  turn this string into a button mapping"]
    pub fn SDL_GameControllerGetButtonFromString(
        pchString: *const libc::c_char,
    ) -> SDL_GameControllerButton;
}
extern "C" {
    #[doc = "  turn this button enum into a string mapping"]
    pub fn SDL_GameControllerGetStringForButton(
        button: SDL_GameControllerButton,
    ) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  Get the SDL joystick layer binding for this controller button mapping"]
    pub fn SDL_GameControllerGetBindForButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> SDL_GameControllerButtonBind;
}
extern "C" {
    #[doc = "  Get the current state of a button on a game controller.\n\n  The button indices start at index 0."]
    pub fn SDL_GameControllerGetButton(
        gamecontroller: *mut SDL_GameController,
        button: SDL_GameControllerButton,
    ) -> Uint8;
}
extern "C" {
    #[doc = "  Trigger a rumble effect\n  Each call to this function cancels any previous rumble effect, and calling it with 0 intensity stops any rumbling.\n\n  \\param gamecontroller The controller to vibrate\n  \\param low_frequency_rumble The intensity of the low frequency (left) rumble motor, from 0 to 0xFFFF\n  \\param high_frequency_rumble The intensity of the high frequency (right) rumble motor, from 0 to 0xFFFF\n  \\param duration_ms The duration of the rumble effect, in milliseconds\n\n  \\return 0, or -1 if rumble isn't supported on this joystick"]
    pub fn SDL_GameControllerRumble(
        gamecontroller: *mut SDL_GameController,
        low_frequency_rumble: Uint16,
        high_frequency_rumble: Uint16,
        duration_ms: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Close a controller previously opened with SDL_GameControllerOpen()."]
    pub fn SDL_GameControllerClose(gamecontroller: *mut SDL_GameController);
}
pub type SDL_TouchID = Sint64;
pub type SDL_FingerID = Sint64;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INVALID: SDL_TouchDeviceType = -1;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_DIRECT: SDL_TouchDeviceType = 0;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_ABSOLUTE: SDL_TouchDeviceType = 1;
pub const SDL_TouchDeviceType_SDL_TOUCH_DEVICE_INDIRECT_RELATIVE: SDL_TouchDeviceType = 2;
pub type SDL_TouchDeviceType = libc::c_int;
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Finger {
    pub id: SDL_FingerID,
    pub x: f32,
    pub y: f32,
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_Finger() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Finger> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Finger>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_Finger))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Finger>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Finger))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Finger),
            "::",
            stringify!(pressure)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the number of registered touch devices."]
    pub fn SDL_GetNumTouchDevices() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the touch ID with the given index, or 0 if the index is invalid."]
    pub fn SDL_GetTouchDevice(index: libc::c_int) -> SDL_TouchID;
}
extern "C" {
    #[doc = " \\brief Get the type of the given touch device."]
    pub fn SDL_GetTouchDeviceType(touchID: SDL_TouchID) -> SDL_TouchDeviceType;
}
extern "C" {
    #[doc = "  \\brief Get the number of active fingers for a given touch device."]
    pub fn SDL_GetNumTouchFingers(touchID: SDL_TouchID) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the finger object of the given touch, with the given index."]
    pub fn SDL_GetTouchFinger(touchID: SDL_TouchID, index: libc::c_int) -> *mut SDL_Finger;
}
pub type SDL_GestureID = Sint64;
extern "C" {
    #[doc = "  \\brief Begin Recording a gesture on the specified touch, or all touches (-1)\n\n"]
    pub fn SDL_RecordGesture(touchId: SDL_TouchID) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Save all currently loaded Dollar Gesture templates\n\n"]
    pub fn SDL_SaveAllDollarTemplates(dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Save a currently loaded Dollar Gesture template\n\n"]
    pub fn SDL_SaveDollarTemplate(gestureId: SDL_GestureID, dst: *mut SDL_RWops) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Load Dollar Gesture templates from a file\n\n"]
    pub fn SDL_LoadDollarTemplates(touchId: SDL_TouchID, src: *mut SDL_RWops) -> libc::c_int;
}
#[doc = "< Unused (do not remove)"]
pub const SDL_EventType_SDL_FIRSTEVENT: SDL_EventType = 0;
#[doc = "< User-requested quit"]
pub const SDL_EventType_SDL_QUIT: SDL_EventType = 256;
#[doc = "< The application is being terminated by the OS\nCalled on iOS in applicationWillTerminate()\nCalled on Android in onDestroy()"]
pub const SDL_EventType_SDL_APP_TERMINATING: SDL_EventType = 257;
#[doc = "< The application is low on memory, free memory if possible.\nCalled on iOS in applicationDidReceiveMemoryWarning()\nCalled on Android in onLowMemory()"]
pub const SDL_EventType_SDL_APP_LOWMEMORY: SDL_EventType = 258;
#[doc = "< The application is about to enter the background\nCalled on iOS in applicationWillResignActive()\nCalled on Android in onPause()"]
pub const SDL_EventType_SDL_APP_WILLENTERBACKGROUND: SDL_EventType = 259;
#[doc = "< The application did enter the background and may not get CPU for some time\nCalled on iOS in applicationDidEnterBackground()\nCalled on Android in onPause()"]
pub const SDL_EventType_SDL_APP_DIDENTERBACKGROUND: SDL_EventType = 260;
#[doc = "< The application is about to enter the foreground\nCalled on iOS in applicationWillEnterForeground()\nCalled on Android in onResume()"]
pub const SDL_EventType_SDL_APP_WILLENTERFOREGROUND: SDL_EventType = 261;
#[doc = "< The application is now interactive\nCalled on iOS in applicationDidBecomeActive()\nCalled on Android in onResume()"]
pub const SDL_EventType_SDL_APP_DIDENTERFOREGROUND: SDL_EventType = 262;
#[doc = "< Display state change"]
pub const SDL_EventType_SDL_DISPLAYEVENT: SDL_EventType = 336;
#[doc = "< Window state change"]
pub const SDL_EventType_SDL_WINDOWEVENT: SDL_EventType = 512;
#[doc = "< System specific event"]
pub const SDL_EventType_SDL_SYSWMEVENT: SDL_EventType = 513;
#[doc = "< Key pressed"]
pub const SDL_EventType_SDL_KEYDOWN: SDL_EventType = 768;
#[doc = "< Key released"]
pub const SDL_EventType_SDL_KEYUP: SDL_EventType = 769;
#[doc = "< Keyboard text editing (composition)"]
pub const SDL_EventType_SDL_TEXTEDITING: SDL_EventType = 770;
#[doc = "< Keyboard text input"]
pub const SDL_EventType_SDL_TEXTINPUT: SDL_EventType = 771;
#[doc = "< Keymap changed due to a system event such as an\ninput language or keyboard layout change."]
pub const SDL_EventType_SDL_KEYMAPCHANGED: SDL_EventType = 772;
#[doc = "< Mouse moved"]
pub const SDL_EventType_SDL_MOUSEMOTION: SDL_EventType = 1024;
#[doc = "< Mouse button pressed"]
pub const SDL_EventType_SDL_MOUSEBUTTONDOWN: SDL_EventType = 1025;
#[doc = "< Mouse button released"]
pub const SDL_EventType_SDL_MOUSEBUTTONUP: SDL_EventType = 1026;
#[doc = "< Mouse wheel motion"]
pub const SDL_EventType_SDL_MOUSEWHEEL: SDL_EventType = 1027;
#[doc = "< Joystick axis motion"]
pub const SDL_EventType_SDL_JOYAXISMOTION: SDL_EventType = 1536;
#[doc = "< Joystick trackball motion"]
pub const SDL_EventType_SDL_JOYBALLMOTION: SDL_EventType = 1537;
#[doc = "< Joystick hat position change"]
pub const SDL_EventType_SDL_JOYHATMOTION: SDL_EventType = 1538;
#[doc = "< Joystick button pressed"]
pub const SDL_EventType_SDL_JOYBUTTONDOWN: SDL_EventType = 1539;
#[doc = "< Joystick button released"]
pub const SDL_EventType_SDL_JOYBUTTONUP: SDL_EventType = 1540;
#[doc = "< A new joystick has been inserted into the system"]
pub const SDL_EventType_SDL_JOYDEVICEADDED: SDL_EventType = 1541;
#[doc = "< An opened joystick has been removed"]
pub const SDL_EventType_SDL_JOYDEVICEREMOVED: SDL_EventType = 1542;
#[doc = "< Game controller axis motion"]
pub const SDL_EventType_SDL_CONTROLLERAXISMOTION: SDL_EventType = 1616;
#[doc = "< Game controller button pressed"]
pub const SDL_EventType_SDL_CONTROLLERBUTTONDOWN: SDL_EventType = 1617;
#[doc = "< Game controller button released"]
pub const SDL_EventType_SDL_CONTROLLERBUTTONUP: SDL_EventType = 1618;
#[doc = "< A new Game controller has been inserted into the system"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEADDED: SDL_EventType = 1619;
#[doc = "< An opened Game controller has been removed"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEREMOVED: SDL_EventType = 1620;
#[doc = "< The controller mapping was updated"]
pub const SDL_EventType_SDL_CONTROLLERDEVICEREMAPPED: SDL_EventType = 1621;
pub const SDL_EventType_SDL_FINGERDOWN: SDL_EventType = 1792;
pub const SDL_EventType_SDL_FINGERUP: SDL_EventType = 1793;
pub const SDL_EventType_SDL_FINGERMOTION: SDL_EventType = 1794;
pub const SDL_EventType_SDL_DOLLARGESTURE: SDL_EventType = 2048;
pub const SDL_EventType_SDL_DOLLARRECORD: SDL_EventType = 2049;
pub const SDL_EventType_SDL_MULTIGESTURE: SDL_EventType = 2050;
#[doc = "< The clipboard changed"]
pub const SDL_EventType_SDL_CLIPBOARDUPDATE: SDL_EventType = 2304;
#[doc = "< The system requests a file open"]
pub const SDL_EventType_SDL_DROPFILE: SDL_EventType = 4096;
#[doc = "< text/plain drag-and-drop event"]
pub const SDL_EventType_SDL_DROPTEXT: SDL_EventType = 4097;
#[doc = "< A new set of drops is beginning (NULL filename)"]
pub const SDL_EventType_SDL_DROPBEGIN: SDL_EventType = 4098;
#[doc = "< Current set of drops is now complete (NULL filename)"]
pub const SDL_EventType_SDL_DROPCOMPLETE: SDL_EventType = 4099;
#[doc = "< A new audio device is available"]
pub const SDL_EventType_SDL_AUDIODEVICEADDED: SDL_EventType = 4352;
#[doc = "< An audio device has been removed."]
pub const SDL_EventType_SDL_AUDIODEVICEREMOVED: SDL_EventType = 4353;
#[doc = "< A sensor was updated"]
pub const SDL_EventType_SDL_SENSORUPDATE: SDL_EventType = 4608;
#[doc = "< The render targets have been reset and their contents need to be updated"]
pub const SDL_EventType_SDL_RENDER_TARGETS_RESET: SDL_EventType = 8192;
#[doc = "< The device has been reset and all textures need to be recreated"]
pub const SDL_EventType_SDL_RENDER_DEVICE_RESET: SDL_EventType = 8193;
#[doc = " Events ::SDL_USEREVENT through ::SDL_LASTEVENT are for your use,\n  and should be allocated with SDL_RegisterEvents()"]
pub const SDL_EventType_SDL_USEREVENT: SDL_EventType = 32768;
#[doc = "  This last event is only for bounding internal arrays"]
pub const SDL_EventType_SDL_LASTEVENT: SDL_EventType = 65535;
#[doc = " \\brief The types of events that can be delivered."]
pub type SDL_EventType = libc::c_int;
#[doc = "  \\brief Fields shared by every event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_CommonEvent {
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_CommonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_CommonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_CommonEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_CommonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_CommonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_CommonEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief Display state change event data (event.display.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DisplayEvent {
    #[doc = "< ::SDL_DISPLAYEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated display index"]
    pub display: Uint32,
    #[doc = "< ::SDL_DisplayEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_DisplayEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DisplayEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DisplayEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DisplayEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DisplayEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DisplayEvent),
            "::",
            stringify!(data1)
        )
    );
}
#[doc = "  \\brief Window state change event data (event.window.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_WindowEvent {
    #[doc = "< ::SDL_WINDOWEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_WindowEventID"]
    pub event: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< event dependent data"]
    pub data1: Sint32,
    #[doc = "< event dependent data"]
    pub data2: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_WindowEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).event) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[doc = "  \\brief Keyboard button event structure (event.key.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_KeyboardEvent {
    #[doc = "< ::SDL_KEYDOWN or ::SDL_KEYUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< Non-zero if this is a key repeat"]
    pub repeat: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The key that was pressed or released"]
    pub keysym: SDL_Keysym,
}
#[test]
fn bindgen_test_layout_SDL_KeyboardEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_KeyboardEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_KeyboardEvent>(),
        32usize,
        concat!("Size of: ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_KeyboardEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_KeyboardEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).repeat) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(repeat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keysym) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_KeyboardEvent),
            "::",
            stringify!(keysym)
        )
    );
}
#[doc = "  \\brief Keyboard text editing event structure (event.edit.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextEditingEvent {
    #[doc = "< ::SDL_TEXTEDITING"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The editing text"]
    pub text: [libc::c_char; 32usize],
    #[doc = "< The start cursor of selected editing text"]
    pub start: Sint32,
    #[doc = "< The length of selected editing text"]
    pub length: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_TextEditingEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TextEditingEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TextEditingEvent>(),
        52usize,
        concat!("Size of: ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextEditingEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextEditingEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextEditingEvent),
            "::",
            stringify!(length)
        )
    );
}
#[doc = "  \\brief Keyboard text input event structure (event.text.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TextInputEvent {
    #[doc = "< ::SDL_TEXTINPUT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with keyboard focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The input text"]
    pub text: [libc::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_SDL_TextInputEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TextInputEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TextInputEvent>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TextInputEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TextInputEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TextInputEvent),
            "::",
            stringify!(text)
        )
    );
}
#[doc = "  \\brief Mouse motion event structure (event.motion.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseMotionEvent {
    #[doc = "< ::SDL_MOUSEMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The current button state"]
    pub state: Uint32,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint32,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseMotionEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseMotionEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseMotionEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseMotionEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseMotionEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xrel) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yrel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseMotionEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Mouse button event structure (event.button.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseButtonEvent {
    #[doc = "< ::SDL_MOUSEBUTTONDOWN or ::SDL_MOUSEBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The mouse button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    #[doc = "< 1 for single-click, 2 for double-click, etc."]
    pub clicks: Uint8,
    pub padding1: Uint8,
    #[doc = "< X coordinate, relative to window"]
    pub x: Sint32,
    #[doc = "< Y coordinate, relative to window"]
    pub y: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseButtonEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseButtonEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clicks) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(clicks)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseButtonEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief Mouse wheel event structure (event.wheel.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MouseWheelEvent {
    #[doc = "< ::SDL_MOUSEWHEEL"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The window with mouse focus, if any"]
    pub windowID: Uint32,
    #[doc = "< The mouse instance id, or SDL_TOUCH_MOUSEID"]
    pub which: Uint32,
    #[doc = "< The amount scrolled horizontally, positive to the right and negative to the left"]
    pub x: Sint32,
    #[doc = "< The amount scrolled vertically, positive away from the user and negative toward the user"]
    pub y: Sint32,
    #[doc = "< Set to one of the SDL_MOUSEWHEEL_* defines. When FLIPPED the values in X and Y will be opposite. Multiply by -1 to change them back"]
    pub direction: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_MouseWheelEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MouseWheelEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MouseWheelEvent>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MouseWheelEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MouseWheelEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MouseWheelEvent),
            "::",
            stringify!(direction)
        )
    );
}
#[doc = "  \\brief Joystick axis motion event structure (event.jaxis.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyAxisEvent {
    #[doc = "< ::SDL_JOYAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick axis index"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyAxisEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyAxisEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyAxisEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding4) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Joystick trackball motion event structure (event.jball.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyBallEvent {
    #[doc = "< ::SDL_JOYBALLMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick trackball index"]
    pub ball: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The relative motion in the X direction"]
    pub xrel: Sint16,
    #[doc = "< The relative motion in the Y direction"]
    pub yrel: Sint16,
}
#[test]
fn bindgen_test_layout_SDL_JoyBallEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyBallEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyBallEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyBallEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyBallEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ball) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(ball)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).xrel) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(xrel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).yrel) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyBallEvent),
            "::",
            stringify!(yrel)
        )
    );
}
#[doc = "  \\brief Joystick hat position change event structure (event.jhat.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyHatEvent {
    #[doc = "< ::SDL_JOYHATMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick hat index"]
    pub hat: Uint8,
    #[doc = "< The hat position value.\n   \\sa ::SDL_HAT_LEFTUP ::SDL_HAT_UP ::SDL_HAT_RIGHTUP\n   \\sa ::SDL_HAT_LEFT ::SDL_HAT_CENTERED ::SDL_HAT_RIGHT\n   \\sa ::SDL_HAT_LEFTDOWN ::SDL_HAT_DOWN ::SDL_HAT_RIGHTDOWN\n\n   Note that zero means the POV is centered."]
    pub value: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyHatEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyHatEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyHatEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyHatEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyHatEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hat) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(hat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyHatEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick button event structure (event.jbutton.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyButtonEvent {
    #[doc = "< ::SDL_JOYBUTTONDOWN or ::SDL_JOYBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The joystick button index"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_JoyButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyButtonEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Joystick device event structure (event.jdevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_JoyDeviceEvent {
    #[doc = "< ::SDL_JOYDEVICEADDED or ::SDL_JOYDEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_JoyDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_JoyDeviceEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_JoyDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_JoyDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_JoyDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_JoyDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Game controller axis motion event structure (event.caxis.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerAxisEvent {
    #[doc = "< ::SDL_CONTROLLERAXISMOTION"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller axis (SDL_GameControllerAxis)"]
    pub axis: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
    #[doc = "< The axis value (range: -32768 to 32767)"]
    pub value: Sint16,
    pub padding4: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_ControllerAxisEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_ControllerAxisEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerAxisEvent>(),
        20usize,
        concat!("Size of: ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerAxisEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerAxisEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).axis) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding3)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding4) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerAxisEvent),
            "::",
            stringify!(padding4)
        )
    );
}
#[doc = "  \\brief Game controller button event structure (event.cbutton.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerButtonEvent {
    #[doc = "< ::SDL_CONTROLLERBUTTONDOWN or ::SDL_CONTROLLERBUTTONUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick instance id"]
    pub which: SDL_JoystickID,
    #[doc = "< The controller button (SDL_GameControllerButton)"]
    pub button: Uint8,
    #[doc = "< ::SDL_PRESSED or ::SDL_RELEASED"]
    pub state: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_ControllerButtonEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_ControllerButtonEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerButtonEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerButtonEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerButtonEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerButtonEvent),
            "::",
            stringify!(padding2)
        )
    );
}
#[doc = "  \\brief Controller device event structure (event.cdevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_ControllerDeviceEvent {
    #[doc = "< ::SDL_CONTROLLERDEVICEADDED, ::SDL_CONTROLLERDEVICEREMOVED, or ::SDL_CONTROLLERDEVICEREMAPPED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The joystick device index for the ADDED event, instance id for the REMOVED or REMAPPED event"]
    pub which: Sint32,
}
#[test]
fn bindgen_test_layout_SDL_ControllerDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_ControllerDeviceEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_ControllerDeviceEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_ControllerDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_ControllerDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_ControllerDeviceEvent),
            "::",
            stringify!(which)
        )
    );
}
#[doc = "  \\brief Audio device event structure (event.adevice.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_AudioDeviceEvent {
    #[doc = "< ::SDL_AUDIODEVICEADDED, or ::SDL_AUDIODEVICEREMOVED"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The audio device index for the ADDED event (valid until next SDL_GetNumAudioDevices() call), SDL_AudioDeviceID for the REMOVED event"]
    pub which: Uint32,
    #[doc = "< zero if an output device, non-zero if a capture device."]
    pub iscapture: Uint8,
    pub padding1: Uint8,
    pub padding2: Uint8,
    pub padding3: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_AudioDeviceEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_AudioDeviceEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_AudioDeviceEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_AudioDeviceEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_AudioDeviceEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iscapture) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(iscapture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding1) as usize - ptr as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding2) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding3) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_AudioDeviceEvent),
            "::",
            stringify!(padding3)
        )
    );
}
#[doc = "  \\brief Touch finger event structure (event.tfinger.*)"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SDL_TouchFingerEvent {
    #[doc = "< ::SDL_FINGERMOTION or ::SDL_FINGERDOWN or ::SDL_FINGERUP"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub fingerId: SDL_FingerID,
    #[doc = "< Normalized in the range 0...1"]
    pub x: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub y: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dx: f32,
    #[doc = "< Normalized in the range -1...1"]
    pub dy: f32,
    #[doc = "< Normalized in the range 0...1"]
    pub pressure: f32,
}
#[test]
fn bindgen_test_layout_SDL_TouchFingerEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_TouchFingerEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_TouchFingerEvent>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_TouchFingerEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_TouchFingerEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).touchId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fingerId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(fingerId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dx) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dy) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(dy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_TouchFingerEvent),
            "::",
            stringify!(pressure)
        )
    );
}
#[doc = "  \\brief Multiple Finger Gesture Event (event.mgesture.*)"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MultiGestureEvent {
    #[doc = "< ::SDL_MULTIGESTURE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub dTheta: f32,
    pub dDist: f32,
    pub x: f32,
    pub y: f32,
    pub numFingers: Uint16,
    pub padding: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_MultiGestureEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MultiGestureEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MultiGestureEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MultiGestureEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MultiGestureEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).touchId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dTheta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dTheta)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dDist) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(dDist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numFingers) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MultiGestureEvent),
            "::",
            stringify!(padding)
        )
    );
}
#[doc = " \\brief Dollar Gesture Event (event.dgesture.*)"]
#[repr(C, packed(4))]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DollarGestureEvent {
    #[doc = "< ::SDL_DOLLARGESTURE or ::SDL_DOLLARRECORD"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The touch device id"]
    pub touchId: SDL_TouchID,
    pub gestureId: SDL_GestureID,
    pub numFingers: Uint32,
    pub error: f32,
    #[doc = "< Normalized center of gesture"]
    pub x: f32,
    #[doc = "< Normalized center of gesture"]
    pub y: f32,
}
#[test]
fn bindgen_test_layout_SDL_DollarGestureEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DollarGestureEvent> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DollarGestureEvent>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DollarGestureEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DollarGestureEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).touchId) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(touchId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).gestureId) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(gestureId)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numFingers) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(numFingers)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).error) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DollarGestureEvent),
            "::",
            stringify!(y)
        )
    );
}
#[doc = "  \\brief An event used to request a file open by the system (event.drop.*)\n         This event is enabled by default, you can disable it with SDL_EventState().\n  \\note If this event is enabled, you must free the filename in the event."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_DropEvent {
    #[doc = "< ::SDL_DROPBEGIN or ::SDL_DROPFILE or ::SDL_DROPTEXT or ::SDL_DROPCOMPLETE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The file name, which should be freed with SDL_free(), is NULL on begin/complete"]
    pub file: *mut libc::c_char,
    #[doc = "< The window that was dropped on, if any"]
    pub windowID: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_DropEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_DropEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_DropEvent>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_DropEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_DropEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).file) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_DropEvent),
            "::",
            stringify!(windowID)
        )
    );
}
#[doc = "  \\brief Sensor event structure (event.sensor.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SensorEvent {
    #[doc = "< ::SDL_SENSORUPDATE"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The instance ID of the sensor"]
    pub which: Sint32,
    #[doc = "< Up to 6 values from the sensor - additional values can be queried using SDL_SensorGetData()"]
    pub data: [f32; 6usize],
}
#[test]
fn bindgen_test_layout_SDL_SensorEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SensorEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SensorEvent>(),
        36usize,
        concat!("Size of: ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SensorEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_SensorEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).which) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(which)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SensorEvent),
            "::",
            stringify!(data)
        )
    );
}
#[doc = "  \\brief The \"quit requested\" event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_QuitEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_QuitEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_QuitEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_QuitEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_QuitEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_QuitEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_QuitEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief OS Specific event"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_OSEvent {
    #[doc = "< ::SDL_QUIT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
}
#[test]
fn bindgen_test_layout_SDL_OSEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_OSEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_OSEvent>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_OSEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_OSEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_OSEvent),
            "::",
            stringify!(timestamp)
        )
    );
}
#[doc = "  \\brief A user-defined event type (event.user.*)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_UserEvent {
    #[doc = "< ::SDL_USEREVENT through ::SDL_LASTEVENT-1"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< The associated window if any"]
    pub windowID: Uint32,
    #[doc = "< User defined event code"]
    pub code: Sint32,
    #[doc = "< User defined data pointer"]
    pub data1: *mut libc::c_void,
    #[doc = "< User defined data pointer"]
    pub data2: *mut libc::c_void,
}
#[test]
fn bindgen_test_layout_SDL_UserEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_UserEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_UserEvent>(),
        24usize,
        concat!("Size of: ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_UserEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_UserEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).windowID) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(windowID)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data2) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_UserEvent),
            "::",
            stringify!(data2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMmsg {
    _unused: [u8; 0],
}
#[doc = "  \\brief A video driver dependent system event (event.syswm.*)\n         This event is disabled by default, you can enable it with SDL_EventState()\n\n  \\note If you want to use this event, you should include SDL_syswm.h."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_SysWMEvent {
    #[doc = "< ::SDL_SYSWMEVENT"]
    pub type_: Uint32,
    #[doc = "< In milliseconds, populated using SDL_GetTicks()"]
    pub timestamp: Uint32,
    #[doc = "< driver dependent data, defined in SDL_syswm.h"]
    pub msg: *mut SDL_SysWMmsg,
}
#[test]
fn bindgen_test_layout_SDL_SysWMEvent() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_SysWMEvent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_SysWMEvent>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_SysWMEvent>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_SysWMEvent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).msg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_SysWMEvent),
            "::",
            stringify!(msg)
        )
    );
}
#[doc = "  \\brief General event structure"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_Event {
    #[doc = "< Event type, shared with all events"]
    pub type_: Uint32,
    #[doc = "< Common event data"]
    pub common: SDL_CommonEvent,
    #[doc = "< Window event data"]
    pub display: SDL_DisplayEvent,
    #[doc = "< Window event data"]
    pub window: SDL_WindowEvent,
    #[doc = "< Keyboard event data"]
    pub key: SDL_KeyboardEvent,
    #[doc = "< Text editing event data"]
    pub edit: SDL_TextEditingEvent,
    #[doc = "< Text input event data"]
    pub text: SDL_TextInputEvent,
    #[doc = "< Mouse motion event data"]
    pub motion: SDL_MouseMotionEvent,
    #[doc = "< Mouse button event data"]
    pub button: SDL_MouseButtonEvent,
    #[doc = "< Mouse wheel event data"]
    pub wheel: SDL_MouseWheelEvent,
    #[doc = "< Joystick axis event data"]
    pub jaxis: SDL_JoyAxisEvent,
    #[doc = "< Joystick ball event data"]
    pub jball: SDL_JoyBallEvent,
    #[doc = "< Joystick hat event data"]
    pub jhat: SDL_JoyHatEvent,
    #[doc = "< Joystick button event data"]
    pub jbutton: SDL_JoyButtonEvent,
    #[doc = "< Joystick device change event data"]
    pub jdevice: SDL_JoyDeviceEvent,
    #[doc = "< Game Controller axis event data"]
    pub caxis: SDL_ControllerAxisEvent,
    #[doc = "< Game Controller button event data"]
    pub cbutton: SDL_ControllerButtonEvent,
    #[doc = "< Game Controller device event data"]
    pub cdevice: SDL_ControllerDeviceEvent,
    #[doc = "< Audio device event data"]
    pub adevice: SDL_AudioDeviceEvent,
    #[doc = "< Sensor event data"]
    pub sensor: SDL_SensorEvent,
    #[doc = "< Quit request event data"]
    pub quit: SDL_QuitEvent,
    #[doc = "< Custom event data"]
    pub user: SDL_UserEvent,
    #[doc = "< System dependent window event data"]
    pub syswm: SDL_SysWMEvent,
    #[doc = "< Touch finger event data"]
    pub tfinger: SDL_TouchFingerEvent,
    #[doc = "< Gesture event data"]
    pub mgesture: SDL_MultiGestureEvent,
    #[doc = "< Gesture event data"]
    pub dgesture: SDL_DollarGestureEvent,
    #[doc = "< Drag and drop event data"]
    pub drop: SDL_DropEvent,
    pub padding: [Uint8; 56usize],
}
#[test]
fn bindgen_test_layout_SDL_Event() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_Event> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_Event>(),
        56usize,
        concat!("Size of: ", stringify!(SDL_Event))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_Event>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_Event))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).common) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(common)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).display) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).edit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(edit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).motion) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(motion)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wheel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(wheel)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jaxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jaxis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jball) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jball)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jhat) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jhat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jdevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(jdevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).caxis) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(caxis)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cbutton) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cbutton)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cdevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(cdevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).adevice) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(adevice)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sensor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(sensor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).quit) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).user) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(user)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).syswm) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(syswm)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tfinger) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(tfinger)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mgesture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(mgesture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dgesture) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(dgesture)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_Event),
            "::",
            stringify!(padding)
        )
    );
}
extern "C" {
    #[doc = "  Pumps the event loop, gathering events from the input devices.\n\n  This function updates the event queue and internal input device state.\n\n  This should only be run in the thread that sets the video mode."]
    pub fn SDL_PumpEvents();
}
pub const SDL_eventaction_SDL_ADDEVENT: SDL_eventaction = 0;
pub const SDL_eventaction_SDL_PEEKEVENT: SDL_eventaction = 1;
pub const SDL_eventaction_SDL_GETEVENT: SDL_eventaction = 2;
pub type SDL_eventaction = libc::c_int;
extern "C" {
    #[doc = "  Checks the event queue for messages and optionally returns them.\n\n  If \\c action is ::SDL_ADDEVENT, up to \\c numevents events will be added to\n  the back of the event queue.\n\n  If \\c action is ::SDL_PEEKEVENT, up to \\c numevents events at the front\n  of the event queue, within the specified minimum and maximum type,\n  will be returned and will not be removed from the queue.\n\n  If \\c action is ::SDL_GETEVENT, up to \\c numevents events at the front\n  of the event queue, within the specified minimum and maximum type,\n  will be returned and will be removed from the queue.\n\n  \\return The number of events actually stored, or -1 if there was an error.\n\n  This function is thread-safe."]
    pub fn SDL_PeepEvents(
        events: *mut SDL_Event,
        numevents: libc::c_int,
        action: SDL_eventaction,
        minType: Uint32,
        maxType: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Checks to see if certain event types are in the event queue."]
    pub fn SDL_HasEvent(type_: Uint32) -> SDL_bool;
}
extern "C" {
    pub fn SDL_HasEvents(minType: Uint32, maxType: Uint32) -> SDL_bool;
}
extern "C" {
    #[doc = "  This function clears events from the event queue\n  This function only affects currently queued events. If you want to make\n  sure that all pending OS events are flushed, you can call SDL_PumpEvents()\n  on the main thread immediately before the flush call."]
    pub fn SDL_FlushEvent(type_: Uint32);
}
extern "C" {
    pub fn SDL_FlushEvents(minType: Uint32, maxType: Uint32);
}
extern "C" {
    #[doc = "  \\brief Polls for currently pending events.\n\n  \\return 1 if there are any pending events, or 0 if there are none available.\n\n  \\param event If not NULL, the next event is removed from the queue and\n               stored in that area."]
    pub fn SDL_PollEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Waits indefinitely for the next available event.\n\n  \\return 1, or 0 if there was an error while waiting for events.\n\n  \\param event If not NULL, the next event is removed from the queue and\n               stored in that area."]
    pub fn SDL_WaitEvent(event: *mut SDL_Event) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Waits until the specified timeout (in milliseconds) for the next\n         available event.\n\n  \\return 1, or 0 if there was an error while waiting for events.\n\n  \\param event If not NULL, the next event is removed from the queue and\n               stored in that area.\n  \\param timeout The timeout (in milliseconds) to wait for next event."]
    pub fn SDL_WaitEventTimeout(event: *mut SDL_Event, timeout: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Add an event to the event queue.\n\n  \\return 1 on success, 0 if the event was filtered, or -1 if the event queue\n          was full or there was some other error."]
    pub fn SDL_PushEvent(event: *mut SDL_Event) -> libc::c_int;
}
pub type SDL_EventFilter = ::core::option::Option<
    unsafe extern "C" fn(userdata: *mut libc::c_void, event: *mut SDL_Event) -> libc::c_int,
>;
extern "C" {
    #[doc = "  Sets up a filter to process all events before they change internal state and\n  are posted to the internal event queue.\n\n  The filter is prototyped as:\n  \\code\n      int SDL_EventFilter(void *userdata, SDL_Event * event);\n  \\endcode\n\n  If the filter returns 1, then the event will be added to the internal queue.\n  If it returns 0, then the event will be dropped from the queue, but the\n  internal state will still be updated.  This allows selective filtering of\n  dynamically arriving events.\n\n  \\warning  Be very careful of what you do in the event filter function, as\n            it may run in a different thread!\n\n  There is one caveat when dealing with the ::SDL_QuitEvent event type.  The\n  event filter is only called when the window manager desires to close the\n  application window.  If the event filter returns 1, then the window will\n  be closed, otherwise the window will remain open if possible.\n\n  If the quit event is generated by an interrupt signal, it will bypass the\n  internal queue and be delivered to the application at the next event poll."]
    pub fn SDL_SetEventFilter(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "  Return the current event filter - can be used to \"chain\" filters.\n  If there is no event filter set, this function returns SDL_FALSE."]
    pub fn SDL_GetEventFilter(
        filter: *mut SDL_EventFilter,
        userdata: *mut *mut libc::c_void,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  Add a function which is called when an event is added to the queue."]
    pub fn SDL_AddEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "  Remove an event watch function added with SDL_AddEventWatch()"]
    pub fn SDL_DelEventWatch(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "  Run the filter function on the current event queue, removing any\n  events for which the filter returns 0."]
    pub fn SDL_FilterEvents(filter: SDL_EventFilter, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "  This function allows you to set the state of processing certain events.\n   - If \\c state is set to ::SDL_IGNORE, that event will be automatically\n     dropped from the event queue and will not be filtered.\n   - If \\c state is set to ::SDL_ENABLE, that event will be processed\n     normally.\n   - If \\c state is set to ::SDL_QUERY, SDL_EventState() will return the\n     current processing state of the specified event."]
    pub fn SDL_EventState(type_: Uint32, state: libc::c_int) -> Uint8;
}
extern "C" {
    #[doc = "  This function allocates a set of user-defined events, and returns\n  the beginning event number for that set of events.\n\n  If there aren't enough user-defined events left, this function\n  returns (Uint32)-1"]
    pub fn SDL_RegisterEvents(numevents: libc::c_int) -> Uint32;
}
extern "C" {
    #[doc = " \\brief Get the path where the application resides.\n\n Get the \"base path\". This is the directory where the application was run\n  from, which is probably the installation directory, and may or may not\n  be the process's current working directory.\n\n This returns an absolute path in UTF-8 encoding, and is guaranteed to\n  end with a path separator ('\\\\' on Windows, '/' most other places).\n\n The pointer returned by this function is owned by you. Please call\n  SDL_free() on the pointer when you are done with it, or it will be a\n  memory leak. This is not necessarily a fast call, though, so you should\n  call this once near startup and save the string if you need it.\n\n Some platforms can't determine the application's path, and on other\n  platforms, this might be meaningless. In such cases, this function will\n  return NULL.\n\n  \\return String of base dir in UTF-8 encoding, or NULL on error.\n\n \\sa SDL_GetPrefPath"]
    pub fn SDL_GetBasePath() -> *mut libc::c_char;
}
extern "C" {
    #[doc = " \\brief Get the user-and-app-specific path where files can be written.\n\n Get the \"pref dir\". This is meant to be where users can write personal\n  files (preferences and save games, etc) that are specific to your\n  application. This directory is unique per user, per application.\n\n This function will decide the appropriate location in the native filesystem,\n  create the directory if necessary, and return a string of the absolute\n  path to the directory in UTF-8 encoding.\n\n On Windows, the string might look like:\n  \"C:\\\\Users\\\\bob\\\\AppData\\\\Roaming\\\\My Company\\\\My Program Name\\\\\"\n\n On Linux, the string might look like:\n  \"/home/bob/.local/share/My Program Name/\"\n\n On Mac OS X, the string might look like:\n  \"/Users/bob/Library/Application Support/My Program Name/\"\n\n (etc.)\n\n You specify the name of your organization (if it's not a real organization,\n  your name or an Internet domain you own might do) and the name of your\n  application. These should be untranslated proper names.\n\n Both the org and app strings may become part of a directory name, so\n  please follow these rules:\n\n    - Try to use the same org string (including case-sensitivity) for\n      all your applications that use this function.\n    - Always use a unique app string for each one, and make sure it never\n      changes for an app once you've decided on it.\n    - Unicode characters are legal, as long as it's UTF-8 encoded, but...\n    - ...only use letters, numbers, and spaces. Avoid punctuation like\n      \"Game Name 2: Bad Guy's Revenge!\" ... \"Game Name 2\" is sufficient.\n\n This returns an absolute path in UTF-8 encoding, and is guaranteed to\n  end with a path separator ('\\\\' on Windows, '/' most other places).\n\n The pointer returned by this function is owned by you. Please call\n  SDL_free() on the pointer when you are done with it, or it will be a\n  memory leak. This is not necessarily a fast call, though, so you should\n  call this once near startup and save the string if you need it.\n\n You should assume the path returned by this function is the only safe\n  place to write files (and that SDL_GetBasePath(), while it might be\n  writable, or even the parent of the returned path, aren't where you\n  should be writing things).\n\n Some platforms can't determine the pref path, and on other\n  platforms, this might be meaningless. In such cases, this function will\n  return NULL.\n\n   \\param org The name of your organization.\n   \\param app The name of your application.\n  \\return UTF-8 string of user dir in platform-dependent notation. NULL\n          if there's a problem (creating directory failed, etc).\n\n \\sa SDL_GetBasePath"]
    pub fn SDL_GetPrefPath(org: *const libc::c_char, app: *const libc::c_char)
        -> *mut libc::c_char;
}
#[doc = "  \\typedef SDL_Haptic\n\n  \\brief The haptic structure used to identify an SDL haptic.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticOpenFromJoystick\n  \\sa SDL_HapticClose"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Haptic {
    _unused: [u8; 0],
}
pub type SDL_Haptic = _SDL_Haptic;
#[doc = "  \\brief Structure that represents a haptic direction.\n\n  This is the direction where the force comes from,\n  instead of the direction in which the force is exerted.\n\n  Directions can be specified by:\n   - ::SDL_HAPTIC_POLAR : Specified by polar coordinates.\n   - ::SDL_HAPTIC_CARTESIAN : Specified by cartesian coordinates.\n   - ::SDL_HAPTIC_SPHERICAL : Specified by spherical coordinates.\n\n  Cardinal directions of the haptic device are relative to the positioning\n  of the device.  North is considered to be away from the user.\n\n  The following diagram represents the cardinal directions:\n  \\verbatim\n.--.\n|__| .-------.\n|=.| |.-----.|\n|--| ||     ||\n|  | |'-----'|\n|__|~')_____('\n[ COMPUTER ]\n\n\nNorth (0,-1)\n^\n|\n|\n(-1,0)  West <----[ HAPTIC ]----> East (1,0)\n|\n|\nv\nSouth (0,1)\n\n\n[ USER ]\n\\|||/\n(o o)\n---ooO-(_)-Ooo---\n\\endverbatim\n\n  If type is ::SDL_HAPTIC_POLAR, direction is encoded by hundredths of a\n  degree starting north and turning clockwise.  ::SDL_HAPTIC_POLAR only uses\n  the first \\c dir parameter.  The cardinal directions would be:\n   - North: 0 (0 degrees)\n   - East: 9000 (90 degrees)\n   - South: 18000 (180 degrees)\n   - West: 27000 (270 degrees)\n\n  If type is ::SDL_HAPTIC_CARTESIAN, direction is encoded by three positions\n  (X axis, Y axis and Z axis (with 3 axes)).  ::SDL_HAPTIC_CARTESIAN uses\n  the first three \\c dir parameters.  The cardinal directions would be:\n   - North:  0,-1, 0\n   - East:   1, 0, 0\n   - South:  0, 1, 0\n   - West:  -1, 0, 0\n\n  The Z axis represents the height of the effect if supported, otherwise\n  it's unused.  In cartesian encoding (1, 2) would be the same as (2, 4), you\n  can use any multiple you want, only the direction matters.\n\n  If type is ::SDL_HAPTIC_SPHERICAL, direction is encoded by two rotations.\n  The first two \\c dir parameters are used.  The \\c dir parameters are as\n  follows (all values are in hundredths of degrees):\n   - Degrees from (1, 0) rotated towards (0, 1).\n   - Degrees towards (0, 0, 1) (device needs at least 3 axes).\n\n\n  Example of force coming from the south with all encodings (force coming\n  from the south means the user will have to pull the stick to counteract):\n  \\code\n  SDL_HapticDirection direction;\n\n  // Cartesian directions\n  direction.type = SDL_HAPTIC_CARTESIAN; // Using cartesian direction encoding.\n  direction.dir[0] = 0; // X position\n  direction.dir[1] = 1; // Y position\n  // Assuming the device has 2 axes, we don't need to specify third parameter.\n\n  // Polar directions\n  direction.type = SDL_HAPTIC_POLAR; // We'll be using polar direction encoding.\n  direction.dir[0] = 18000; // Polar only uses first parameter\n\n  // Spherical coordinates\n  direction.type = SDL_HAPTIC_SPHERICAL; // Spherical encoding\n  direction.dir[0] = 9000; // Since we only have two axes we don't need more parameters.\n  \\endcode\n\n  \\sa SDL_HAPTIC_POLAR\n  \\sa SDL_HAPTIC_CARTESIAN\n  \\sa SDL_HAPTIC_SPHERICAL\n  \\sa SDL_HapticEffect\n  \\sa SDL_HapticNumAxes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticDirection {
    #[doc = "< The type of encoding."]
    pub type_: Uint8,
    #[doc = "< The encoded direction."]
    pub dir: [Sint32; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticDirection() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticDirection> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticDirection>(),
        16usize,
        concat!("Size of: ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticDirection>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticDirection))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dir) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticDirection),
            "::",
            stringify!(dir)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Constant effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_CONSTANT effect.\n\n  A constant effect applies a constant force in the specified direction\n  to the joystick.\n\n  \\sa SDL_HAPTIC_CONSTANT\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticConstant {
    #[doc = "< ::SDL_HAPTIC_CONSTANT"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Strength of the constant effect."]
    pub level: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticConstant() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticConstant> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticConstant>(),
        40usize,
        concat!("Size of: ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticConstant>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticConstant))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).level) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticConstant),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Periodic effect.\n\n  The struct handles the following effects:\n   - ::SDL_HAPTIC_SINE\n   - ::SDL_HAPTIC_LEFTRIGHT\n   - ::SDL_HAPTIC_TRIANGLE\n   - ::SDL_HAPTIC_SAWTOOTHUP\n   - ::SDL_HAPTIC_SAWTOOTHDOWN\n\n  A periodic effect consists in a wave-shaped effect that repeats itself\n  over time.  The type determines the shape of the wave and the parameters\n  determine the dimensions of the wave.\n\n  Phase is given by hundredth of a degree meaning that giving the phase a value\n  of 9000 will displace it 25% of its period.  Here are sample values:\n   -     0: No phase displacement.\n   -  9000: Displaced 25% of its period.\n   - 18000: Displaced 50% of its period.\n   - 27000: Displaced 75% of its period.\n   - 36000: Displaced 100% of its period, same as 0, but 0 is preferred.\n\n  Examples:\n  \\verbatim\nSDL_HAPTIC_SINE\n__      __      __      __\n/  \\    /  \\    /  \\    /\n/    \\__/    \\__/    \\__/\n\nSDL_HAPTIC_SQUARE\n__    __    __    __    __\n|  |  |  |  |  |  |  |  |  |\n|  |__|  |__|  |__|  |__|  |\n\nSDL_HAPTIC_TRIANGLE\n/\\    /\\    /\\    /\\    /\\\n/  \\  /  \\  /  \\  /  \\  /\n/    \\/    \\/    \\/    \\/\n\nSDL_HAPTIC_SAWTOOTHUP\n/|  /|  /|  /|  /|  /|  /|\n/ | / | / | / | / | / | / |\n/  |/  |/  |/  |/  |/  |/  |\n\nSDL_HAPTIC_SAWTOOTHDOWN\n\\  |\\  |\\  |\\  |\\  |\\  |\\  |\n\\ | \\ | \\ | \\ | \\ | \\ | \\ |\n\\|  \\|  \\|  \\|  \\|  \\|  \\|\n\\endverbatim\n\n  \\sa SDL_HAPTIC_SINE\n  \\sa SDL_HAPTIC_LEFTRIGHT\n  \\sa SDL_HAPTIC_TRIANGLE\n  \\sa SDL_HAPTIC_SAWTOOTHUP\n  \\sa SDL_HAPTIC_SAWTOOTHDOWN\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticPeriodic {
    #[doc = "< ::SDL_HAPTIC_SINE, ::SDL_HAPTIC_LEFTRIGHT,\n::SDL_HAPTIC_TRIANGLE, ::SDL_HAPTIC_SAWTOOTHUP or\n::SDL_HAPTIC_SAWTOOTHDOWN"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Period of the wave."]
    pub period: Uint16,
    #[doc = "< Peak value; if negative, equivalent to 180 degrees extra phase shift."]
    pub magnitude: Sint16,
    #[doc = "< Mean value of the wave."]
    pub offset: Sint16,
    #[doc = "< Positive phase shift given by hundredth of a degree."]
    pub phase: Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticPeriodic() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticPeriodic> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticPeriodic>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticPeriodic>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticPeriodic))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).magnitude) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(magnitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).phase) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(phase)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticPeriodic),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Condition effect.\n\n  The struct handles the following effects:\n   - ::SDL_HAPTIC_SPRING: Effect based on axes position.\n   - ::SDL_HAPTIC_DAMPER: Effect based on axes velocity.\n   - ::SDL_HAPTIC_INERTIA: Effect based on axes acceleration.\n   - ::SDL_HAPTIC_FRICTION: Effect based on axes movement.\n\n  Direction is handled by condition internals instead of a direction member.\n  The condition effect specific members have three parameters.  The first\n  refers to the X axis, the second refers to the Y axis and the third\n  refers to the Z axis.  The right terms refer to the positive side of the\n  axis and the left terms refer to the negative side of the axis.  Please\n  refer to the ::SDL_HapticDirection diagram for which side is positive and\n  which is negative.\n\n  \\sa SDL_HapticDirection\n  \\sa SDL_HAPTIC_SPRING\n  \\sa SDL_HAPTIC_DAMPER\n  \\sa SDL_HAPTIC_INERTIA\n  \\sa SDL_HAPTIC_FRICTION\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticCondition {
    #[doc = "< ::SDL_HAPTIC_SPRING, ::SDL_HAPTIC_DAMPER,\n::SDL_HAPTIC_INERTIA or ::SDL_HAPTIC_FRICTION"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect - Not used ATM."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Level when joystick is to the positive side; max 0xFFFF."]
    pub right_sat: [Uint16; 3usize],
    #[doc = "< Level when joystick is to the negative side; max 0xFFFF."]
    pub left_sat: [Uint16; 3usize],
    #[doc = "< How fast to increase the force towards the positive side."]
    pub right_coeff: [Sint16; 3usize],
    #[doc = "< How fast to increase the force towards the negative side."]
    pub left_coeff: [Sint16; 3usize],
    #[doc = "< Size of the dead zone; max 0xFFFF: whole axis-range when 0-centered."]
    pub deadband: [Uint16; 3usize],
    #[doc = "< Position of the dead zone."]
    pub center: [Sint16; 3usize],
}
#[test]
fn bindgen_test_layout_SDL_HapticCondition() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticCondition> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCondition>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCondition>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCondition))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right_sat) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_sat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left_sat) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_sat)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).right_coeff) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(right_coeff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).left_coeff) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(left_coeff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).deadband) as usize - ptr as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(deadband)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).center) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCondition),
            "::",
            stringify!(center)
        )
    );
}
#[doc = "  \\brief A structure containing a template for a Ramp effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_RAMP effect.\n\n  The ramp effect starts at start strength and ends at end strength.\n  It augments in linear fashion.  If you use attack and fade with a ramp\n  the effects get added to the ramp effect making the effect become\n  quadratic instead of linear.\n\n  \\sa SDL_HAPTIC_RAMP\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticRamp {
    #[doc = "< ::SDL_HAPTIC_RAMP"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Beginning strength level."]
    pub start: Sint16,
    #[doc = "< Ending strength level."]
    pub end: Sint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticRamp() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticRamp> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticRamp>(),
        44usize,
        concat!("Size of: ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticRamp>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticRamp))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticRamp),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = " \\brief A structure containing a template for a Left/Right effect.\n\n This struct is exclusively for the ::SDL_HAPTIC_LEFTRIGHT effect.\n\n The Left/Right effect is used to explicitly control the large and small\n motors, commonly found in modern game controllers. The small (right) motor\n is high frequency, and the large (left) motor is low frequency.\n\n \\sa SDL_HAPTIC_LEFTRIGHT\n \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticLeftRight {
    #[doc = "< ::SDL_HAPTIC_LEFTRIGHT"]
    pub type_: Uint16,
    #[doc = "< Duration of the effect in milliseconds."]
    pub length: Uint32,
    #[doc = "< Control of the large controller motor."]
    pub large_magnitude: Uint16,
    #[doc = "< Control of the small controller motor."]
    pub small_magnitude: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticLeftRight() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticLeftRight> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticLeftRight>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticLeftRight>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticLeftRight))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).large_magnitude) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(large_magnitude)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).small_magnitude) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticLeftRight),
            "::",
            stringify!(small_magnitude)
        )
    );
}
#[doc = "  \\brief A structure containing a template for the ::SDL_HAPTIC_CUSTOM effect.\n\n  This struct is exclusively for the ::SDL_HAPTIC_CUSTOM effect.\n\n  A custom force feedback effect is much like a periodic effect, where the\n  application can define its exact shape.  You will have to allocate the\n  data yourself.  Data should consist of channels * samples Uint16 samples.\n\n  If channels is one, the effect is rotated using the defined direction.\n  Otherwise it uses the samples in data for the different axes.\n\n  \\sa SDL_HAPTIC_CUSTOM\n  \\sa SDL_HapticEffect"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_HapticCustom {
    #[doc = "< ::SDL_HAPTIC_CUSTOM"]
    pub type_: Uint16,
    #[doc = "< Direction of the effect."]
    pub direction: SDL_HapticDirection,
    #[doc = "< Duration of the effect."]
    pub length: Uint32,
    #[doc = "< Delay before starting the effect."]
    pub delay: Uint16,
    #[doc = "< Button that triggers the effect."]
    pub button: Uint16,
    #[doc = "< How soon it can be triggered again after button."]
    pub interval: Uint16,
    #[doc = "< Axes to use, minimum of one."]
    pub channels: Uint8,
    #[doc = "< Sample periods."]
    pub period: Uint16,
    #[doc = "< Amount of samples."]
    pub samples: Uint16,
    #[doc = "< Should contain channels*samples items."]
    pub data: *mut Uint16,
    #[doc = "< Duration of the attack."]
    pub attack_length: Uint16,
    #[doc = "< Level at the start of the attack."]
    pub attack_level: Uint16,
    #[doc = "< Duration of the fade."]
    pub fade_length: Uint16,
    #[doc = "< Level at the end of the fade."]
    pub fade_level: Uint16,
}
#[test]
fn bindgen_test_layout_SDL_HapticCustom() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticCustom> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticCustom>(),
        48usize,
        concat!("Size of: ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticCustom>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticCustom))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).delay) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).button) as usize - ptr as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(button)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).interval) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).channels) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).samples) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(samples)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_length) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).attack_level) as usize - ptr as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(attack_level)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_length) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fade_level) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticCustom),
            "::",
            stringify!(fade_level)
        )
    );
}
#[doc = "  \\brief The generic template for any haptic effect.\n\n  All values max at 32767 (0x7FFF).  Signed values also can be negative.\n  Time values unless specified otherwise are in milliseconds.\n\n  You can also pass ::SDL_HAPTIC_INFINITY to length instead of a 0-32767\n  value.  Neither delay, interval, attack_length nor fade_length support\n  ::SDL_HAPTIC_INFINITY.  Fade will also not be used since effect never ends.\n\n  Additionally, the ::SDL_HAPTIC_RAMP effect does not support a duration of\n  ::SDL_HAPTIC_INFINITY.\n\n  Button triggers may not be supported on all devices, it is advised to not\n  use them if possible.  Buttons start at index 1 instead of index 0 like\n  the joystick.\n\n  If both attack_length and fade_level are 0, the envelope is not used,\n  otherwise both values are used.\n\n  Common parts:\n  \\code\n  // Replay - All effects have this\n  Uint32 length;        // Duration of effect (ms).\n  Uint16 delay;         // Delay before starting effect.\n\n  // Trigger - All effects have this\n  Uint16 button;        // Button that triggers effect.\n  Uint16 interval;      // How soon before effect can be triggered again.\n\n  // Envelope - All effects except condition effects have this\n  Uint16 attack_length; // Duration of the attack (ms).\n  Uint16 attack_level;  // Level at the start of the attack.\n  Uint16 fade_length;   // Duration of the fade out (ms).\n  Uint16 fade_level;    // Level at the end of the fade.\n  \\endcode\n\n\n  Here we have an example of a constant effect evolution in time:\n  \\verbatim\nStrength\n^\n|\n|    effect level -->  _________________\n|                     /                 \\\n|                    /                   \\\n|                   /                     \\\n|                  /                       \\\n| attack_level --> |                        \\\n|                  |                        |  <---  fade_level\n|\n+--------------------------------------------------> Time\n[--]                 [---]\nattack_length        fade_length\n\n[------------------][-----------------------]\ndelay               length\n\\endverbatim\n\n  Note either the attack_level or the fade_level may be above the actual\n  effect level.\n\n  \\sa SDL_HapticConstant\n  \\sa SDL_HapticPeriodic\n  \\sa SDL_HapticCondition\n  \\sa SDL_HapticRamp\n  \\sa SDL_HapticLeftRight\n  \\sa SDL_HapticCustom"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_HapticEffect {
    #[doc = "< Effect type."]
    pub type_: Uint16,
    #[doc = "< Constant effect."]
    pub constant: SDL_HapticConstant,
    #[doc = "< Periodic effect."]
    pub periodic: SDL_HapticPeriodic,
    #[doc = "< Condition effect."]
    pub condition: SDL_HapticCondition,
    #[doc = "< Ramp effect."]
    pub ramp: SDL_HapticRamp,
    #[doc = "< Left/Right effect."]
    pub leftright: SDL_HapticLeftRight,
    #[doc = "< Custom effect."]
    pub custom: SDL_HapticCustom,
}
#[test]
fn bindgen_test_layout_SDL_HapticEffect() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_HapticEffect> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_HapticEffect>(),
        68usize,
        concat!("Size of: ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_HapticEffect>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_HapticEffect))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).constant) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(constant)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).periodic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(periodic)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).condition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(condition)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ramp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(ramp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).leftright) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(leftright)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).custom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_HapticEffect),
            "::",
            stringify!(custom)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Count the number of haptic devices attached to the system.\n\n  \\return Number of haptic devices detected on the system."]
    pub fn SDL_NumHaptics() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a haptic device.\n\n  This can be called before any joysticks are opened.\n  If no name can be found, this function returns NULL.\n\n  \\param device_index Index of the device to get its name.\n  \\return Name of the device or NULL on error.\n\n  \\sa SDL_NumHaptics"]
    pub fn SDL_HapticName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Opens a haptic device for use.\n\n  The index passed as an argument refers to the N'th haptic device on this\n  system.\n\n  When opening a haptic device, its gain will be set to maximum and\n  autocenter will be disabled.  To modify these values use\n  SDL_HapticSetGain() and SDL_HapticSetAutocenter().\n\n  \\param device_index Index of the device to open.\n  \\return Device identifier or NULL on error.\n\n  \\sa SDL_HapticIndex\n  \\sa SDL_HapticOpenFromMouse\n  \\sa SDL_HapticOpenFromJoystick\n  \\sa SDL_HapticClose\n  \\sa SDL_HapticSetGain\n  \\sa SDL_HapticSetAutocenter\n  \\sa SDL_HapticPause\n  \\sa SDL_HapticStopAll"]
    pub fn SDL_HapticOpen(device_index: libc::c_int) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Checks if the haptic device at index has been opened.\n\n  \\param device_index Index to check to see if it has been opened.\n  \\return 1 if it has been opened or 0 if it hasn't.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticIndex"]
    pub fn SDL_HapticOpened(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets the index of a haptic device.\n\n  \\param haptic Haptic device to get the index of.\n  \\return The index of the haptic device or -1 on error.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticOpened"]
    pub fn SDL_HapticIndex(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets whether or not the current mouse has haptic capabilities.\n\n  \\return SDL_TRUE if the mouse is haptic, SDL_FALSE if it isn't.\n\n  \\sa SDL_HapticOpenFromMouse"]
    pub fn SDL_MouseIsHaptic() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Tries to open a haptic device from the current mouse.\n\n  \\return The haptic device identifier or NULL on error.\n\n  \\sa SDL_MouseIsHaptic\n  \\sa SDL_HapticOpen"]
    pub fn SDL_HapticOpenFromMouse() -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Checks to see if a joystick has haptic features.\n\n  \\param joystick Joystick to test for haptic capabilities.\n  \\return SDL_TRUE if the joystick is haptic, SDL_FALSE if it isn't\n          or -1 if an error occurred.\n\n  \\sa SDL_HapticOpenFromJoystick"]
    pub fn SDL_JoystickIsHaptic(joystick: *mut SDL_Joystick) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Opens a haptic device for use from a joystick device.\n\n  You must still close the haptic device separately.  It will not be closed\n  with the joystick.\n\n  When opening from a joystick you should first close the haptic device before\n  closing the joystick device.  If not, on some implementations the haptic\n  device will also get unallocated and you'll be unable to use force feedback\n  on that device.\n\n  \\param joystick Joystick to create a haptic device from.\n  \\return A valid haptic device identifier on success or NULL on error.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticClose"]
    pub fn SDL_HapticOpenFromJoystick(joystick: *mut SDL_Joystick) -> *mut SDL_Haptic;
}
extern "C" {
    #[doc = "  \\brief Closes a haptic device previously opened with SDL_HapticOpen().\n\n  \\param haptic Haptic device to close."]
    pub fn SDL_HapticClose(haptic: *mut SDL_Haptic);
}
extern "C" {
    #[doc = "  \\brief Returns the number of effects a haptic device can store.\n\n  On some platforms this isn't fully supported, and therefore is an\n  approximation.  Always check to see if your created effect was actually\n  created and do not rely solely on SDL_HapticNumEffects().\n\n  \\param haptic The haptic device to query effect max.\n  \\return The number of effects the haptic device can store or\n          -1 on error.\n\n  \\sa SDL_HapticNumEffectsPlaying\n  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffects(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Returns the number of effects a haptic device can play at the same\n         time.\n\n  This is not supported on all platforms, but will always return a value.\n  Added here for the sake of completeness.\n\n  \\param haptic The haptic device to query maximum playing effects.\n  \\return The number of effects the haptic device can play at the same time\n          or -1 on error.\n\n  \\sa SDL_HapticNumEffects\n  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticNumEffectsPlaying(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Gets the haptic device's supported features in bitwise manner.\n\n  Example:\n  \\code\n  if (SDL_HapticQuery(haptic) & SDL_HAPTIC_CONSTANT) {\n      printf(\"We have constant haptic effect!\\n\");\n  }\n  \\endcode\n\n  \\param haptic The haptic device to query.\n  \\return Haptic features in bitwise manner (OR'd).\n\n  \\sa SDL_HapticNumEffects\n  \\sa SDL_HapticEffectSupported"]
    pub fn SDL_HapticQuery(haptic: *mut SDL_Haptic) -> libc::c_uint;
}
extern "C" {
    #[doc = "  \\brief Gets the number of haptic axes the device has.\n\n  \\sa SDL_HapticDirection"]
    pub fn SDL_HapticNumAxes(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Checks to see if effect is supported by haptic.\n\n  \\param haptic Haptic device to check on.\n  \\param effect Effect to check to see if it is supported.\n  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.\n\n  \\sa SDL_HapticQuery\n  \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticEffectSupported(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Creates a new haptic effect on the device.\n\n  \\param haptic Haptic device to create the effect on.\n  \\param effect Properties of the effect to create.\n  \\return The identifier of the effect on success or -1 on error.\n\n  \\sa SDL_HapticUpdateEffect\n  \\sa SDL_HapticRunEffect\n  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticNewEffect(
        haptic: *mut SDL_Haptic,
        effect: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Updates the properties of an effect.\n\n  Can be used dynamically, although behavior when dynamically changing\n  direction may be strange.  Specifically the effect may reupload itself\n  and start playing from the start.  You cannot change the type either when\n  running SDL_HapticUpdateEffect().\n\n  \\param haptic Haptic device that has the effect.\n  \\param effect Identifier of the effect to update.\n  \\param data New effect properties to use.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticNewEffect\n  \\sa SDL_HapticRunEffect\n  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticUpdateEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        data: *mut SDL_HapticEffect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Runs the haptic effect on its associated haptic device.\n\n  If iterations are ::SDL_HAPTIC_INFINITY, it'll run the effect over and over\n  repeating the envelope (attack and fade) every time.  If you only want the\n  effect to last forever, set ::SDL_HAPTIC_INFINITY in the effect's length\n  parameter.\n\n  \\param haptic Haptic device to run the effect on.\n  \\param effect Identifier of the haptic effect to run.\n  \\param iterations Number of iterations to run the effect. Use\n         ::SDL_HAPTIC_INFINITY for infinity.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticStopEffect\n  \\sa SDL_HapticDestroyEffect\n  \\sa SDL_HapticGetEffectStatus"]
    pub fn SDL_HapticRunEffect(
        haptic: *mut SDL_Haptic,
        effect: libc::c_int,
        iterations: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops the haptic effect on its associated haptic device.\n\n  \\param haptic Haptic device to stop the effect on.\n  \\param effect Identifier of the effect to stop.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticRunEffect\n  \\sa SDL_HapticDestroyEffect"]
    pub fn SDL_HapticStopEffect(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Destroys a haptic effect on the device.\n\n  This will stop the effect if it's running.  Effects are automatically\n  destroyed when the device is closed.\n\n  \\param haptic Device to destroy the effect on.\n  \\param effect Identifier of the effect to destroy.\n\n  \\sa SDL_HapticNewEffect"]
    pub fn SDL_HapticDestroyEffect(haptic: *mut SDL_Haptic, effect: libc::c_int);
}
extern "C" {
    #[doc = "  \\brief Gets the status of the current effect on the haptic device.\n\n  Device must support the ::SDL_HAPTIC_STATUS feature.\n\n  \\param haptic Haptic device to query the effect status on.\n  \\param effect Identifier of the effect to query its status.\n  \\return 0 if it isn't playing, 1 if it is playing or -1 on error.\n\n  \\sa SDL_HapticRunEffect\n  \\sa SDL_HapticStopEffect"]
    pub fn SDL_HapticGetEffectStatus(haptic: *mut SDL_Haptic, effect: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the global gain of the device.\n\n  Device must support the ::SDL_HAPTIC_GAIN feature.\n\n  The user may specify the maximum gain by setting the environment variable\n  SDL_HAPTIC_GAIN_MAX which should be between 0 and 100.  All calls to\n  SDL_HapticSetGain() will scale linearly using SDL_HAPTIC_GAIN_MAX as the\n  maximum.\n\n  \\param haptic Haptic device to set the gain on.\n  \\param gain Value to set the gain to, should be between 0 and 100.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetGain(haptic: *mut SDL_Haptic, gain: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Sets the global autocenter of the device.\n\n  Autocenter should be between 0 and 100.  Setting it to 0 will disable\n  autocentering.\n\n  Device must support the ::SDL_HAPTIC_AUTOCENTER feature.\n\n  \\param haptic Haptic device to set autocentering on.\n  \\param autocenter Value to set autocenter to, 0 disables autocentering.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticQuery"]
    pub fn SDL_HapticSetAutocenter(haptic: *mut SDL_Haptic, autocenter: libc::c_int)
        -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Pauses a haptic device.\n\n  Device must support the ::SDL_HAPTIC_PAUSE feature.  Call\n  SDL_HapticUnpause() to resume playback.\n\n  Do not modify the effects nor add new ones while the device is paused.\n  That can cause all sorts of weird errors.\n\n  \\param haptic Haptic device to pause.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticUnpause"]
    pub fn SDL_HapticPause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Unpauses a haptic device.\n\n  Call to unpause after SDL_HapticPause().\n\n  \\param haptic Haptic device to unpause.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticPause"]
    pub fn SDL_HapticUnpause(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops all the currently playing effects on a haptic device.\n\n  \\param haptic Haptic device to stop.\n  \\return 0 on success or -1 on error."]
    pub fn SDL_HapticStopAll(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Checks to see if rumble is supported on a haptic device.\n\n  \\param haptic Haptic device to check to see if it supports rumble.\n  \\return SDL_TRUE if effect is supported, SDL_FALSE if it isn't or -1 on error.\n\n  \\sa SDL_HapticRumbleInit\n  \\sa SDL_HapticRumblePlay\n  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleSupported(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Initializes the haptic device for simple rumble playback.\n\n  \\param haptic Haptic device to initialize for simple rumble playback.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticOpen\n  \\sa SDL_HapticRumbleSupported\n  \\sa SDL_HapticRumblePlay\n  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumbleInit(haptic: *mut SDL_Haptic) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Runs simple rumble on a haptic device\n\n  \\param haptic Haptic device to play rumble effect on.\n  \\param strength Strength of the rumble to play as a 0-1 float value.\n  \\param length Length of the rumble to play in milliseconds.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticRumbleSupported\n  \\sa SDL_HapticRumbleInit\n  \\sa SDL_HapticRumbleStop"]
    pub fn SDL_HapticRumblePlay(
        haptic: *mut SDL_Haptic,
        strength: f32,
        length: Uint32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Stops the simple rumble on a haptic device.\n\n  \\param haptic Haptic to stop the rumble on.\n  \\return 0 on success or -1 on error.\n\n  \\sa SDL_HapticRumbleSupported\n  \\sa SDL_HapticRumbleInit\n  \\sa SDL_HapticRumblePlay"]
    pub fn SDL_HapticRumbleStop(haptic: *mut SDL_Haptic) -> libc::c_int;
}
pub const SDL_HintPriority_SDL_HINT_DEFAULT: SDL_HintPriority = 0;
pub const SDL_HintPriority_SDL_HINT_NORMAL: SDL_HintPriority = 1;
pub const SDL_HintPriority_SDL_HINT_OVERRIDE: SDL_HintPriority = 2;
#[doc = "  \\brief  An enumeration of hint priorities"]
pub type SDL_HintPriority = libc::c_int;
extern "C" {
    #[doc = "  \\brief Set a hint with a specific priority\n\n  The priority controls the behavior when setting a hint that already\n  has a value.  Hints will replace existing hints of their priority and\n  lower.  Environment variables are considered to have override priority.\n\n  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
    pub fn SDL_SetHintWithPriority(
        name: *const libc::c_char,
        value: *const libc::c_char,
        priority: SDL_HintPriority,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set a hint with normal priority\n\n  \\return SDL_TRUE if the hint was set, SDL_FALSE otherwise"]
    pub fn SDL_SetHint(name: *const libc::c_char, value: *const libc::c_char) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Get a hint\n\n  \\return The string value of a hint variable."]
    pub fn SDL_GetHint(name: *const libc::c_char) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get a hint\n\n  \\return The boolean value of a hint variable."]
    pub fn SDL_GetHintBoolean(name: *const libc::c_char, default_value: SDL_bool) -> SDL_bool;
}
#[doc = " \\brief type definition of the hint callback function."]
pub type SDL_HintCallback = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        name: *const libc::c_char,
        oldValue: *const libc::c_char,
        newValue: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = "  \\brief Add a function to watch a particular hint\n\n  \\param name The hint to watch\n  \\param callback The function to call when the hint value changes\n  \\param userdata A pointer to pass to the callback function"]
    pub fn SDL_AddHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief Remove a function watching a particular hint\n\n  \\param name The hint being watched\n  \\param callback The function being called when the hint value changes\n  \\param userdata A pointer being passed to the callback function"]
    pub fn SDL_DelHintCallback(
        name: *const libc::c_char,
        callback: SDL_HintCallback,
        userdata: *mut libc::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief  Clear all hints\n\n  This function is called during SDL_Quit() to free stored hints."]
    pub fn SDL_ClearHints();
}
extern "C" {
    #[doc = "  This function dynamically loads a shared object and returns a pointer\n  to the object handle (or NULL if there was an error).\n  The 'sofile' parameter is a system dependent name of the object file."]
    pub fn SDL_LoadObject(sofile: *const libc::c_char) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  Given an object handle, this function looks up the address of the\n  named function in the shared object and returns it.  This address\n  is no longer valid after calling SDL_UnloadObject()."]
    pub fn SDL_LoadFunction(
        handle: *mut libc::c_void,
        name: *const libc::c_char,
    ) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  Unload a shared object from memory."]
    pub fn SDL_UnloadObject(handle: *mut libc::c_void);
}
pub const SDL_LOG_CATEGORY_APPLICATION: _bindgen_ty_16 = 0;
pub const SDL_LOG_CATEGORY_ERROR: _bindgen_ty_16 = 1;
pub const SDL_LOG_CATEGORY_ASSERT: _bindgen_ty_16 = 2;
pub const SDL_LOG_CATEGORY_SYSTEM: _bindgen_ty_16 = 3;
pub const SDL_LOG_CATEGORY_AUDIO: _bindgen_ty_16 = 4;
pub const SDL_LOG_CATEGORY_VIDEO: _bindgen_ty_16 = 5;
pub const SDL_LOG_CATEGORY_RENDER: _bindgen_ty_16 = 6;
pub const SDL_LOG_CATEGORY_INPUT: _bindgen_ty_16 = 7;
pub const SDL_LOG_CATEGORY_TEST: _bindgen_ty_16 = 8;
pub const SDL_LOG_CATEGORY_RESERVED1: _bindgen_ty_16 = 9;
pub const SDL_LOG_CATEGORY_RESERVED2: _bindgen_ty_16 = 10;
pub const SDL_LOG_CATEGORY_RESERVED3: _bindgen_ty_16 = 11;
pub const SDL_LOG_CATEGORY_RESERVED4: _bindgen_ty_16 = 12;
pub const SDL_LOG_CATEGORY_RESERVED5: _bindgen_ty_16 = 13;
pub const SDL_LOG_CATEGORY_RESERVED6: _bindgen_ty_16 = 14;
pub const SDL_LOG_CATEGORY_RESERVED7: _bindgen_ty_16 = 15;
pub const SDL_LOG_CATEGORY_RESERVED8: _bindgen_ty_16 = 16;
pub const SDL_LOG_CATEGORY_RESERVED9: _bindgen_ty_16 = 17;
pub const SDL_LOG_CATEGORY_RESERVED10: _bindgen_ty_16 = 18;
pub const SDL_LOG_CATEGORY_CUSTOM: _bindgen_ty_16 = 19;
#[doc = "  \\brief The predefined log categories\n\n  By default the application category is enabled at the INFO level,\n  the assert category is enabled at the WARN level, test is enabled\n  at the VERBOSE level and all other categories are enabled at the\n  CRITICAL level."]
pub type _bindgen_ty_16 = libc::c_int;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_VERBOSE: SDL_LogPriority = 1;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_DEBUG: SDL_LogPriority = 2;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_INFO: SDL_LogPriority = 3;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_WARN: SDL_LogPriority = 4;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_ERROR: SDL_LogPriority = 5;
pub const SDL_LogPriority_SDL_LOG_PRIORITY_CRITICAL: SDL_LogPriority = 6;
pub const SDL_LogPriority_SDL_NUM_LOG_PRIORITIES: SDL_LogPriority = 7;
#[doc = "  \\brief The predefined log priorities"]
pub type SDL_LogPriority = libc::c_int;
extern "C" {
    #[doc = "  \\brief Set the priority of all log categories"]
    pub fn SDL_LogSetAllPriority(priority: SDL_LogPriority);
}
extern "C" {
    #[doc = "  \\brief Set the priority of a particular log category"]
    pub fn SDL_LogSetPriority(category: libc::c_int, priority: SDL_LogPriority);
}
extern "C" {
    #[doc = "  \\brief Get the priority of a particular log category"]
    pub fn SDL_LogGetPriority(category: libc::c_int) -> SDL_LogPriority;
}
extern "C" {
    #[doc = "  \\brief Reset all priorities to default.\n\n  \\note This is called in SDL_Quit()."]
    pub fn SDL_LogResetPriorities();
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO"]
    pub fn SDL_Log(fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_VERBOSE"]
    pub fn SDL_LogVerbose(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_DEBUG"]
    pub fn SDL_LogDebug(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_INFO"]
    pub fn SDL_LogInfo(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_WARN"]
    pub fn SDL_LogWarn(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_ERROR"]
    pub fn SDL_LogError(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with SDL_LOG_PRIORITY_CRITICAL"]
    pub fn SDL_LogCritical(category: libc::c_int, fmt: *const libc::c_char, ...);
}
extern "C" {
    #[doc = "  \\brief Log a message with the specified category and priority."]
    pub fn SDL_LogMessage(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ...
    );
}
extern "C" {
    #[doc = "  \\brief Log a message with the specified category and priority."]
    pub fn SDL_LogMessageV(
        category: libc::c_int,
        priority: SDL_LogPriority,
        fmt: *const libc::c_char,
        ap: va_list,
    );
}
#[doc = "  \\brief The prototype for the log output function"]
pub type SDL_LogOutputFunction = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        category: libc::c_int,
        priority: SDL_LogPriority,
        message: *const libc::c_char,
    ),
>;
extern "C" {
    #[doc = "  \\brief Get the current log output function."]
    pub fn SDL_LogGetOutputFunction(
        callback: *mut SDL_LogOutputFunction,
        userdata: *mut *mut libc::c_void,
    );
}
extern "C" {
    #[doc = "  \\brief This function allows you to replace the default log output\n         function with one of your own."]
    pub fn SDL_LogSetOutputFunction(callback: SDL_LogOutputFunction, userdata: *mut libc::c_void);
}
#[doc = "< error dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_ERROR: SDL_MessageBoxFlags = 16;
#[doc = "< warning dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_WARNING: SDL_MessageBoxFlags = 32;
#[doc = "< informational dialog"]
pub const SDL_MessageBoxFlags_SDL_MESSAGEBOX_INFORMATION: SDL_MessageBoxFlags = 64;
#[doc = " \\brief SDL_MessageBox flags. If supported will display warning icon, etc."]
pub type SDL_MessageBoxFlags = libc::c_int;
#[doc = "< Marks the default button when return is hit"]
pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT:
    SDL_MessageBoxButtonFlags = 1;
#[doc = "< Marks the default button when escape is hit"]
pub const SDL_MessageBoxButtonFlags_SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT:
    SDL_MessageBoxButtonFlags = 2;
#[doc = " \\brief Flags for SDL_MessageBoxButtonData."]
pub type SDL_MessageBoxButtonFlags = libc::c_int;
#[doc = "  \\brief Individual button data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxButtonData {
    #[doc = "< ::SDL_MessageBoxButtonFlags"]
    pub flags: Uint32,
    #[doc = "< User defined button id (value returned via SDL_ShowMessageBox)"]
    pub buttonid: libc::c_int,
    #[doc = "< The UTF-8 button text"]
    pub text: *const libc::c_char,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxButtonData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxButtonData> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxButtonData>(),
        12usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxButtonData>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxButtonData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buttonid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(buttonid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxButtonData),
            "::",
            stringify!(text)
        )
    );
}
#[doc = " \\brief RGB value used in a message box color scheme"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxColor {
    pub r: Uint8,
    pub g: Uint8,
    pub b: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColor() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxColor> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColor>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColor>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColor))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).g) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColor),
            "::",
            stringify!(b)
        )
    );
}
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BACKGROUND: SDL_MessageBoxColorType = 0;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_TEXT: SDL_MessageBoxColorType = 1;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BORDER: SDL_MessageBoxColorType = 2;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_BACKGROUND: SDL_MessageBoxColorType =
    3;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_BUTTON_SELECTED: SDL_MessageBoxColorType = 4;
pub const SDL_MessageBoxColorType_SDL_MESSAGEBOX_COLOR_MAX: SDL_MessageBoxColorType = 5;
pub type SDL_MessageBoxColorType = libc::c_int;
#[doc = " \\brief A set of colors to use for message box dialogs"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxColorScheme {
    pub colors: [SDL_MessageBoxColor; 5usize],
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxColorScheme() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxColorScheme> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxColorScheme>(),
        15usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxColorScheme>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxColorScheme))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxColorScheme),
            "::",
            stringify!(colors)
        )
    );
}
#[doc = "  \\brief MessageBox structure containing title, text, window, etc."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_MessageBoxData {
    #[doc = "< ::SDL_MessageBoxFlags"]
    pub flags: Uint32,
    #[doc = "< Parent window, can be NULL"]
    pub window: *mut SDL_Window,
    #[doc = "< UTF-8 title"]
    pub title: *const libc::c_char,
    #[doc = "< UTF-8 message text"]
    pub message: *const libc::c_char,
    pub numbuttons: libc::c_int,
    pub buttons: *const SDL_MessageBoxButtonData,
    #[doc = "< ::SDL_MessageBoxColorScheme, can be NULL to use system settings"]
    pub colorScheme: *const SDL_MessageBoxColorScheme,
}
#[test]
fn bindgen_test_layout_SDL_MessageBoxData() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_MessageBoxData> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_MessageBoxData>(),
        28usize,
        concat!("Size of: ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_MessageBoxData>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_MessageBoxData))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).window) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(window)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).title) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).numbuttons) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(numbuttons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buttons) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(buttons)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorScheme) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_MessageBoxData),
            "::",
            stringify!(colorScheme)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Create a modal message box.\n\n  \\param messageboxdata The SDL_MessageBoxData structure with title, text, etc.\n  \\param buttonid The pointer to which user id of hit button should be copied.\n\n  \\return -1 on error, otherwise 0 and buttonid contains user id of button\n          hit or -1 if dialog was closed.\n\n  \\note This function should be called on the thread that created the parent\n        window, or on the main thread if the messagebox has no parent.  It will\n        block execution of that thread until the user clicks a button or\n        closes the messagebox."]
    pub fn SDL_ShowMessageBox(
        messageboxdata: *const SDL_MessageBoxData,
        buttonid: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a simple modal message box\n\n  \\param flags    ::SDL_MessageBoxFlags\n  \\param title    UTF-8 title text\n  \\param message  UTF-8 message text\n  \\param window   The parent window, or NULL for no parent\n\n  \\return 0 on success, -1 on error\n\n  \\sa SDL_ShowMessageBox"]
    pub fn SDL_ShowSimpleMessageBox(
        flags: Uint32,
        title: *const libc::c_char,
        message: *const libc::c_char,
        window: *mut SDL_Window,
    ) -> libc::c_int;
}
#[doc = "< cannot determine power status"]
pub const SDL_PowerState_SDL_POWERSTATE_UNKNOWN: SDL_PowerState = 0;
#[doc = "< Not plugged in, running on the battery"]
pub const SDL_PowerState_SDL_POWERSTATE_ON_BATTERY: SDL_PowerState = 1;
#[doc = "< Plugged in, no battery available"]
pub const SDL_PowerState_SDL_POWERSTATE_NO_BATTERY: SDL_PowerState = 2;
#[doc = "< Plugged in, charging battery"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGING: SDL_PowerState = 3;
#[doc = "< Plugged in, battery charged"]
pub const SDL_PowerState_SDL_POWERSTATE_CHARGED: SDL_PowerState = 4;
#[doc = "  \\brief The basic state for the system's power supply."]
pub type SDL_PowerState = libc::c_int;
extern "C" {
    #[doc = "  \\brief Get the current power supply details.\n\n  \\param secs Seconds of battery life left. You can pass a NULL here if\n              you don't care. Will return -1 if we can't determine a\n              value, or we're not running on a battery.\n\n  \\param pct Percentage of battery life left, between 0 and 100. You can\n             pass a NULL here if you don't care. Will return -1 if we\n             can't determine a value, or we're not running on a battery.\n\n  \\return The state of the battery (if any)."]
    pub fn SDL_GetPowerInfo(secs: *mut libc::c_int, pct: *mut libc::c_int) -> SDL_PowerState;
}
#[doc = "< The renderer is a software fallback"]
pub const SDL_RendererFlags_SDL_RENDERER_SOFTWARE: SDL_RendererFlags = 1;
#[doc = "< The renderer uses hardware\nacceleration"]
pub const SDL_RendererFlags_SDL_RENDERER_ACCELERATED: SDL_RendererFlags = 2;
#[doc = "< Present is synchronized\nwith the refresh rate"]
pub const SDL_RendererFlags_SDL_RENDERER_PRESENTVSYNC: SDL_RendererFlags = 4;
#[doc = "< The renderer supports\nrendering to texture"]
pub const SDL_RendererFlags_SDL_RENDERER_TARGETTEXTURE: SDL_RendererFlags = 8;
#[doc = "  \\brief Flags used when creating a rendering context"]
pub type SDL_RendererFlags = libc::c_int;
#[doc = "  \\brief Information on the capabilities of a render driver or context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_RendererInfo {
    #[doc = "< The name of the renderer"]
    pub name: *const libc::c_char,
    #[doc = "< Supported ::SDL_RendererFlags"]
    pub flags: Uint32,
    #[doc = "< The number of available texture formats"]
    pub num_texture_formats: Uint32,
    #[doc = "< The available texture formats"]
    pub texture_formats: [Uint32; 16usize],
    #[doc = "< The maximum texture width"]
    pub max_texture_width: libc::c_int,
    #[doc = "< The maximum texture height"]
    pub max_texture_height: libc::c_int,
}
#[test]
fn bindgen_test_layout_SDL_RendererInfo() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_RendererInfo> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_RendererInfo>(),
        84usize,
        concat!("Size of: ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_RendererInfo>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_RendererInfo))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).num_texture_formats) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(num_texture_formats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).texture_formats) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(texture_formats)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_texture_width) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_texture_height) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_RendererInfo),
            "::",
            stringify!(max_texture_height)
        )
    );
}
#[doc = "< Changes rarely, not lockable"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STATIC: SDL_TextureAccess = 0;
#[doc = "< Changes frequently, lockable"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_STREAMING: SDL_TextureAccess = 1;
#[doc = "< Texture can be used as a render target"]
pub const SDL_TextureAccess_SDL_TEXTUREACCESS_TARGET: SDL_TextureAccess = 2;
#[doc = "  \\brief The access pattern allowed for a texture."]
pub type SDL_TextureAccess = libc::c_int;
#[doc = "< No modulation"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_NONE: SDL_TextureModulate = 0;
#[doc = "< srcC = srcC * color"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_COLOR: SDL_TextureModulate = 1;
#[doc = "< srcA = srcA * alpha"]
pub const SDL_TextureModulate_SDL_TEXTUREMODULATE_ALPHA: SDL_TextureModulate = 2;
#[doc = "  \\brief The texture channel modulation used in SDL_RenderCopy()."]
pub type SDL_TextureModulate = libc::c_int;
#[doc = "< Do not flip"]
pub const SDL_RendererFlip_SDL_FLIP_NONE: SDL_RendererFlip = 0;
#[doc = "< flip horizontally"]
pub const SDL_RendererFlip_SDL_FLIP_HORIZONTAL: SDL_RendererFlip = 1;
#[doc = "< flip vertically"]
pub const SDL_RendererFlip_SDL_FLIP_VERTICAL: SDL_RendererFlip = 2;
#[doc = "  \\brief Flip constants for SDL_RenderCopyEx"]
pub type SDL_RendererFlip = libc::c_int;
#[doc = "  \\brief A structure representing rendering state"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Renderer {
    _unused: [u8; 0],
}
#[doc = "  \\brief An efficient driver-specific representation of pixel data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_Texture {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "  \\brief Get the number of 2D rendering drivers available for the current\n         display.\n\n  A render driver is a set of code that handles rendering and texture\n  management on a particular display.  Normally there is only one, but\n  some drivers may have several available with different capabilities.\n\n  \\sa SDL_GetRenderDriverInfo()\n  \\sa SDL_CreateRenderer()"]
    pub fn SDL_GetNumRenderDrivers() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get information about a specific 2D rendering driver for the current\n         display.\n\n  \\param index The index of the driver to query information about.\n  \\param info  A pointer to an SDL_RendererInfo struct to be filled with\n               information on the rendering driver.\n\n  \\return 0 on success, -1 if the index was out of range.\n\n  \\sa SDL_CreateRenderer()"]
    pub fn SDL_GetRenderDriverInfo(index: libc::c_int, info: *mut SDL_RendererInfo) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a window and default renderer\n\n  \\param width    The width of the window\n  \\param height   The height of the window\n  \\param window_flags The flags used to create the window\n  \\param window   A pointer filled with the window, or NULL on error\n  \\param renderer A pointer filled with the renderer, or NULL on error\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_CreateWindowAndRenderer(
        width: libc::c_int,
        height: libc::c_int,
        window_flags: Uint32,
        window: *mut *mut SDL_Window,
        renderer: *mut *mut SDL_Renderer,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a 2D rendering context for a window.\n\n  \\param window The window where rendering is displayed.\n  \\param index    The index of the rendering driver to initialize, or -1 to\n                  initialize the first one supporting the requested flags.\n  \\param flags    ::SDL_RendererFlags.\n\n  \\return A valid rendering context or NULL if there was an error.\n\n  \\sa SDL_CreateSoftwareRenderer()\n  \\sa SDL_GetRendererInfo()\n  \\sa SDL_DestroyRenderer()"]
    pub fn SDL_CreateRenderer(
        window: *mut SDL_Window,
        index: libc::c_int,
        flags: Uint32,
    ) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Create a 2D software rendering context for a surface.\n\n  \\param surface The surface where rendering is done.\n\n  \\return A valid rendering context or NULL if there was an error.\n\n  \\sa SDL_CreateRenderer()\n  \\sa SDL_DestroyRenderer()"]
    pub fn SDL_CreateSoftwareRenderer(surface: *mut SDL_Surface) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Get the renderer associated with a window."]
    pub fn SDL_GetRenderer(window: *mut SDL_Window) -> *mut SDL_Renderer;
}
extern "C" {
    #[doc = "  \\brief Get information about a rendering context."]
    pub fn SDL_GetRendererInfo(
        renderer: *mut SDL_Renderer,
        info: *mut SDL_RendererInfo,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the output size in pixels of a rendering context."]
    pub fn SDL_GetRendererOutputSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Create a texture for a rendering context.\n\n  \\param renderer The renderer.\n  \\param format The format of the texture.\n  \\param access One of the enumerated values in ::SDL_TextureAccess.\n  \\param w      The width of the texture in pixels.\n  \\param h      The height of the texture in pixels.\n\n  \\return The created texture is returned, or NULL if no rendering context was\n          active,  the format was unsupported, or the width or height were out\n          of range.\n\n  \\note The contents of the texture are not defined at creation.\n\n  \\sa SDL_QueryTexture()\n  \\sa SDL_UpdateTexture()\n  \\sa SDL_DestroyTexture()"]
    pub fn SDL_CreateTexture(
        renderer: *mut SDL_Renderer,
        format: Uint32,
        access: libc::c_int,
        w: libc::c_int,
        h: libc::c_int,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Create a texture from an existing surface.\n\n  \\param renderer The renderer.\n  \\param surface The surface containing pixel data used to fill the texture.\n\n  \\return The created texture is returned, or NULL on error.\n\n  \\note The surface is not modified or freed by this function.\n\n  \\sa SDL_QueryTexture()\n  \\sa SDL_DestroyTexture()"]
    pub fn SDL_CreateTextureFromSurface(
        renderer: *mut SDL_Renderer,
        surface: *mut SDL_Surface,
    ) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Query the attributes of a texture\n\n  \\param texture A texture to be queried.\n  \\param format  A pointer filled in with the raw format of the texture.  The\n                 actual format may differ, but pixel transfers will use this\n                 format.\n  \\param access  A pointer filled in with the actual access to the texture.\n  \\param w       A pointer filled in with the width of the texture in pixels.\n  \\param h       A pointer filled in with the height of the texture in pixels.\n\n  \\return 0 on success, or -1 if the texture is not valid."]
    pub fn SDL_QueryTexture(
        texture: *mut SDL_Texture,
        format: *mut Uint32,
        access: *mut libc::c_int,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional color value used in render copy operations.\n\n  \\param texture The texture to update.\n  \\param r       The red color value multiplied into copy operations.\n  \\param g       The green color value multiplied into copy operations.\n  \\param b       The blue color value multiplied into copy operations.\n\n  \\return 0 on success, or -1 if the texture is not valid or color modulation\n          is not supported.\n\n  \\sa SDL_GetTextureColorMod()"]
    pub fn SDL_SetTextureColorMod(
        texture: *mut SDL_Texture,
        r: Uint8,
        g: Uint8,
        b: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional color value used in render copy operations.\n\n  \\param texture The texture to query.\n  \\param r         A pointer filled in with the current red color value.\n  \\param g         A pointer filled in with the current green color value.\n  \\param b         A pointer filled in with the current blue color value.\n\n  \\return 0 on success, or -1 if the texture is not valid.\n\n  \\sa SDL_SetTextureColorMod()"]
    pub fn SDL_GetTextureColorMod(
        texture: *mut SDL_Texture,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set an additional alpha value used in render copy operations.\n\n  \\param texture The texture to update.\n  \\param alpha     The alpha value multiplied into copy operations.\n\n  \\return 0 on success, or -1 if the texture is not valid or alpha modulation\n          is not supported.\n\n  \\sa SDL_GetTextureAlphaMod()"]
    pub fn SDL_SetTextureAlphaMod(texture: *mut SDL_Texture, alpha: Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the additional alpha value used in render copy operations.\n\n  \\param texture The texture to query.\n  \\param alpha     A pointer filled in with the current alpha value.\n\n  \\return 0 on success, or -1 if the texture is not valid.\n\n  \\sa SDL_SetTextureAlphaMod()"]
    pub fn SDL_GetTextureAlphaMod(texture: *mut SDL_Texture, alpha: *mut Uint8) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for texture copy operations.\n\n  \\param texture The texture to update.\n  \\param blendMode ::SDL_BlendMode to use for texture blending.\n\n  \\return 0 on success, or -1 if the texture is not valid or the blend mode is\n          not supported.\n\n  \\note If the blend mode is not supported, the closest supported mode is\n        chosen.\n\n  \\sa SDL_GetTextureBlendMode()"]
    pub fn SDL_SetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for texture copy operations.\n\n  \\param texture   The texture to query.\n  \\param blendMode A pointer filled in with the current blend mode.\n\n  \\return 0 on success, or -1 if the texture is not valid.\n\n  \\sa SDL_SetTextureBlendMode()"]
    pub fn SDL_GetTextureBlendMode(
        texture: *mut SDL_Texture,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Update the given texture rectangle with new pixel data.\n\n  \\param texture   The texture to update\n  \\param rect      A pointer to the rectangle of pixels to update, or NULL to\n                   update the entire texture.\n  \\param pixels    The raw pixel data in the format of the texture.\n  \\param pitch     The number of bytes in a row of pixel data, including padding between lines.\n\n  The pixel data must be in the format of the texture. The pixel format can be\n  queried with SDL_QueryTexture.\n\n  \\return 0 on success, or -1 if the texture is not valid.\n\n  \\note This is a fairly slow function."]
    pub fn SDL_UpdateTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *const libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Update a rectangle within a planar YV12 or IYUV texture with new pixel data.\n\n  \\param texture   The texture to update\n  \\param rect      A pointer to the rectangle of pixels to update, or NULL to\n                   update the entire texture.\n  \\param Yplane    The raw pixel data for the Y plane.\n  \\param Ypitch    The number of bytes between rows of pixel data for the Y plane.\n  \\param Uplane    The raw pixel data for the U plane.\n  \\param Upitch    The number of bytes between rows of pixel data for the U plane.\n  \\param Vplane    The raw pixel data for the V plane.\n  \\param Vpitch    The number of bytes between rows of pixel data for the V plane.\n\n  \\return 0 on success, or -1 if the texture is not valid.\n\n  \\note You can use SDL_UpdateTexture() as long as your pixel data is\n        a contiguous block of Y and U/V planes in the proper order, but\n        this function is available if your pixel data is not contiguous."]
    pub fn SDL_UpdateYUVTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        Yplane: *const Uint8,
        Ypitch: libc::c_int,
        Uplane: *const Uint8,
        Upitch: libc::c_int,
        Vplane: *const Uint8,
        Vpitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Lock a portion of the texture for write-only pixel access.\n\n  \\param texture   The texture to lock for access, which was created with\n                   ::SDL_TEXTUREACCESS_STREAMING.\n  \\param rect      A pointer to the rectangle to lock for access. If the rect\n                   is NULL, the entire texture will be locked.\n  \\param pixels    This is filled in with a pointer to the locked pixels,\n                   appropriately offset by the locked area.\n  \\param pitch     This is filled in with the pitch of the locked pixels.\n\n  \\return 0 on success, or -1 if the texture is not valid or was not created with ::SDL_TEXTUREACCESS_STREAMING.\n\n  \\sa SDL_UnlockTexture()"]
    pub fn SDL_LockTexture(
        texture: *mut SDL_Texture,
        rect: *const SDL_Rect,
        pixels: *mut *mut libc::c_void,
        pitch: *mut libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Unlock a texture, uploading the changes to video memory, if needed.\n\n  \\sa SDL_LockTexture()"]
    pub fn SDL_UnlockTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = " \\brief Determines whether a window supports the use of render targets\n\n \\param renderer The renderer that will be checked\n\n \\return SDL_TRUE if supported, SDL_FALSE if not."]
    pub fn SDL_RenderTargetSupported(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Set a texture as the current rendering target.\n\n \\param renderer The renderer.\n \\param texture The targeted texture, which must be created with the SDL_TEXTUREACCESS_TARGET flag, or NULL for the default render target\n\n \\return 0 on success, or -1 on error\n\n  \\sa SDL_GetRenderTarget()"]
    pub fn SDL_SetRenderTarget(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the current render target or NULL for the default render target.\n\n \\return The current render target\n\n  \\sa SDL_SetRenderTarget()"]
    pub fn SDL_GetRenderTarget(renderer: *mut SDL_Renderer) -> *mut SDL_Texture;
}
extern "C" {
    #[doc = "  \\brief Set device independent resolution for rendering\n\n  \\param renderer The renderer for which resolution should be set.\n  \\param w      The width of the logical resolution\n  \\param h      The height of the logical resolution\n\n  This function uses the viewport and scaling functionality to allow a fixed logical\n  resolution for rendering, regardless of the actual output resolution.  If the actual\n  output resolution doesn't have the same aspect ratio the output rendering will be\n  centered within the output display.\n\n  If the output display is a window, mouse events in the window will be filtered\n  and scaled so they seem to arrive within the logical resolution.\n\n  \\note If this function results in scaling or subpixel drawing by the\n        rendering backend, it will be handled using the appropriate\n        quality hints.\n\n  \\sa SDL_RenderGetLogicalSize()\n  \\sa SDL_RenderSetScale()\n  \\sa SDL_RenderSetViewport()"]
    pub fn SDL_RenderSetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: libc::c_int,
        h: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get device independent resolution for rendering\n\n  \\param renderer The renderer from which resolution should be queried.\n  \\param w      A pointer filled with the width of the logical resolution\n  \\param h      A pointer filled with the height of the logical resolution\n\n  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderGetLogicalSize(
        renderer: *mut SDL_Renderer,
        w: *mut libc::c_int,
        h: *mut libc::c_int,
    );
}
extern "C" {
    #[doc = "  \\brief Set whether to force integer scales for resolution-independent rendering\n\n  \\param renderer The renderer for which integer scaling should be set.\n  \\param enable   Enable or disable integer scaling\n\n  This function restricts the logical viewport to integer values - that is, when\n  a resolution is between two multiples of a logical size, the viewport size is\n  rounded down to the lower multiple.\n\n  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetIntegerScale(renderer: *mut SDL_Renderer, enable: SDL_bool) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get whether integer scales are forced for resolution-independent rendering\n\n  \\param renderer The renderer from which integer scaling should be queried.\n\n  \\sa SDL_RenderSetIntegerScale()"]
    pub fn SDL_RenderGetIntegerScale(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set the drawing area for rendering on the current target.\n\n  \\param renderer The renderer for which the drawing area should be set.\n  \\param rect The rectangle representing the drawing area, or NULL to set the viewport to the entire target.\n\n  The x,y of the viewport rect represents the origin for rendering.\n\n  \\return 0 on success, or -1 on error\n\n  \\note If the window associated with the renderer is resized, the viewport is automatically reset.\n\n  \\sa SDL_RenderGetViewport()\n  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetViewport(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the drawing area for the current target.\n\n  \\sa SDL_RenderSetViewport()"]
    pub fn SDL_RenderGetViewport(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Set the clip rectangle for the current target.\n\n  \\param renderer The renderer for which clip rectangle should be set.\n  \\param rect   A pointer to the rectangle to set as the clip rectangle, or\n                NULL to disable clipping.\n\n  \\return 0 on success, or -1 on error\n\n  \\sa SDL_RenderGetClipRect()"]
    pub fn SDL_RenderSetClipRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect)
        -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the clip rectangle for the current target.\n\n  \\param renderer The renderer from which clip rectangle should be queried.\n  \\param rect   A pointer filled in with the current clip rectangle, or\n                an empty rectangle if clipping is disabled.\n\n  \\sa SDL_RenderSetClipRect()"]
    pub fn SDL_RenderGetClipRect(renderer: *mut SDL_Renderer, rect: *mut SDL_Rect);
}
extern "C" {
    #[doc = "  \\brief Get whether clipping is enabled on the given renderer.\n\n  \\param renderer The renderer from which clip state should be queried.\n\n  \\sa SDL_RenderGetClipRect()"]
    pub fn SDL_RenderIsClipEnabled(renderer: *mut SDL_Renderer) -> SDL_bool;
}
extern "C" {
    #[doc = "  \\brief Set the drawing scale for rendering on the current target.\n\n  \\param renderer The renderer for which the drawing scale should be set.\n  \\param scaleX The horizontal scaling factor\n  \\param scaleY The vertical scaling factor\n\n  The drawing coordinates are scaled by the x/y scaling factors\n  before they are used by the renderer.  This allows resolution\n  independent drawing with a single coordinate system.\n\n  \\note If this results in scaling or subpixel drawing by the\n        rendering backend, it will be handled using the appropriate\n        quality hints.  For best results use integer scaling factors.\n\n  \\sa SDL_RenderGetScale()\n  \\sa SDL_RenderSetLogicalSize()"]
    pub fn SDL_RenderSetScale(renderer: *mut SDL_Renderer, scaleX: f32, scaleY: f32)
        -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the drawing scale for the current target.\n\n  \\param renderer The renderer from which drawing scale should be queried.\n  \\param scaleX A pointer filled in with the horizontal scaling factor\n  \\param scaleY A pointer filled in with the vertical scaling factor\n\n  \\sa SDL_RenderSetScale()"]
    pub fn SDL_RenderGetScale(renderer: *mut SDL_Renderer, scaleX: *mut f32, scaleY: *mut f32);
}
extern "C" {
    #[doc = "  \\brief Set the color used for drawing operations (Rect, Line and Clear).\n\n  \\param renderer The renderer for which drawing color should be set.\n  \\param r The red value used to draw on the rendering target.\n  \\param g The green value used to draw on the rendering target.\n  \\param b The blue value used to draw on the rendering target.\n  \\param a The alpha value used to draw on the rendering target, usually\n           ::SDL_ALPHA_OPAQUE (255).\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_SetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: Uint8,
        g: Uint8,
        b: Uint8,
        a: Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the color used for drawing operations (Rect, Line and Clear).\n\n  \\param renderer The renderer from which drawing color should be queried.\n  \\param r A pointer to the red value used to draw on the rendering target.\n  \\param g A pointer to the green value used to draw on the rendering target.\n  \\param b A pointer to the blue value used to draw on the rendering target.\n  \\param a A pointer to the alpha value used to draw on the rendering target,\n           usually ::SDL_ALPHA_OPAQUE (255).\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_GetRenderDrawColor(
        renderer: *mut SDL_Renderer,
        r: *mut Uint8,
        g: *mut Uint8,
        b: *mut Uint8,
        a: *mut Uint8,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Set the blend mode used for drawing operations (Fill and Line).\n\n  \\param renderer The renderer for which blend mode should be set.\n  \\param blendMode ::SDL_BlendMode to use for blending.\n\n  \\return 0 on success, or -1 on error\n\n  \\note If the blend mode is not supported, the closest supported mode is\n        chosen.\n\n  \\sa SDL_GetRenderDrawBlendMode()"]
    pub fn SDL_SetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the blend mode used for drawing operations.\n\n  \\param renderer The renderer from which blend mode should be queried.\n  \\param blendMode A pointer filled in with the current blend mode.\n\n  \\return 0 on success, or -1 on error\n\n  \\sa SDL_SetRenderDrawBlendMode()"]
    pub fn SDL_GetRenderDrawBlendMode(
        renderer: *mut SDL_Renderer,
        blendMode: *mut SDL_BlendMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Clear the current rendering target with the drawing color\n\n  This function clears the entire rendering target, ignoring the viewport and\n  the clip rectangle.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderClear(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a point on the current rendering target.\n\n  \\param renderer The renderer which should draw a point.\n  \\param x The x coordinate of the point.\n  \\param y The y coordinate of the point.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPoint(
        renderer: *mut SDL_Renderer,
        x: libc::c_int,
        y: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw multiple points on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple points.\n  \\param points The points to draw\n  \\param count The number of points to draw\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPoints(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a line on the current rendering target.\n\n  \\param renderer The renderer which should draw a line.\n  \\param x1 The x coordinate of the start point.\n  \\param y1 The y coordinate of the start point.\n  \\param x2 The x coordinate of the end point.\n  \\param y2 The y coordinate of the end point.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLine(
        renderer: *mut SDL_Renderer,
        x1: libc::c_int,
        y1: libc::c_int,
        x2: libc::c_int,
        y2: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a series of connected lines on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple lines.\n  \\param points The points along the lines\n  \\param count The number of points, drawing count-1 lines\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLines(
        renderer: *mut SDL_Renderer,
        points: *const SDL_Point,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a rectangle on the current rendering target.\n\n  \\param renderer The renderer which should draw a rectangle.\n  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw some number of rectangles on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple rectangles.\n  \\param rects A pointer to an array of destination rectangles.\n  \\param count The number of rectangles.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color.\n\n  \\param renderer The renderer which should fill a rectangle.\n  \\param rect A pointer to the destination rectangle, or NULL for the entire\n              rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRect(renderer: *mut SDL_Renderer, rect: *const SDL_Rect) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color.\n\n  \\param renderer The renderer which should fill multiple rectangles.\n  \\param rects A pointer to an array of destination rectangles.\n  \\param count The number of rectangles.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRects(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_Rect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the texture to the current rendering target.\n\n  \\param renderer The renderer which should copy parts of a texture.\n  \\param texture The source texture.\n  \\param srcrect   A pointer to the source rectangle, or NULL for the entire\n                   texture.\n  \\param dstrect   A pointer to the destination rectangle, or NULL for the\n                   entire rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopy(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center\n\n  \\param renderer The renderer which should copy parts of a texture.\n  \\param texture The source texture.\n  \\param srcrect   A pointer to the source rectangle, or NULL for the entire\n                   texture.\n  \\param dstrect   A pointer to the destination rectangle, or NULL for the\n                   entire rendering target.\n  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction\n  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).\n  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyEx(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_Rect,
        angle: f64,
        center: *const SDL_Point,
        flip: SDL_RendererFlip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a point on the current rendering target.\n\n  \\param renderer The renderer which should draw a point.\n  \\param x The x coordinate of the point.\n  \\param y The y coordinate of the point.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPointF(renderer: *mut SDL_Renderer, x: f32, y: f32) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw multiple points on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple points.\n  \\param points The points to draw\n  \\param count The number of points to draw\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawPointsF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a line on the current rendering target.\n\n  \\param renderer The renderer which should draw a line.\n  \\param x1 The x coordinate of the start point.\n  \\param y1 The y coordinate of the start point.\n  \\param x2 The x coordinate of the end point.\n  \\param y2 The y coordinate of the end point.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLineF(
        renderer: *mut SDL_Renderer,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a series of connected lines on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple lines.\n  \\param points The points along the lines\n  \\param count The number of points, drawing count-1 lines\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawLinesF(
        renderer: *mut SDL_Renderer,
        points: *const SDL_FPoint,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw a rectangle on the current rendering target.\n\n  \\param renderer The renderer which should draw a rectangle.\n  \\param rect A pointer to the destination rectangle, or NULL to outline the entire rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Draw some number of rectangles on the current rendering target.\n\n  \\param renderer The renderer which should draw multiple rectangles.\n  \\param rects A pointer to an array of destination rectangles.\n  \\param count The number of rectangles.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderDrawRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill a rectangle on the current rendering target with the drawing color.\n\n  \\param renderer The renderer which should fill a rectangle.\n  \\param rect A pointer to the destination rectangle, or NULL for the entire\n              rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRectF(renderer: *mut SDL_Renderer, rect: *const SDL_FRect) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Fill some number of rectangles on the current rendering target with the drawing color.\n\n  \\param renderer The renderer which should fill multiple rectangles.\n  \\param rects A pointer to an array of destination rectangles.\n  \\param count The number of rectangles.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderFillRectsF(
        renderer: *mut SDL_Renderer,
        rects: *const SDL_FRect,
        count: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the texture to the current rendering target.\n\n  \\param renderer The renderer which should copy parts of a texture.\n  \\param texture The source texture.\n  \\param srcrect   A pointer to the source rectangle, or NULL for the entire\n                   texture.\n  \\param dstrect   A pointer to the destination rectangle, or NULL for the\n                   entire rendering target.\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Copy a portion of the source texture to the current rendering target, rotating it by angle around the given center\n\n  \\param renderer The renderer which should copy parts of a texture.\n  \\param texture The source texture.\n  \\param srcrect   A pointer to the source rectangle, or NULL for the entire\n                   texture.\n  \\param dstrect   A pointer to the destination rectangle, or NULL for the\n                   entire rendering target.\n  \\param angle    An angle in degrees that indicates the rotation that will be applied to dstrect, rotating it in a clockwise direction\n  \\param center   A pointer to a point indicating the point around which dstrect will be rotated (if NULL, rotation will be done around dstrect.w/2, dstrect.h/2).\n  \\param flip     An SDL_RendererFlip value stating which flipping actions should be performed on the texture\n\n  \\return 0 on success, or -1 on error"]
    pub fn SDL_RenderCopyExF(
        renderer: *mut SDL_Renderer,
        texture: *mut SDL_Texture,
        srcrect: *const SDL_Rect,
        dstrect: *const SDL_FRect,
        angle: f64,
        center: *const SDL_FPoint,
        flip: SDL_RendererFlip,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Read pixels from the current rendering target.\n\n  \\param renderer The renderer from which pixels should be read.\n  \\param rect   A pointer to the rectangle to read, or NULL for the entire\n                render target.\n  \\param format The desired format of the pixel data, or 0 to use the format\n                of the rendering target\n  \\param pixels A pointer to be filled in with the pixel data\n  \\param pitch  The pitch of the pixels parameter.\n\n  \\return 0 on success, or -1 if pixel reading is not supported.\n\n  \\warning This is a very slow operation, and should not be used frequently."]
    pub fn SDL_RenderReadPixels(
        renderer: *mut SDL_Renderer,
        rect: *const SDL_Rect,
        format: Uint32,
        pixels: *mut libc::c_void,
        pitch: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Update the screen with rendering performed."]
    pub fn SDL_RenderPresent(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = "  \\brief Destroy the specified texture.\n\n  \\sa SDL_CreateTexture()\n  \\sa SDL_CreateTextureFromSurface()"]
    pub fn SDL_DestroyTexture(texture: *mut SDL_Texture);
}
extern "C" {
    #[doc = "  \\brief Destroy the rendering context for a window and free associated\n         textures.\n\n  \\sa SDL_CreateRenderer()"]
    pub fn SDL_DestroyRenderer(renderer: *mut SDL_Renderer);
}
extern "C" {
    #[doc = "  \\brief Force the rendering context to flush any pending commands to the\n         underlying rendering API.\n\n  You do not need to (and in fact, shouldn't) call this function unless\n  you are planning to call into OpenGL/Direct3D/Metal/whatever directly\n  in addition to using an SDL_Renderer.\n\n  This is for a very-specific case: if you are using SDL's render API,\n  you asked for a specific renderer backend (OpenGL, Direct3D, etc),\n  you set SDL_HINT_RENDER_BATCHING to \"1\", and you plan to make\n  OpenGL/D3D/whatever calls in addition to SDL render API calls. If all of\n  this applies, you should call SDL_RenderFlush() between calls to SDL's\n  render API and the low-level API you're using in cooperation.\n\n  In all other cases, you can ignore this function. This is only here to\n  get maximum performance out of a specific situation. In all other cases,\n  SDL will do the right thing, perhaps at a performance loss.\n\n  This function is first available in SDL 2.0.10, and is not needed in\n  2.0.9 and earlier, as earlier versions did not queue rendering commands\n  at all, instead flushing them to the OS immediately."]
    pub fn SDL_RenderFlush(renderer: *mut SDL_Renderer) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Bind the texture to the current OpenGL/ES/ES2 context for use with\n         OpenGL instructions.\n\n  \\param texture  The SDL texture to bind\n  \\param texw     A pointer to a float that will be filled with the texture width\n  \\param texh     A pointer to a float that will be filled with the texture height\n\n  \\return 0 on success, or -1 if the operation is not supported"]
    pub fn SDL_GL_BindTexture(
        texture: *mut SDL_Texture,
        texw: *mut f32,
        texh: *mut f32,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Unbind a texture from the current OpenGL/ES/ES2 context.\n\n  \\param texture  The SDL texture to unbind\n\n  \\return 0 on success, or -1 if the operation is not supported"]
    pub fn SDL_GL_UnbindTexture(texture: *mut SDL_Texture) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the CAMetalLayer associated with the given Metal renderer\n\n  \\param renderer The renderer to query\n\n  \\return CAMetalLayer* on success, or NULL if the renderer isn't a Metal renderer\n\n  \\sa SDL_RenderGetMetalCommandEncoder()"]
    pub fn SDL_RenderGetMetalLayer(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
extern "C" {
    #[doc = "  \\brief Get the Metal command encoder for the current frame\n\n  \\param renderer The renderer to query\n\n  \\return id<MTLRenderCommandEncoder> on success, or NULL if the renderer isn't a Metal renderer\n\n  \\sa SDL_RenderGetMetalLayer()"]
    pub fn SDL_RenderGetMetalCommandEncoder(renderer: *mut SDL_Renderer) -> *mut libc::c_void;
}
#[doc = "  \\brief SDL_sensor.h\n\n  In order to use these functions, SDL_Init() must have been called\n  with the ::SDL_INIT_SENSOR flag.  This causes SDL to scan the system\n  for sensors, and load appropriate drivers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SDL_Sensor {
    _unused: [u8; 0],
}
pub type SDL_Sensor = _SDL_Sensor;
#[doc = " This is a unique ID for a sensor for the time it is connected to the system,\n and is never reused for the lifetime of the application.\n\n The ID value starts at 0 and increments from there. The value -1 is an invalid ID."]
pub type SDL_SensorID = Sint32;
#[doc = "< Returned for an invalid sensor"]
pub const SDL_SensorType_SDL_SENSOR_INVALID: SDL_SensorType = -1;
#[doc = "< Unknown sensor type"]
pub const SDL_SensorType_SDL_SENSOR_UNKNOWN: SDL_SensorType = 0;
#[doc = "< Accelerometer"]
pub const SDL_SensorType_SDL_SENSOR_ACCEL: SDL_SensorType = 1;
#[doc = "< Gyroscope"]
pub const SDL_SensorType_SDL_SENSOR_GYRO: SDL_SensorType = 2;
pub type SDL_SensorType = libc::c_int;
extern "C" {
    #[doc = "  \\brief Count the number of sensors attached to the system right now"]
    pub fn SDL_NumSensors() -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor name, or NULL if device_index is out of range."]
    pub fn SDL_SensorGetDeviceName(device_index: libc::c_int) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the type of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor type, or SDL_SENSOR_INVALID if device_index is out of range."]
    pub fn SDL_SensorGetDeviceType(device_index: libc::c_int) -> SDL_SensorType;
}
extern "C" {
    #[doc = "  \\brief Get the platform dependent type of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor platform dependent type, or -1 if device_index is out of range."]
    pub fn SDL_SensorGetDeviceNonPortableType(device_index: libc::c_int) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the instance ID of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor instance ID, or -1 if device_index is out of range."]
    pub fn SDL_SensorGetDeviceInstanceID(device_index: libc::c_int) -> SDL_SensorID;
}
extern "C" {
    #[doc = "  \\brief Open a sensor for use.\n\n  The index passed as an argument refers to the N'th sensor on the system.\n\n  \\return A sensor identifier, or NULL if an error occurred."]
    pub fn SDL_SensorOpen(device_index: libc::c_int) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = " Return the SDL_Sensor associated with an instance id."]
    pub fn SDL_SensorFromInstanceID(instance_id: SDL_SensorID) -> *mut SDL_Sensor;
}
extern "C" {
    #[doc = "  \\brief Get the implementation dependent name of a sensor.\n\n  \\return The sensor name, or NULL if the sensor is NULL."]
    pub fn SDL_SensorGetName(sensor: *mut SDL_Sensor) -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the type of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor type, or SDL_SENSOR_INVALID if the sensor is NULL."]
    pub fn SDL_SensorGetType(sensor: *mut SDL_Sensor) -> SDL_SensorType;
}
extern "C" {
    #[doc = "  \\brief Get the platform dependent type of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor platform dependent type, or -1 if the sensor is NULL."]
    pub fn SDL_SensorGetNonPortableType(sensor: *mut SDL_Sensor) -> libc::c_int;
}
extern "C" {
    #[doc = "  \\brief Get the instance ID of a sensor.\n\n  This can be called before any sensors are opened.\n\n  \\return The sensor instance ID, or -1 if the sensor is NULL."]
    pub fn SDL_SensorGetInstanceID(sensor: *mut SDL_Sensor) -> SDL_SensorID;
}
extern "C" {
    #[doc = "  Get the current state of an opened sensor.\n\n  The number of values and interpretation of the data is sensor dependent.\n\n  \\param sensor The sensor to query\n  \\param data A pointer filled with the current sensor state\n  \\param num_values The number of values to write to data\n\n  \\return 0 or -1 if an error occurred."]
    pub fn SDL_SensorGetData(
        sensor: *mut SDL_Sensor,
        data: *mut f32,
        num_values: libc::c_int,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = "  Close a sensor previously opened with SDL_SensorOpen()"]
    pub fn SDL_SensorClose(sensor: *mut SDL_Sensor);
}
extern "C" {
    #[doc = "  Update the current state of the open sensors.\n\n  This is called automatically by the event loop if sensor events are enabled.\n\n  This needs to be called from the thread that initialized the sensor subsystem."]
    pub fn SDL_SensorUpdate();
}
extern "C" {
    #[doc = "  \\brief Create a window that can be shaped with the specified position, dimensions, and flags.\n\n  \\param title The title of the window, in UTF-8 encoding.\n  \\param x     The x position of the window, ::SDL_WINDOWPOS_CENTERED, or\n               ::SDL_WINDOWPOS_UNDEFINED.\n  \\param y     The y position of the window, ::SDL_WINDOWPOS_CENTERED, or\n               ::SDL_WINDOWPOS_UNDEFINED.\n  \\param w     The width of the window.\n  \\param h     The height of the window.\n  \\param flags The flags for the window, a mask of SDL_WINDOW_BORDERLESS with any of the following:\n               ::SDL_WINDOW_OPENGL,     ::SDL_WINDOW_INPUT_GRABBED,\n               ::SDL_WINDOW_HIDDEN,     ::SDL_WINDOW_RESIZABLE,\n               ::SDL_WINDOW_MAXIMIZED,  ::SDL_WINDOW_MINIMIZED,\n       ::SDL_WINDOW_BORDERLESS is always set, and ::SDL_WINDOW_FULLSCREEN is always unset.\n\n  \\return The window created, or NULL if window creation failed.\n\n  \\sa SDL_DestroyWindow()"]
    pub fn SDL_CreateShapedWindow(
        title: *const libc::c_char,
        x: libc::c_uint,
        y: libc::c_uint,
        w: libc::c_uint,
        h: libc::c_uint,
        flags: Uint32,
    ) -> *mut SDL_Window;
}
extern "C" {
    #[doc = " \\brief Return whether the given window is a shaped window.\n\n \\param window The window to query for being shaped.\n\n \\return SDL_TRUE if the window is a window that can be shaped, SDL_FALSE if the window is unshaped or NULL.\n\n \\sa SDL_CreateShapedWindow"]
    pub fn SDL_IsShapedWindow(window: *const SDL_Window) -> SDL_bool;
}
#[doc = " \\brief The default mode, a binarized alpha cutoff of 1."]
pub const WindowShapeMode_ShapeModeDefault: WindowShapeMode = 0;
#[doc = " \\brief A binarized alpha cutoff with a given integer value."]
pub const WindowShapeMode_ShapeModeBinarizeAlpha: WindowShapeMode = 1;
#[doc = " \\brief A binarized alpha cutoff with a given integer value, but with the opposite comparison."]
pub const WindowShapeMode_ShapeModeReverseBinarizeAlpha: WindowShapeMode = 2;
#[doc = " \\brief A color key is applied."]
pub const WindowShapeMode_ShapeModeColorKey: WindowShapeMode = 3;
#[doc = " \\brief An enum denoting the specific type of contents present in an SDL_WindowShapeParams union."]
pub type WindowShapeMode = libc::c_int;
#[doc = " \\brief A union containing parameters for shaped windows."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union SDL_WindowShapeParams {
    #[doc = " \\brief A cutoff alpha value for binarization of the window shape's alpha channel."]
    pub binarizationCutoff: Uint8,
    pub colorKey: SDL_Color,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeParams() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowShapeParams> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeParams>(),
        4usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeParams))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).binarizationCutoff) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(binarizationCutoff)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colorKey) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeParams),
            "::",
            stringify!(colorKey)
        )
    );
}
#[doc = " \\brief A struct that tags the SDL_WindowShapeParams union with an enum describing the type of its contents."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct SDL_WindowShapeMode {
    #[doc = " \\brief The mode of these window-shape parameters."]
    pub mode: WindowShapeMode,
    #[doc = " \\brief Window-shape parameters."]
    pub parameters: SDL_WindowShapeParams,
}
#[test]
fn bindgen_test_layout_SDL_WindowShapeMode() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_WindowShapeMode> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_WindowShapeMode>(),
        8usize,
        concat!("Size of: ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_WindowShapeMode>(),
        4usize,
        concat!("Alignment of ", stringify!(SDL_WindowShapeMode))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).parameters) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_WindowShapeMode),
            "::",
            stringify!(parameters)
        )
    );
}
extern "C" {
    #[doc = " \\brief Set the shape and parameters of a shaped window.\n\n \\param window The shaped window whose parameters should be set.\n \\param shape A surface encoding the desired shape for the window.\n \\param shape_mode The parameters to set for the shaped window.\n\n \\return 0 on success, SDL_INVALID_SHAPE_ARGUMENT on an invalid shape argument, or SDL_NONSHAPEABLE_WINDOW\n           if the SDL_Window given does not reference a valid shaped window.\n\n \\sa SDL_WindowShapeMode\n \\sa SDL_GetShapedWindowMode."]
    pub fn SDL_SetWindowShape(
        window: *mut SDL_Window,
        shape: *mut SDL_Surface,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
extern "C" {
    #[doc = " \\brief Get the shape parameters of a shaped window.\n\n \\param window The shaped window whose parameters should be retrieved.\n \\param shape_mode An empty shape-mode structure to fill, or NULL to check whether the window has a shape.\n\n \\return 0 if the window has a shape and, provided shape_mode was not NULL, shape_mode has been filled with the mode\n           data, SDL_NONSHAPEABLE_WINDOW if the SDL_Window given is not a shaped window, or SDL_WINDOW_LACKS_SHAPE if\n           the SDL_Window given is a shapeable window currently lacking a shape.\n\n \\sa SDL_WindowShapeMode\n \\sa SDL_SetWindowShape"]
    pub fn SDL_GetShapedWindowMode(
        window: *mut SDL_Window,
        shape_mode: *mut SDL_WindowShapeMode,
    ) -> libc::c_int;
}
#[doc = "\\brief Set a function that is called for every windows message, before TranslateMessage()"]
pub type SDL_WindowsMessageHook = ::core::option::Option<
    unsafe extern "C" fn(
        userdata: *mut libc::c_void,
        hWnd: *mut libc::c_void,
        message: libc::c_uint,
        wParam: Uint64,
        lParam: Sint64,
    ),
>;
extern "C" {
    pub fn SDL_SetWindowsMessageHook(callback: SDL_WindowsMessageHook, userdata: *mut libc::c_void);
}
extern "C" {
    #[doc = "\\brief Returns the D3D9 adapter index that matches the specified display index.\n\nThis adapter index can be passed to IDirect3D9::CreateDevice and controls\non which monitor a full screen application will appear."]
    pub fn SDL_Direct3D9GetAdapterIndex(displayIndex: libc::c_int) -> libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IDirect3DDevice9 {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = "\\brief Returns the D3D device associated with a renderer, or NULL if it's not a D3D renderer.\n\nOnce you are done using the device, you should release it to avoid a resource leak."]
    pub fn SDL_RenderGetD3D9Device(renderer: *mut SDL_Renderer) -> *mut IDirect3DDevice9;
}
extern "C" {
    #[doc = "\\brief Returns the DXGI Adapter and Output indices for the specified display index.\n\nThese can be passed to EnumAdapters and EnumOutputs respectively to get the objects\nrequired to create a DX10 or DX11 device and swap chain."]
    pub fn SDL_DXGIGetOutputInfo(
        displayIndex: libc::c_int,
        adapterIndex: *mut libc::c_int,
        outputIndex: *mut libc::c_int,
    ) -> SDL_bool;
}
extern "C" {
    #[doc = "\\brief Return true if the current device is a tablet."]
    pub fn SDL_IsTablet() -> SDL_bool;
}
extern "C" {
    #[doc = " \\brief Get the number of milliseconds since the SDL library initialization.\n\n \\note This value wraps if the program runs for more than ~49 days."]
    pub fn SDL_GetTicks() -> Uint32;
}
extern "C" {
    #[doc = " \\brief Get the current value of the high resolution counter"]
    pub fn SDL_GetPerformanceCounter() -> Uint64;
}
extern "C" {
    #[doc = " \\brief Get the count per second of the high resolution counter"]
    pub fn SDL_GetPerformanceFrequency() -> Uint64;
}
extern "C" {
    #[doc = " \\brief Wait a specified number of milliseconds before returning."]
    pub fn SDL_Delay(ms: Uint32);
}
#[doc = "  Function prototype for the timer callback function.\n\n  The callback function is passed the current timer interval and returns\n  the next timer interval.  If the returned value is the same as the one\n  passed in, the periodic alarm continues, otherwise a new alarm is\n  scheduled.  If the callback returns 0, the periodic alarm is cancelled."]
pub type SDL_TimerCallback = ::core::option::Option<
    unsafe extern "C" fn(interval: Uint32, param: *mut libc::c_void) -> Uint32,
>;
#[doc = " Definition of the timer ID type."]
pub type SDL_TimerID = libc::c_int;
extern "C" {
    #[doc = " \\brief Add a new timer to the pool of timers already running.\n\n \\return A timer ID, or 0 when an error occurs."]
    pub fn SDL_AddTimer(
        interval: Uint32,
        callback: SDL_TimerCallback,
        param: *mut libc::c_void,
    ) -> SDL_TimerID;
}
extern "C" {
    #[doc = " \\brief Remove a timer knowing its ID.\n\n \\return A boolean value indicating success or failure.\n\n \\warning It is not safe to remove a timer multiple times."]
    pub fn SDL_RemoveTimer(id: SDL_TimerID) -> SDL_bool;
}
#[doc = "  \\brief Information the version of SDL in use.\n\n  Represents the library's version as three levels: major revision\n  (increments with massive changes, additions, and enhancements),\n  minor revision (increments with backwards-compatible changes to the\n  major revision), and patchlevel (increments with fixes to the minor\n  revision).\n\n  \\sa SDL_VERSION\n  \\sa SDL_GetVersion"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_version {
    #[doc = "< major version"]
    pub major: Uint8,
    #[doc = "< minor version"]
    pub minor: Uint8,
    #[doc = "< update version"]
    pub patch: Uint8,
}
#[test]
fn bindgen_test_layout_SDL_version() {
    const UNINIT: ::core::mem::MaybeUninit<SDL_version> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<SDL_version>(),
        3usize,
        concat!("Size of: ", stringify!(SDL_version))
    );
    assert_eq!(
        ::core::mem::align_of::<SDL_version>(),
        1usize,
        concat!("Alignment of ", stringify!(SDL_version))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SDL_version),
            "::",
            stringify!(patch)
        )
    );
}
extern "C" {
    #[doc = "  \\brief Get the version of SDL that is linked against your program.\n\n  If you are linking to SDL dynamically, then it is possible that the\n  current version will be different than the version you compiled against.\n  This function returns the current version, while SDL_VERSION() is a\n  macro that tells you what version you compiled with.\n\n  \\code\n  SDL_version compiled;\n  SDL_version linked;\n\n  SDL_VERSION(&compiled);\n  SDL_GetVersion(&linked);\n  printf(\"We compiled against SDL version %d.%d.%d ...\\n\",\n         compiled.major, compiled.minor, compiled.patch);\n  printf(\"But we linked against SDL version %d.%d.%d.\\n\",\n         linked.major, linked.minor, linked.patch);\n  \\endcode\n\n  This function may be called safely at any time, even before SDL_Init().\n\n  \\sa SDL_VERSION"]
    pub fn SDL_GetVersion(ver: *mut SDL_version);
}
extern "C" {
    #[doc = "  \\brief Get the code revision of SDL that is linked against your program.\n\n  Returns an arbitrary string (a hash value) uniquely identifying the\n  exact revision of the SDL library in use, and is only useful in comparing\n  against other revisions. It is NOT an incrementing number."]
    pub fn SDL_GetRevision() -> *const libc::c_char;
}
extern "C" {
    #[doc = "  \\brief Get the revision number of SDL that is linked against your program.\n\n  Returns a number uniquely identifying the exact revision of the SDL\n  library in use. It is an incrementing number based on commits to\n  hg.libsdl.org."]
    pub fn SDL_GetRevisionNumber() -> libc::c_int;
}
extern "C" {
    #[doc = "  This function initializes  the subsystems specified by \\c flags"]
    pub fn SDL_Init(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = "  This function initializes specific SDL subsystems\n\n  Subsystem initialization is ref-counted, you must call\n  SDL_QuitSubSystem() for each SDL_InitSubSystem() to correctly\n  shutdown a subsystem manually (or call SDL_Quit() to force shutdown).\n  If a subsystem is already loaded then this call will\n  increase the ref-count and return."]
    pub fn SDL_InitSubSystem(flags: Uint32) -> libc::c_int;
}
extern "C" {
    #[doc = "  This function cleans up specific SDL subsystems"]
    pub fn SDL_QuitSubSystem(flags: Uint32);
}
extern "C" {
    #[doc = "  This function returns a mask of the specified subsystems which have\n  previously been initialized.\n\n  If \\c flags is 0, it returns a mask of all initialized subsystems."]
    pub fn SDL_WasInit(flags: Uint32) -> Uint32;
}
extern "C" {
    #[doc = "  This function cleans up all initialized subsystems. You should\n  call it upon all exit conditions."]
    pub fn SDL_Quit();
}
pub type __builtin_va_list = *mut libc::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
#[doc = "< Private"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDL_BlitMap {
    pub _address: u8,
}
